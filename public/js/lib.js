/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/,
  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0]
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.text(escape(this.smartypants(cap[0])));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
	// explicitly match decimal, hex, and named HTML entities 
  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  mangle: true,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.moment=t()}(this,function(){"use strict";var e,i;function c(){return e.apply(null,arguments)}function o(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function u(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function l(e){return void 0===e}function h(e){return"number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function d(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function f(e,t){var n,s=[];for(n=0;n<e.length;++n)s.push(t(e[n],n));return s}function m(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function _(e,t){for(var n in t)m(t,n)&&(e[n]=t[n]);return m(t,"toString")&&(e.toString=t.toString),m(t,"valueOf")&&(e.valueOf=t.valueOf),e}function y(e,t,n,s){return Tt(e,t,n,s,!0).utc()}function g(e){return null==e._pf&&(e._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),e._pf}function v(e){if(null==e._isValid){var t=g(e),n=i.call(t.parsedDateParts,function(e){return null!=e}),s=!isNaN(e._d.getTime())&&t.overflow<0&&!t.empty&&!t.invalidMonth&&!t.invalidWeekday&&!t.weekdayMismatch&&!t.nullInput&&!t.invalidFormat&&!t.userInvalidated&&(!t.meridiem||t.meridiem&&n);if(e._strict&&(s=s&&0===t.charsLeftOver&&0===t.unusedTokens.length&&void 0===t.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return s;e._isValid=s}return e._isValid}function p(e){var t=y(NaN);return null!=e?_(g(t),e):g(t).userInvalidated=!0,t}i=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,s=0;s<n;s++)if(s in t&&e.call(this,t[s],s,t))return!0;return!1};var r=c.momentProperties=[];function w(e,t){var n,s,i;if(l(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),l(t._i)||(e._i=t._i),l(t._f)||(e._f=t._f),l(t._l)||(e._l=t._l),l(t._strict)||(e._strict=t._strict),l(t._tzm)||(e._tzm=t._tzm),l(t._isUTC)||(e._isUTC=t._isUTC),l(t._offset)||(e._offset=t._offset),l(t._pf)||(e._pf=g(t)),l(t._locale)||(e._locale=t._locale),0<r.length)for(n=0;n<r.length;n++)l(i=t[s=r[n]])||(e[s]=i);return e}var t=!1;function M(e){w(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===t&&(t=!0,c.updateOffset(this),t=!1)}function k(e){return e instanceof M||null!=e&&null!=e._isAMomentObject}function S(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function D(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=S(t)),n}function a(e,t,n){var s,i=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),a=0;for(s=0;s<i;s++)(n&&e[s]!==t[s]||!n&&D(e[s])!==D(t[s]))&&a++;return a+r}function Y(e){!1===c.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e)}function n(i,r){var a=!0;return _(function(){if(null!=c.deprecationHandler&&c.deprecationHandler(null,i),a){for(var e,t=[],n=0;n<arguments.length;n++){if(e="","object"==typeof arguments[n]){for(var s in e+="\n["+n+"] ",arguments[0])e+=s+": "+arguments[0][s]+", ";e=e.slice(0,-2)}else e=arguments[n];t.push(e)}Y(i+"\nArguments: "+Array.prototype.slice.call(t).join("")+"\n"+(new Error).stack),a=!1}return r.apply(this,arguments)},r)}var s,O={};function T(e,t){null!=c.deprecationHandler&&c.deprecationHandler(e,t),O[e]||(Y(t),O[e]=!0)}function b(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function x(e,t){var n,s=_({},e);for(n in t)m(t,n)&&(u(e[n])&&u(t[n])?(s[n]={},_(s[n],e[n]),_(s[n],t[n])):null!=t[n]?s[n]=t[n]:delete s[n]);for(n in e)m(e,n)&&!m(t,n)&&u(e[n])&&(s[n]=_({},s[n]));return s}function P(e){null!=e&&this.set(e)}c.suppressDeprecationWarnings=!1,c.deprecationHandler=null,s=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)m(e,t)&&n.push(t);return n};var W={};function C(e,t){var n=e.toLowerCase();W[n]=W[n+"s"]=W[t]=e}function H(e){return"string"==typeof e?W[e]||W[e.toLowerCase()]:void 0}function R(e){var t,n,s={};for(n in e)m(e,n)&&(t=H(n))&&(s[t]=e[n]);return s}var U={};function F(e,t){U[e]=t}function L(e,t,n){var s=""+Math.abs(e),i=t-s.length;return(0<=e?n?"+":"":"-")+Math.pow(10,Math.max(0,i)).toString().substr(1)+s}var N=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,G=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,V={},E={};function I(e,t,n,s){var i=s;"string"==typeof s&&(i=function(){return this[s]()}),e&&(E[e]=i),t&&(E[t[0]]=function(){return L(i.apply(this,arguments),t[1],t[2])}),n&&(E[n]=function(){return this.localeData().ordinal(i.apply(this,arguments),e)})}function A(e,t){return e.isValid()?(t=j(t,e.localeData()),V[t]=V[t]||function(s){var e,i,t,r=s.match(N);for(e=0,i=r.length;e<i;e++)E[r[e]]?r[e]=E[r[e]]:r[e]=(t=r[e]).match(/\[[\s\S]/)?t.replace(/^\[|\]$/g,""):t.replace(/\\/g,"");return function(e){var t,n="";for(t=0;t<i;t++)n+=b(r[t])?r[t].call(e,s):r[t];return n}}(t),V[t](e)):e.localeData().invalidDate()}function j(e,t){var n=5;function s(e){return t.longDateFormat(e)||e}for(G.lastIndex=0;0<=n&&G.test(e);)e=e.replace(G,s),G.lastIndex=0,n-=1;return e}var Z=/\d/,z=/\d\d/,$=/\d{3}/,q=/\d{4}/,J=/[+-]?\d{6}/,B=/\d\d?/,Q=/\d\d\d\d?/,X=/\d\d\d\d\d\d?/,K=/\d{1,3}/,ee=/\d{1,4}/,te=/[+-]?\d{1,6}/,ne=/\d+/,se=/[+-]?\d+/,ie=/Z|[+-]\d\d:?\d\d/gi,re=/Z|[+-]\d\d(?::?\d\d)?/gi,ae=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,oe={};function ue(e,n,s){oe[e]=b(n)?n:function(e,t){return e&&s?s:n}}function le(e,t){return m(oe,e)?oe[e](t._strict,t._locale):new RegExp(he(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,s,i){return t||n||s||i})))}function he(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var de={};function ce(e,n){var t,s=n;for("string"==typeof e&&(e=[e]),h(n)&&(s=function(e,t){t[n]=D(e)}),t=0;t<e.length;t++)de[e[t]]=s}function fe(e,i){ce(e,function(e,t,n,s){n._w=n._w||{},i(e,n._w,n,s)})}var me=0,_e=1,ye=2,ge=3,ve=4,pe=5,we=6,Me=7,ke=8;function Se(e){return De(e)?366:365}function De(e){return e%4==0&&e%100!=0||e%400==0}I("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),I(0,["YY",2],0,function(){return this.year()%100}),I(0,["YYYY",4],0,"year"),I(0,["YYYYY",5],0,"year"),I(0,["YYYYYY",6,!0],0,"year"),C("year","y"),F("year",1),ue("Y",se),ue("YY",B,z),ue("YYYY",ee,q),ue("YYYYY",te,J),ue("YYYYYY",te,J),ce(["YYYYY","YYYYYY"],me),ce("YYYY",function(e,t){t[me]=2===e.length?c.parseTwoDigitYear(e):D(e)}),ce("YY",function(e,t){t[me]=c.parseTwoDigitYear(e)}),ce("Y",function(e,t){t[me]=parseInt(e,10)}),c.parseTwoDigitYear=function(e){return D(e)+(68<D(e)?1900:2e3)};var Ye,Oe=Te("FullYear",!0);function Te(t,n){return function(e){return null!=e?(xe(this,t,e),c.updateOffset(this,n),this):be(this,t)}}function be(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function xe(e,t,n){e.isValid()&&!isNaN(n)&&("FullYear"===t&&De(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+t](n,e.month(),Pe(n,e.month())):e._d["set"+(e._isUTC?"UTC":"")+t](n))}function Pe(e,t){if(isNaN(e)||isNaN(t))return NaN;var n,s=(t%(n=12)+n)%n;return e+=(t-s)/12,1===s?De(e)?29:28:31-s%7%2}Ye=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;t<this.length;++t)if(this[t]===e)return t;return-1},I("M",["MM",2],"Mo",function(){return this.month()+1}),I("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),I("MMMM",0,0,function(e){return this.localeData().months(this,e)}),C("month","M"),F("month",8),ue("M",B),ue("MM",B,z),ue("MMM",function(e,t){return t.monthsShortRegex(e)}),ue("MMMM",function(e,t){return t.monthsRegex(e)}),ce(["M","MM"],function(e,t){t[_e]=D(e)-1}),ce(["MMM","MMMM"],function(e,t,n,s){var i=n._locale.monthsParse(e,s,n._strict);null!=i?t[_e]=i:g(n).invalidMonth=e});var We=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Ce="January_February_March_April_May_June_July_August_September_October_November_December".split("_");var He="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function Re(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=D(t);else if(!h(t=e.localeData().monthsParse(t)))return e;return n=Math.min(e.date(),Pe(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function Ue(e){return null!=e?(Re(this,e),c.updateOffset(this,!0),this):be(this,"Month")}var Fe=ae;var Le=ae;function Ne(){function e(e,t){return t.length-e.length}var t,n,s=[],i=[],r=[];for(t=0;t<12;t++)n=y([2e3,t]),s.push(this.monthsShort(n,"")),i.push(this.months(n,"")),r.push(this.months(n,"")),r.push(this.monthsShort(n,""));for(s.sort(e),i.sort(e),r.sort(e),t=0;t<12;t++)s[t]=he(s[t]),i[t]=he(i[t]);for(t=0;t<24;t++)r[t]=he(r[t]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+s.join("|")+")","i")}function Ge(e){var t;if(e<100&&0<=e){var n=Array.prototype.slice.call(arguments);n[0]=e+400,t=new Date(Date.UTC.apply(null,n)),isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e)}else t=new Date(Date.UTC.apply(null,arguments));return t}function Ve(e,t,n){var s=7+t-n;return-((7+Ge(e,0,s).getUTCDay()-t)%7)+s-1}function Ee(e,t,n,s,i){var r,a,o=1+7*(t-1)+(7+n-s)%7+Ve(e,s,i);return a=o<=0?Se(r=e-1)+o:o>Se(e)?(r=e+1,o-Se(e)):(r=e,o),{year:r,dayOfYear:a}}function Ie(e,t,n){var s,i,r=Ve(e.year(),t,n),a=Math.floor((e.dayOfYear()-r-1)/7)+1;return a<1?s=a+Ae(i=e.year()-1,t,n):a>Ae(e.year(),t,n)?(s=a-Ae(e.year(),t,n),i=e.year()+1):(i=e.year(),s=a),{week:s,year:i}}function Ae(e,t,n){var s=Ve(e,t,n),i=Ve(e+1,t,n);return(Se(e)-s+i)/7}I("w",["ww",2],"wo","week"),I("W",["WW",2],"Wo","isoWeek"),C("week","w"),C("isoWeek","W"),F("week",5),F("isoWeek",5),ue("w",B),ue("ww",B,z),ue("W",B),ue("WW",B,z),fe(["w","ww","W","WW"],function(e,t,n,s){t[s.substr(0,1)]=D(e)});function je(e,t){return e.slice(t,7).concat(e.slice(0,t))}I("d",0,"do","day"),I("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),I("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),I("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),I("e",0,0,"weekday"),I("E",0,0,"isoWeekday"),C("day","d"),C("weekday","e"),C("isoWeekday","E"),F("day",11),F("weekday",11),F("isoWeekday",11),ue("d",B),ue("e",B),ue("E",B),ue("dd",function(e,t){return t.weekdaysMinRegex(e)}),ue("ddd",function(e,t){return t.weekdaysShortRegex(e)}),ue("dddd",function(e,t){return t.weekdaysRegex(e)}),fe(["dd","ddd","dddd"],function(e,t,n,s){var i=n._locale.weekdaysParse(e,s,n._strict);null!=i?t.d=i:g(n).invalidWeekday=e}),fe(["d","e","E"],function(e,t,n,s){t[s]=D(e)});var Ze="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");var ze="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");var $e="Su_Mo_Tu_We_Th_Fr_Sa".split("_");var qe=ae;var Je=ae;var Be=ae;function Qe(){function e(e,t){return t.length-e.length}var t,n,s,i,r,a=[],o=[],u=[],l=[];for(t=0;t<7;t++)n=y([2e3,1]).day(t),s=this.weekdaysMin(n,""),i=this.weekdaysShort(n,""),r=this.weekdays(n,""),a.push(s),o.push(i),u.push(r),l.push(s),l.push(i),l.push(r);for(a.sort(e),o.sort(e),u.sort(e),l.sort(e),t=0;t<7;t++)o[t]=he(o[t]),u[t]=he(u[t]),l[t]=he(l[t]);this._weekdaysRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+o.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+a.join("|")+")","i")}function Xe(){return this.hours()%12||12}function Ke(e,t){I(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)})}function et(e,t){return t._meridiemParse}I("H",["HH",2],0,"hour"),I("h",["hh",2],0,Xe),I("k",["kk",2],0,function(){return this.hours()||24}),I("hmm",0,0,function(){return""+Xe.apply(this)+L(this.minutes(),2)}),I("hmmss",0,0,function(){return""+Xe.apply(this)+L(this.minutes(),2)+L(this.seconds(),2)}),I("Hmm",0,0,function(){return""+this.hours()+L(this.minutes(),2)}),I("Hmmss",0,0,function(){return""+this.hours()+L(this.minutes(),2)+L(this.seconds(),2)}),Ke("a",!0),Ke("A",!1),C("hour","h"),F("hour",13),ue("a",et),ue("A",et),ue("H",B),ue("h",B),ue("k",B),ue("HH",B,z),ue("hh",B,z),ue("kk",B,z),ue("hmm",Q),ue("hmmss",X),ue("Hmm",Q),ue("Hmmss",X),ce(["H","HH"],ge),ce(["k","kk"],function(e,t,n){var s=D(e);t[ge]=24===s?0:s}),ce(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e}),ce(["h","hh"],function(e,t,n){t[ge]=D(e),g(n).bigHour=!0}),ce("hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s)),g(n).bigHour=!0}),ce("hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i)),g(n).bigHour=!0}),ce("Hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s))}),ce("Hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i))});var tt,nt=Te("Hours",!0),st={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Ce,monthsShort:He,week:{dow:0,doy:6},weekdays:Ze,weekdaysMin:$e,weekdaysShort:ze,meridiemParse:/[ap]\.?m?\.?/i},it={},rt={};function at(e){return e?e.toLowerCase().replace("_","-"):e}function ot(e){var t=null;if(!it[e]&&"undefined"!=typeof module&&module&&module.exports)try{t=tt._abbr,require("./locale/"+e),ut(t)}catch(e){}return it[e]}function ut(e,t){var n;return e&&((n=l(t)?ht(e):lt(e,t))?tt=n:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+e+" not found. Did you forget to load it?")),tt._abbr}function lt(e,t){if(null===t)return delete it[e],null;var n,s=st;if(t.abbr=e,null!=it[e])T("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),s=it[e]._config;else if(null!=t.parentLocale)if(null!=it[t.parentLocale])s=it[t.parentLocale]._config;else{if(null==(n=ot(t.parentLocale)))return rt[t.parentLocale]||(rt[t.parentLocale]=[]),rt[t.parentLocale].push({name:e,config:t}),null;s=n._config}return it[e]=new P(x(s,t)),rt[e]&&rt[e].forEach(function(e){lt(e.name,e.config)}),ut(e),it[e]}function ht(e){var t;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return tt;if(!o(e)){if(t=ot(e))return t;e=[e]}return function(e){for(var t,n,s,i,r=0;r<e.length;){for(t=(i=at(e[r]).split("-")).length,n=(n=at(e[r+1]))?n.split("-"):null;0<t;){if(s=ot(i.slice(0,t).join("-")))return s;if(n&&n.length>=t&&a(i,n,!0)>=t-1)break;t--}r++}return tt}(e)}function dt(e){var t,n=e._a;return n&&-2===g(e).overflow&&(t=n[_e]<0||11<n[_e]?_e:n[ye]<1||n[ye]>Pe(n[me],n[_e])?ye:n[ge]<0||24<n[ge]||24===n[ge]&&(0!==n[ve]||0!==n[pe]||0!==n[we])?ge:n[ve]<0||59<n[ve]?ve:n[pe]<0||59<n[pe]?pe:n[we]<0||999<n[we]?we:-1,g(e)._overflowDayOfYear&&(t<me||ye<t)&&(t=ye),g(e)._overflowWeeks&&-1===t&&(t=Me),g(e)._overflowWeekday&&-1===t&&(t=ke),g(e).overflow=t),e}function ct(e,t,n){return null!=e?e:null!=t?t:n}function ft(e){var t,n,s,i,r,a=[];if(!e._d){var o,u;for(o=e,u=new Date(c.now()),s=o._useUTC?[u.getUTCFullYear(),u.getUTCMonth(),u.getUTCDate()]:[u.getFullYear(),u.getMonth(),u.getDate()],e._w&&null==e._a[ye]&&null==e._a[_e]&&function(e){var t,n,s,i,r,a,o,u;if(null!=(t=e._w).GG||null!=t.W||null!=t.E)r=1,a=4,n=ct(t.GG,e._a[me],Ie(bt(),1,4).year),s=ct(t.W,1),((i=ct(t.E,1))<1||7<i)&&(u=!0);else{r=e._locale._week.dow,a=e._locale._week.doy;var l=Ie(bt(),r,a);n=ct(t.gg,e._a[me],l.year),s=ct(t.w,l.week),null!=t.d?((i=t.d)<0||6<i)&&(u=!0):null!=t.e?(i=t.e+r,(t.e<0||6<t.e)&&(u=!0)):i=r}s<1||s>Ae(n,r,a)?g(e)._overflowWeeks=!0:null!=u?g(e)._overflowWeekday=!0:(o=Ee(n,s,i,r,a),e._a[me]=o.year,e._dayOfYear=o.dayOfYear)}(e),null!=e._dayOfYear&&(r=ct(e._a[me],s[me]),(e._dayOfYear>Se(r)||0===e._dayOfYear)&&(g(e)._overflowDayOfYear=!0),n=Ge(r,0,e._dayOfYear),e._a[_e]=n.getUTCMonth(),e._a[ye]=n.getUTCDate()),t=0;t<3&&null==e._a[t];++t)e._a[t]=a[t]=s[t];for(;t<7;t++)e._a[t]=a[t]=null==e._a[t]?2===t?1:0:e._a[t];24===e._a[ge]&&0===e._a[ve]&&0===e._a[pe]&&0===e._a[we]&&(e._nextDay=!0,e._a[ge]=0),e._d=(e._useUTC?Ge:function(e,t,n,s,i,r,a){var o;return e<100&&0<=e?(o=new Date(e+400,t,n,s,i,r,a),isFinite(o.getFullYear())&&o.setFullYear(e)):o=new Date(e,t,n,s,i,r,a),o}).apply(null,a),i=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[ge]=24),e._w&&void 0!==e._w.d&&e._w.d!==i&&(g(e).weekdayMismatch=!0)}}var mt=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,_t=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,yt=/Z|[+-]\d\d(?::?\d\d)?/,gt=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],vt=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],pt=/^\/?Date\((\-?\d+)/i;function wt(e){var t,n,s,i,r,a,o=e._i,u=mt.exec(o)||_t.exec(o);if(u){for(g(e).iso=!0,t=0,n=gt.length;t<n;t++)if(gt[t][1].exec(u[1])){i=gt[t][0],s=!1!==gt[t][2];break}if(null==i)return void(e._isValid=!1);if(u[3]){for(t=0,n=vt.length;t<n;t++)if(vt[t][1].exec(u[3])){r=(u[2]||" ")+vt[t][0];break}if(null==r)return void(e._isValid=!1)}if(!s&&null!=r)return void(e._isValid=!1);if(u[4]){if(!yt.exec(u[4]))return void(e._isValid=!1);a="Z"}e._f=i+(r||"")+(a||""),Yt(e)}else e._isValid=!1}var Mt=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function kt(e,t,n,s,i,r){var a=[function(e){var t=parseInt(e,10);{if(t<=49)return 2e3+t;if(t<=999)return 1900+t}return t}(e),He.indexOf(t),parseInt(n,10),parseInt(s,10),parseInt(i,10)];return r&&a.push(parseInt(r,10)),a}var St={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Dt(e){var t,n,s,i=Mt.exec(e._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,""));if(i){var r=kt(i[4],i[3],i[2],i[5],i[6],i[7]);if(t=i[1],n=r,s=e,t&&ze.indexOf(t)!==new Date(n[0],n[1],n[2]).getDay()&&(g(s).weekdayMismatch=!0,!(s._isValid=!1)))return;e._a=r,e._tzm=function(e,t,n){if(e)return St[e];if(t)return 0;var s=parseInt(n,10),i=s%100;return(s-i)/100*60+i}(i[8],i[9],i[10]),e._d=Ge.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),g(e).rfc2822=!0}else e._isValid=!1}function Yt(e){if(e._f!==c.ISO_8601)if(e._f!==c.RFC_2822){e._a=[],g(e).empty=!0;var t,n,s,i,r,a,o,u,l=""+e._i,h=l.length,d=0;for(s=j(e._f,e._locale).match(N)||[],t=0;t<s.length;t++)i=s[t],(n=(l.match(le(i,e))||[])[0])&&(0<(r=l.substr(0,l.indexOf(n))).length&&g(e).unusedInput.push(r),l=l.slice(l.indexOf(n)+n.length),d+=n.length),E[i]?(n?g(e).empty=!1:g(e).unusedTokens.push(i),a=i,u=e,null!=(o=n)&&m(de,a)&&de[a](o,u._a,u,a)):e._strict&&!n&&g(e).unusedTokens.push(i);g(e).charsLeftOver=h-d,0<l.length&&g(e).unusedInput.push(l),e._a[ge]<=12&&!0===g(e).bigHour&&0<e._a[ge]&&(g(e).bigHour=void 0),g(e).parsedDateParts=e._a.slice(0),g(e).meridiem=e._meridiem,e._a[ge]=function(e,t,n){var s;if(null==n)return t;return null!=e.meridiemHour?e.meridiemHour(t,n):(null!=e.isPM&&((s=e.isPM(n))&&t<12&&(t+=12),s||12!==t||(t=0)),t)}(e._locale,e._a[ge],e._meridiem),ft(e),dt(e)}else Dt(e);else wt(e)}function Ot(e){var t,n,s,i,r=e._i,a=e._f;return e._locale=e._locale||ht(e._l),null===r||void 0===a&&""===r?p({nullInput:!0}):("string"==typeof r&&(e._i=r=e._locale.preparse(r)),k(r)?new M(dt(r)):(d(r)?e._d=r:o(a)?function(e){var t,n,s,i,r;if(0===e._f.length)return g(e).invalidFormat=!0,e._d=new Date(NaN);for(i=0;i<e._f.length;i++)r=0,t=w({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[i],Yt(t),v(t)&&(r+=g(t).charsLeftOver,r+=10*g(t).unusedTokens.length,g(t).score=r,(null==s||r<s)&&(s=r,n=t));_(e,n||t)}(e):a?Yt(e):l(n=(t=e)._i)?t._d=new Date(c.now()):d(n)?t._d=new Date(n.valueOf()):"string"==typeof n?(s=t,null===(i=pt.exec(s._i))?(wt(s),!1===s._isValid&&(delete s._isValid,Dt(s),!1===s._isValid&&(delete s._isValid,c.createFromInputFallback(s)))):s._d=new Date(+i[1])):o(n)?(t._a=f(n.slice(0),function(e){return parseInt(e,10)}),ft(t)):u(n)?function(e){if(!e._d){var t=R(e._i);e._a=f([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),ft(e)}}(t):h(n)?t._d=new Date(n):c.createFromInputFallback(t),v(e)||(e._d=null),e))}function Tt(e,t,n,s,i){var r,a={};return!0!==n&&!1!==n||(s=n,n=void 0),(u(e)&&function(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var t;for(t in e)if(e.hasOwnProperty(t))return!1;return!0}(e)||o(e)&&0===e.length)&&(e=void 0),a._isAMomentObject=!0,a._useUTC=a._isUTC=i,a._l=n,a._i=e,a._f=t,a._strict=s,(r=new M(dt(Ot(a))))._nextDay&&(r.add(1,"d"),r._nextDay=void 0),r}function bt(e,t,n,s){return Tt(e,t,n,s,!1)}c.createFromInputFallback=n("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""))}),c.ISO_8601=function(){},c.RFC_2822=function(){};var xt=n("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:p()}),Pt=n("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?this<e?this:e:p()});function Wt(e,t){var n,s;if(1===t.length&&o(t[0])&&(t=t[0]),!t.length)return bt();for(n=t[0],s=1;s<t.length;++s)t[s].isValid()&&!t[s][e](n)||(n=t[s]);return n}var Ct=["year","quarter","month","week","day","hour","minute","second","millisecond"];function Ht(e){var t=R(e),n=t.year||0,s=t.quarter||0,i=t.month||0,r=t.week||t.isoWeek||0,a=t.day||0,o=t.hour||0,u=t.minute||0,l=t.second||0,h=t.millisecond||0;this._isValid=function(e){for(var t in e)if(-1===Ye.call(Ct,t)||null!=e[t]&&isNaN(e[t]))return!1;for(var n=!1,s=0;s<Ct.length;++s)if(e[Ct[s]]){if(n)return!1;parseFloat(e[Ct[s]])!==D(e[Ct[s]])&&(n=!0)}return!0}(t),this._milliseconds=+h+1e3*l+6e4*u+1e3*o*60*60,this._days=+a+7*r,this._months=+i+3*s+12*n,this._data={},this._locale=ht(),this._bubble()}function Rt(e){return e instanceof Ht}function Ut(e){return e<0?-1*Math.round(-1*e):Math.round(e)}function Ft(e,n){I(e,0,0,function(){var e=this.utcOffset(),t="+";return e<0&&(e=-e,t="-"),t+L(~~(e/60),2)+n+L(~~e%60,2)})}Ft("Z",":"),Ft("ZZ",""),ue("Z",re),ue("ZZ",re),ce(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=Nt(re,e)});var Lt=/([\+\-]|\d\d)/gi;function Nt(e,t){var n=(t||"").match(e);if(null===n)return null;var s=((n[n.length-1]||[])+"").match(Lt)||["-",0,0],i=60*s[1]+D(s[2]);return 0===i?0:"+"===s[0]?i:-i}function Gt(e,t){var n,s;return t._isUTC?(n=t.clone(),s=(k(e)||d(e)?e.valueOf():bt(e).valueOf())-n.valueOf(),n._d.setTime(n._d.valueOf()+s),c.updateOffset(n,!1),n):bt(e).local()}function Vt(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Et(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}c.updateOffset=function(){};var It=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,At=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function jt(e,t){var n,s,i,r=e,a=null;return Rt(e)?r={ms:e._milliseconds,d:e._days,M:e._months}:h(e)?(r={},t?r[t]=e:r.milliseconds=e):(a=It.exec(e))?(n="-"===a[1]?-1:1,r={y:0,d:D(a[ye])*n,h:D(a[ge])*n,m:D(a[ve])*n,s:D(a[pe])*n,ms:D(Ut(1e3*a[we]))*n}):(a=At.exec(e))?(n="-"===a[1]?-1:1,r={y:Zt(a[2],n),M:Zt(a[3],n),w:Zt(a[4],n),d:Zt(a[5],n),h:Zt(a[6],n),m:Zt(a[7],n),s:Zt(a[8],n)}):null==r?r={}:"object"==typeof r&&("from"in r||"to"in r)&&(i=function(e,t){var n;if(!e.isValid()||!t.isValid())return{milliseconds:0,months:0};t=Gt(t,e),e.isBefore(t)?n=zt(e,t):((n=zt(t,e)).milliseconds=-n.milliseconds,n.months=-n.months);return n}(bt(r.from),bt(r.to)),(r={}).ms=i.milliseconds,r.M=i.months),s=new Ht(r),Rt(e)&&m(e,"_locale")&&(s._locale=e._locale),s}function Zt(e,t){var n=e&&parseFloat(e.replace(",","."));return(isNaN(n)?0:n)*t}function zt(e,t){var n={};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function $t(s,i){return function(e,t){var n;return null===t||isNaN(+t)||(T(i,"moment()."+i+"(period, number) is deprecated. Please use moment()."+i+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),n=e,e=t,t=n),qt(this,jt(e="string"==typeof e?+e:e,t),s),this}}function qt(e,t,n,s){var i=t._milliseconds,r=Ut(t._days),a=Ut(t._months);e.isValid()&&(s=null==s||s,a&&Re(e,be(e,"Month")+a*n),r&&xe(e,"Date",be(e,"Date")+r*n),i&&e._d.setTime(e._d.valueOf()+i*n),s&&c.updateOffset(e,r||a))}jt.fn=Ht.prototype,jt.invalid=function(){return jt(NaN)};var Jt=$t(1,"add"),Bt=$t(-1,"subtract");function Qt(e,t){var n=12*(t.year()-e.year())+(t.month()-e.month()),s=e.clone().add(n,"months");return-(n+(t-s<0?(t-s)/(s-e.clone().add(n-1,"months")):(t-s)/(e.clone().add(n+1,"months")-s)))||0}function Xt(e){var t;return void 0===e?this._locale._abbr:(null!=(t=ht(e))&&(this._locale=t),this)}c.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",c.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Kt=n("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});function en(){return this._locale}var tn=126227808e5;function nn(e,t){return(e%t+t)%t}function sn(e,t,n){return e<100&&0<=e?new Date(e+400,t,n)-tn:new Date(e,t,n).valueOf()}function rn(e,t,n){return e<100&&0<=e?Date.UTC(e+400,t,n)-tn:Date.UTC(e,t,n)}function an(e,t){I(0,[e,e.length],0,t)}function on(e,t,n,s,i){var r;return null==e?Ie(this,s,i).year:((r=Ae(e,s,i))<t&&(t=r),function(e,t,n,s,i){var r=Ee(e,t,n,s,i),a=Ge(r.year,0,r.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}.call(this,e,t,n,s,i))}I(0,["gg",2],0,function(){return this.weekYear()%100}),I(0,["GG",2],0,function(){return this.isoWeekYear()%100}),an("gggg","weekYear"),an("ggggg","weekYear"),an("GGGG","isoWeekYear"),an("GGGGG","isoWeekYear"),C("weekYear","gg"),C("isoWeekYear","GG"),F("weekYear",1),F("isoWeekYear",1),ue("G",se),ue("g",se),ue("GG",B,z),ue("gg",B,z),ue("GGGG",ee,q),ue("gggg",ee,q),ue("GGGGG",te,J),ue("ggggg",te,J),fe(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,s){t[s.substr(0,2)]=D(e)}),fe(["gg","GG"],function(e,t,n,s){t[s]=c.parseTwoDigitYear(e)}),I("Q",0,"Qo","quarter"),C("quarter","Q"),F("quarter",7),ue("Q",Z),ce("Q",function(e,t){t[_e]=3*(D(e)-1)}),I("D",["DD",2],"Do","date"),C("date","D"),F("date",9),ue("D",B),ue("DD",B,z),ue("Do",function(e,t){return e?t._dayOfMonthOrdinalParse||t._ordinalParse:t._dayOfMonthOrdinalParseLenient}),ce(["D","DD"],ye),ce("Do",function(e,t){t[ye]=D(e.match(B)[0])});var un=Te("Date",!0);I("DDD",["DDDD",3],"DDDo","dayOfYear"),C("dayOfYear","DDD"),F("dayOfYear",4),ue("DDD",K),ue("DDDD",$),ce(["DDD","DDDD"],function(e,t,n){n._dayOfYear=D(e)}),I("m",["mm",2],0,"minute"),C("minute","m"),F("minute",14),ue("m",B),ue("mm",B,z),ce(["m","mm"],ve);var ln=Te("Minutes",!1);I("s",["ss",2],0,"second"),C("second","s"),F("second",15),ue("s",B),ue("ss",B,z),ce(["s","ss"],pe);var hn,dn=Te("Seconds",!1);for(I("S",0,0,function(){return~~(this.millisecond()/100)}),I(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),I(0,["SSS",3],0,"millisecond"),I(0,["SSSS",4],0,function(){return 10*this.millisecond()}),I(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),I(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),I(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),I(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),I(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),C("millisecond","ms"),F("millisecond",16),ue("S",K,Z),ue("SS",K,z),ue("SSS",K,$),hn="SSSS";hn.length<=9;hn+="S")ue(hn,ne);function cn(e,t){t[we]=D(1e3*("0."+e))}for(hn="S";hn.length<=9;hn+="S")ce(hn,cn);var fn=Te("Milliseconds",!1);I("z",0,0,"zoneAbbr"),I("zz",0,0,"zoneName");var mn=M.prototype;function _n(e){return e}mn.add=Jt,mn.calendar=function(e,t){var n=e||bt(),s=Gt(n,this).startOf("day"),i=c.calendarFormat(this,s)||"sameElse",r=t&&(b(t[i])?t[i].call(this,n):t[i]);return this.format(r||this.localeData().calendar(i,this,bt(n)))},mn.clone=function(){return new M(this)},mn.diff=function(e,t,n){var s,i,r;if(!this.isValid())return NaN;if(!(s=Gt(e,this)).isValid())return NaN;switch(i=6e4*(s.utcOffset()-this.utcOffset()),t=H(t)){case"year":r=Qt(this,s)/12;break;case"month":r=Qt(this,s);break;case"quarter":r=Qt(this,s)/3;break;case"second":r=(this-s)/1e3;break;case"minute":r=(this-s)/6e4;break;case"hour":r=(this-s)/36e5;break;case"day":r=(this-s-i)/864e5;break;case"week":r=(this-s-i)/6048e5;break;default:r=this-s}return n?r:S(r)},mn.endOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year()+1,0,1)-1;break;case"quarter":t=n(this.year(),this.month()-this.month()%3+3,1)-1;break;case"month":t=n(this.year(),this.month()+1,1)-1;break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday()+7)-1;break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1)+7)-1;break;case"day":case"date":t=n(this.year(),this.month(),this.date()+1)-1;break;case"hour":t=this._d.valueOf(),t+=36e5-nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5)-1;break;case"minute":t=this._d.valueOf(),t+=6e4-nn(t,6e4)-1;break;case"second":t=this._d.valueOf(),t+=1e3-nn(t,1e3)-1;break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.format=function(e){e||(e=this.isUtc()?c.defaultFormatUtc:c.defaultFormat);var t=A(this,e);return this.localeData().postformat(t)},mn.from=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.fromNow=function(e){return this.from(bt(),e)},mn.to=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.toNow=function(e){return this.to(bt(),e)},mn.get=function(e){return b(this[e=H(e)])?this[e]():this},mn.invalidAt=function(){return g(this).overflow},mn.isAfter=function(e,t){var n=k(e)?e:bt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())},mn.isBefore=function(e,t){var n=k(e)?e:bt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())},mn.isBetween=function(e,t,n,s){var i=k(e)?e:bt(e),r=k(t)?t:bt(t);return!!(this.isValid()&&i.isValid()&&r.isValid())&&("("===(s=s||"()")[0]?this.isAfter(i,n):!this.isBefore(i,n))&&(")"===s[1]?this.isBefore(r,n):!this.isAfter(r,n))},mn.isSame=function(e,t){var n,s=k(e)?e:bt(e);return!(!this.isValid()||!s.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()===s.valueOf():(n=s.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))},mn.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)},mn.isSameOrBefore=function(e,t){return this.isSame(e,t)||this.isBefore(e,t)},mn.isValid=function(){return v(this)},mn.lang=Kt,mn.locale=Xt,mn.localeData=en,mn.max=Pt,mn.min=xt,mn.parsingFlags=function(){return _({},g(this))},mn.set=function(e,t){if("object"==typeof e)for(var n=function(e){var t=[];for(var n in e)t.push({unit:n,priority:U[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}(e=R(e)),s=0;s<n.length;s++)this[n[s].unit](e[n[s].unit]);else if(b(this[e=H(e)]))return this[e](t);return this},mn.startOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year(),0,1);break;case"quarter":t=n(this.year(),this.month()-this.month()%3,1);break;case"month":t=n(this.year(),this.month(),1);break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday());break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1));break;case"day":case"date":t=n(this.year(),this.month(),this.date());break;case"hour":t=this._d.valueOf(),t-=nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5);break;case"minute":t=this._d.valueOf(),t-=nn(t,6e4);break;case"second":t=this._d.valueOf(),t-=nn(t,1e3);break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.subtract=Bt,mn.toArray=function(){var e=this;return[e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]},mn.toObject=function(){var e=this;return{years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}},mn.toDate=function(){return new Date(this.valueOf())},mn.toISOString=function(e){if(!this.isValid())return null;var t=!0!==e,n=t?this.clone().utc():this;return n.year()<0||9999<n.year()?A(n,t?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):b(Date.prototype.toISOString)?t?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",A(n,"Z")):A(n,t?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},mn.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");var n="["+e+'("]',s=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",i=t+'[")]';return this.format(n+s+"-MM-DD[T]HH:mm:ss.SSS"+i)},mn.toJSON=function(){return this.isValid()?this.toISOString():null},mn.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},mn.unix=function(){return Math.floor(this.valueOf()/1e3)},mn.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},mn.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},mn.year=Oe,mn.isLeapYear=function(){return De(this.year())},mn.weekYear=function(e){return on.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},mn.isoWeekYear=function(e){return on.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)},mn.quarter=mn.quarters=function(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)},mn.month=Ue,mn.daysInMonth=function(){return Pe(this.year(),this.month())},mn.week=mn.weeks=function(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")},mn.isoWeek=mn.isoWeeks=function(e){var t=Ie(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")},mn.weeksInYear=function(){var e=this.localeData()._week;return Ae(this.year(),e.dow,e.doy)},mn.isoWeeksInYear=function(){return Ae(this.year(),1,4)},mn.date=un,mn.day=mn.days=function(e){if(!this.isValid())return null!=e?this:NaN;var t,n,s=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(t=e,n=this.localeData(),e="string"!=typeof t?t:isNaN(t)?"number"==typeof(t=n.weekdaysParse(t))?t:null:parseInt(t,10),this.add(e-s,"d")):s},mn.weekday=function(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")},mn.isoWeekday=function(e){if(!this.isValid())return null!=e?this:NaN;if(null==e)return this.day()||7;var t,n,s=(t=e,n=this.localeData(),"string"==typeof t?n.weekdaysParse(t)%7||7:isNaN(t)?null:t);return this.day(this.day()%7?s:s-7)},mn.dayOfYear=function(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")},mn.hour=mn.hours=nt,mn.minute=mn.minutes=ln,mn.second=mn.seconds=dn,mn.millisecond=mn.milliseconds=fn,mn.utcOffset=function(e,t,n){var s,i=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null==e)return this._isUTC?i:Vt(this);if("string"==typeof e){if(null===(e=Nt(re,e)))return this}else Math.abs(e)<16&&!n&&(e*=60);return!this._isUTC&&t&&(s=Vt(this)),this._offset=e,this._isUTC=!0,null!=s&&this.add(s,"m"),i!==e&&(!t||this._changeInProgress?qt(this,jt(e-i,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,c.updateOffset(this,!0),this._changeInProgress=null)),this},mn.utc=function(e){return this.utcOffset(0,e)},mn.local=function(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Vt(this),"m")),this},mn.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=Nt(ie,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0)}return this},mn.hasAlignedHourOffset=function(e){return!!this.isValid()&&(e=e?bt(e).utcOffset():0,(this.utcOffset()-e)%60==0)},mn.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},mn.isLocal=function(){return!!this.isValid()&&!this._isUTC},mn.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},mn.isUtc=Et,mn.isUTC=Et,mn.zoneAbbr=function(){return this._isUTC?"UTC":""},mn.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},mn.dates=n("dates accessor is deprecated. Use date instead.",un),mn.months=n("months accessor is deprecated. Use month instead",Ue),mn.years=n("years accessor is deprecated. Use year instead",Oe),mn.zone=n("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",function(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}),mn.isDSTShifted=n("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",function(){if(!l(this._isDSTShifted))return this._isDSTShifted;var e={};if(w(e,this),(e=Ot(e))._a){var t=e._isUTC?y(e._a):bt(e._a);this._isDSTShifted=this.isValid()&&0<a(e._a,t.toArray())}else this._isDSTShifted=!1;return this._isDSTShifted});var yn=P.prototype;function gn(e,t,n,s){var i=ht(),r=y().set(s,t);return i[n](r,e)}function vn(e,t,n){if(h(e)&&(t=e,e=void 0),e=e||"",null!=t)return gn(e,t,n,"month");var s,i=[];for(s=0;s<12;s++)i[s]=gn(e,s,n,"month");return i}function pn(e,t,n,s){t=("boolean"==typeof e?h(t)&&(n=t,t=void 0):(t=e,e=!1,h(n=t)&&(n=t,t=void 0)),t||"");var i,r=ht(),a=e?r._week.dow:0;if(null!=n)return gn(t,(n+a)%7,s,"day");var o=[];for(i=0;i<7;i++)o[i]=gn(t,(i+a)%7,s,"day");return o}yn.calendar=function(e,t,n){var s=this._calendar[e]||this._calendar.sameElse;return b(s)?s.call(t,n):s},yn.longDateFormat=function(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:(this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])},yn.invalidDate=function(){return this._invalidDate},yn.ordinal=function(e){return this._ordinal.replace("%d",e)},yn.preparse=_n,yn.postformat=_n,yn.relativeTime=function(e,t,n,s){var i=this._relativeTime[n];return b(i)?i(e,t,n,s):i.replace(/%d/i,e)},yn.pastFuture=function(e,t){var n=this._relativeTime[0<e?"future":"past"];return b(n)?n(t):n.replace(/%s/i,t)},yn.set=function(e){var t,n;for(n in e)b(t=e[n])?this[n]=t:this["_"+n]=t;this._config=e,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},yn.months=function(e,t){return e?o(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||We).test(t)?"format":"standalone"][e.month()]:o(this._months)?this._months:this._months.standalone},yn.monthsShort=function(e,t){return e?o(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[We.test(t)?"format":"standalone"][e.month()]:o(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},yn.monthsParse=function(e,t,n){var s,i,r;if(this._monthsParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],s=0;s<12;++s)r=y([2e3,s]),this._shortMonthsParse[s]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[s]=this.months(r,"").toLocaleLowerCase();return n?"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null}.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),s=0;s<12;s++){if(i=y([2e3,s]),n&&!this._longMonthsParse[s]&&(this._longMonthsParse[s]=new RegExp("^"+this.months(i,"").replace(".","")+"$","i"),this._shortMonthsParse[s]=new RegExp("^"+this.monthsShort(i,"").replace(".","")+"$","i")),n||this._monthsParse[s]||(r="^"+this.months(i,"")+"|^"+this.monthsShort(i,""),this._monthsParse[s]=new RegExp(r.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[s].test(e))return s;if(n&&"MMM"===t&&this._shortMonthsParse[s].test(e))return s;if(!n&&this._monthsParse[s].test(e))return s}},yn.monthsRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsStrictRegex:this._monthsRegex):(m(this,"_monthsRegex")||(this._monthsRegex=Le),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)},yn.monthsShortRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(m(this,"_monthsShortRegex")||(this._monthsShortRegex=Fe),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)},yn.week=function(e){return Ie(e,this._week.dow,this._week.doy).week},yn.firstDayOfYear=function(){return this._week.doy},yn.firstDayOfWeek=function(){return this._week.dow},yn.weekdays=function(e,t){var n=o(this._weekdays)?this._weekdays:this._weekdays[e&&!0!==e&&this._weekdays.isFormat.test(t)?"format":"standalone"];return!0===e?je(n,this._week.dow):e?n[e.day()]:n},yn.weekdaysMin=function(e){return!0===e?je(this._weekdaysMin,this._week.dow):e?this._weekdaysMin[e.day()]:this._weekdaysMin},yn.weekdaysShort=function(e){return!0===e?je(this._weekdaysShort,this._week.dow):e?this._weekdaysShort[e.day()]:this._weekdaysShort},yn.weekdaysParse=function(e,t,n){var s,i,r;if(this._weekdaysParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],s=0;s<7;++s)r=y([2e3,1]).day(s),this._minWeekdaysParse[s]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[s]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[s]=this.weekdays(r,"").toLocaleLowerCase();return n?"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null}.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),s=0;s<7;s++){if(i=y([2e3,1]).day(s),n&&!this._fullWeekdaysParse[s]&&(this._fullWeekdaysParse[s]=new RegExp("^"+this.weekdays(i,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[s]=new RegExp("^"+this.weekdaysShort(i,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[s]=new RegExp("^"+this.weekdaysMin(i,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[s]||(r="^"+this.weekdays(i,"")+"|^"+this.weekdaysShort(i,"")+"|^"+this.weekdaysMin(i,""),this._weekdaysParse[s]=new RegExp(r.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[s].test(e))return s;if(n&&"ddd"===t&&this._shortWeekdaysParse[s].test(e))return s;if(n&&"dd"===t&&this._minWeekdaysParse[s].test(e))return s;if(!n&&this._weekdaysParse[s].test(e))return s}},yn.weekdaysRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(m(this,"_weekdaysRegex")||(this._weekdaysRegex=qe),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)},yn.weekdaysShortRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(m(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Je),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},yn.weekdaysMinRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(m(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Be),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},yn.isPM=function(e){return"p"===(e+"").toLowerCase().charAt(0)},yn.meridiem=function(e,t,n){return 11<e?n?"pm":"PM":n?"am":"AM"},ut("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10;return e+(1===D(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")}}),c.lang=n("moment.lang is deprecated. Use moment.locale instead.",ut),c.langData=n("moment.langData is deprecated. Use moment.localeData instead.",ht);var wn=Math.abs;function Mn(e,t,n,s){var i=jt(t,n);return e._milliseconds+=s*i._milliseconds,e._days+=s*i._days,e._months+=s*i._months,e._bubble()}function kn(e){return e<0?Math.floor(e):Math.ceil(e)}function Sn(e){return 4800*e/146097}function Dn(e){return 146097*e/4800}function Yn(e){return function(){return this.as(e)}}var On=Yn("ms"),Tn=Yn("s"),bn=Yn("m"),xn=Yn("h"),Pn=Yn("d"),Wn=Yn("w"),Cn=Yn("M"),Hn=Yn("Q"),Rn=Yn("y");function Un(e){return function(){return this.isValid()?this._data[e]:NaN}}var Fn=Un("milliseconds"),Ln=Un("seconds"),Nn=Un("minutes"),Gn=Un("hours"),Vn=Un("days"),En=Un("months"),In=Un("years");var An=Math.round,jn={ss:44,s:45,m:45,h:22,d:26,M:11};var Zn=Math.abs;function zn(e){return(0<e)-(e<0)||+e}function $n(){if(!this.isValid())return this.localeData().invalidDate();var e,t,n=Zn(this._milliseconds)/1e3,s=Zn(this._days),i=Zn(this._months);t=S((e=S(n/60))/60),n%=60,e%=60;var r=S(i/12),a=i%=12,o=s,u=t,l=e,h=n?n.toFixed(3).replace(/\.?0+$/,""):"",d=this.asSeconds();if(!d)return"P0D";var c=d<0?"-":"",f=zn(this._months)!==zn(d)?"-":"",m=zn(this._days)!==zn(d)?"-":"",_=zn(this._milliseconds)!==zn(d)?"-":"";return c+"P"+(r?f+r+"Y":"")+(a?f+a+"M":"")+(o?m+o+"D":"")+(u||l||h?"T":"")+(u?_+u+"H":"")+(l?_+l+"M":"")+(h?_+h+"S":"")}var qn=Ht.prototype;return qn.isValid=function(){return this._isValid},qn.abs=function(){var e=this._data;return this._milliseconds=wn(this._milliseconds),this._days=wn(this._days),this._months=wn(this._months),e.milliseconds=wn(e.milliseconds),e.seconds=wn(e.seconds),e.minutes=wn(e.minutes),e.hours=wn(e.hours),e.months=wn(e.months),e.years=wn(e.years),this},qn.add=function(e,t){return Mn(this,e,t,1)},qn.subtract=function(e,t){return Mn(this,e,t,-1)},qn.as=function(e){if(!this.isValid())return NaN;var t,n,s=this._milliseconds;if("month"===(e=H(e))||"quarter"===e||"year"===e)switch(t=this._days+s/864e5,n=this._months+Sn(t),e){case"month":return n;case"quarter":return n/3;case"year":return n/12}else switch(t=this._days+Math.round(Dn(this._months)),e){case"week":return t/7+s/6048e5;case"day":return t+s/864e5;case"hour":return 24*t+s/36e5;case"minute":return 1440*t+s/6e4;case"second":return 86400*t+s/1e3;case"millisecond":return Math.floor(864e5*t)+s;default:throw new Error("Unknown unit "+e)}},qn.asMilliseconds=On,qn.asSeconds=Tn,qn.asMinutes=bn,qn.asHours=xn,qn.asDays=Pn,qn.asWeeks=Wn,qn.asMonths=Cn,qn.asQuarters=Hn,qn.asYears=Rn,qn.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*D(this._months/12):NaN},qn._bubble=function(){var e,t,n,s,i,r=this._milliseconds,a=this._days,o=this._months,u=this._data;return 0<=r&&0<=a&&0<=o||r<=0&&a<=0&&o<=0||(r+=864e5*kn(Dn(o)+a),o=a=0),u.milliseconds=r%1e3,e=S(r/1e3),u.seconds=e%60,t=S(e/60),u.minutes=t%60,n=S(t/60),u.hours=n%24,o+=i=S(Sn(a+=S(n/24))),a-=kn(Dn(i)),s=S(o/12),o%=12,u.days=a,u.months=o,u.years=s,this},qn.clone=function(){return jt(this)},qn.get=function(e){return e=H(e),this.isValid()?this[e+"s"]():NaN},qn.milliseconds=Fn,qn.seconds=Ln,qn.minutes=Nn,qn.hours=Gn,qn.days=Vn,qn.weeks=function(){return S(this.days()/7)},qn.months=En,qn.years=In,qn.humanize=function(e){if(!this.isValid())return this.localeData().invalidDate();var t,n,s,i,r,a,o,u,l,h,d,c=this.localeData(),f=(n=!e,s=c,i=jt(t=this).abs(),r=An(i.as("s")),a=An(i.as("m")),o=An(i.as("h")),u=An(i.as("d")),l=An(i.as("M")),h=An(i.as("y")),(d=r<=jn.ss&&["s",r]||r<jn.s&&["ss",r]||a<=1&&["m"]||a<jn.m&&["mm",a]||o<=1&&["h"]||o<jn.h&&["hh",o]||u<=1&&["d"]||u<jn.d&&["dd",u]||l<=1&&["M"]||l<jn.M&&["MM",l]||h<=1&&["y"]||["yy",h])[2]=n,d[3]=0<+t,d[4]=s,function(e,t,n,s,i){return i.relativeTime(t||1,!!n,e,s)}.apply(null,d));return e&&(f=c.pastFuture(+this,f)),c.postformat(f)},qn.toISOString=$n,qn.toString=$n,qn.toJSON=$n,qn.locale=Xt,qn.localeData=en,qn.toIsoString=n("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",$n),qn.lang=Kt,I("X",0,0,"unix"),I("x",0,0,"valueOf"),ue("x",se),ue("X",/[+-]?\d+(\.\d{1,3})?/),ce("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10))}),ce("x",function(e,t,n){n._d=new Date(D(e))}),c.version="2.24.0",e=bt,c.fn=mn,c.min=function(){return Wt("isBefore",[].slice.call(arguments,0))},c.max=function(){return Wt("isAfter",[].slice.call(arguments,0))},c.now=function(){return Date.now?Date.now():+new Date},c.utc=y,c.unix=function(e){return bt(1e3*e)},c.months=function(e,t){return vn(e,t,"months")},c.isDate=d,c.locale=ut,c.invalid=p,c.duration=jt,c.isMoment=k,c.weekdays=function(e,t,n){return pn(e,t,n,"weekdays")},c.parseZone=function(){return bt.apply(null,arguments).parseZone()},c.localeData=ht,c.isDuration=Rt,c.monthsShort=function(e,t){return vn(e,t,"monthsShort")},c.weekdaysMin=function(e,t,n){return pn(e,t,n,"weekdaysMin")},c.defineLocale=lt,c.updateLocale=function(e,t){if(null!=t){var n,s,i=st;null!=(s=ot(e))&&(i=s._config),(n=new P(t=x(i,t))).parentLocale=it[e],it[e]=n,ut(e)}else null!=it[e]&&(null!=it[e].parentLocale?it[e]=it[e].parentLocale:null!=it[e]&&delete it[e]);return it[e]},c.locales=function(){return s(it)},c.weekdaysShort=function(e,t,n){return pn(e,t,n,"weekdaysShort")},c.normalizeUnits=H,c.relativeTimeRounding=function(e){return void 0===e?An:"function"==typeof e&&(An=e,!0)},c.relativeTimeThreshold=function(e,t){return void 0!==jn[e]&&(void 0===t?jn[e]:(jn[e]=t,"s"===e&&(jn.ss=t-1),!0))},c.calendarFormat=function(e,t){var n=e.diff(t,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"},c.prototype=mn,c.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"GGGG-[W]WW",MONTH:"YYYY-MM"},c});
!function(e,a){"object"==typeof exports&&"undefined"!=typeof module&&"function"==typeof require?a(require("../moment")):"function"==typeof define&&define.amd?define(["../moment"],a):a(e.moment)}(this,function(e){"use strict";e.defineLocale("af",{months:"Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),monthsShort:"Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),weekdays:"Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),weekdaysShort:"Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),weekdaysMin:"So_Ma_Di_Wo_Do_Vr_Sa".split("_"),meridiemParse:/vm|nm/i,isPM:function(e){return/^nm$/i.test(e)},meridiem:function(e,a,_){return e<12?_?"vm":"VM":_?"nm":"NM"},longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Vandag om] LT",nextDay:"[M\xf4re om] LT",nextWeek:"dddd [om] LT",lastDay:"[Gister om] LT",lastWeek:"[Laas] dddd [om] LT",sameElse:"L"},relativeTime:{future:"oor %s",past:"%s gelede",s:"'n paar sekondes",ss:"%d sekondes",m:"'n minuut",mm:"%d minute",h:"'n uur",hh:"%d ure",d:"'n dag",dd:"%d dae",M:"'n maand",MM:"%d maande",y:"'n jaar",yy:"%d jaar"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}}),e.defineLocale("ar-dz",{months:"\u062c\u0627\u0646\u0641\u064a_\u0641\u064a\u0641\u0631\u064a_\u0645\u0627\u0631\u0633_\u0623\u0641\u0631\u064a\u0644_\u0645\u0627\u064a_\u062c\u0648\u0627\u0646_\u062c\u0648\u064a\u0644\u064a\u0629_\u0623\u0648\u062a_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),monthsShort:"\u062c\u0627\u0646\u0641\u064a_\u0641\u064a\u0641\u0631\u064a_\u0645\u0627\u0631\u0633_\u0623\u0641\u0631\u064a\u0644_\u0645\u0627\u064a_\u062c\u0648\u0627\u0646_\u062c\u0648\u064a\u0644\u064a\u0629_\u0623\u0648\u062a_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0627\u062d\u062f_\u0627\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u0623\u062d_\u0625\u062b_\u062b\u0644\u0627_\u0623\u0631_\u062e\u0645_\u062c\u0645_\u0633\u0628".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},week:{dow:0,doy:4}}),e.defineLocale("ar-kw",{months:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),monthsShort:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062a\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0627\u062d\u062f_\u0627\u062a\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},week:{dow:0,doy:12}});var a={1:"1",2:"2",3:"3",4:"4",5:"5",6:"6",7:"7",8:"8",9:"9",0:"0"},r=function(e){return 0===e?0:1===e?1:2===e?2:3<=e%100&&e%100<=10?3:11<=e%100?4:5},i={s:["\u0623\u0642\u0644 \u0645\u0646 \u062b\u0627\u0646\u064a\u0629","\u062b\u0627\u0646\u064a\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062b\u0627\u0646\u064a\u062a\u0627\u0646","\u062b\u0627\u0646\u064a\u062a\u064a\u0646"],"%d \u062b\u0648\u0627\u0646","%d \u062b\u0627\u0646\u064a\u0629","%d \u062b\u0627\u0646\u064a\u0629"],m:["\u0623\u0642\u0644 \u0645\u0646 \u062f\u0642\u064a\u0642\u0629","\u062f\u0642\u064a\u0642\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062f\u0642\u064a\u0642\u062a\u0627\u0646","\u062f\u0642\u064a\u0642\u062a\u064a\u0646"],"%d \u062f\u0642\u0627\u0626\u0642","%d \u062f\u0642\u064a\u0642\u0629","%d \u062f\u0642\u064a\u0642\u0629"],h:["\u0623\u0642\u0644 \u0645\u0646 \u0633\u0627\u0639\u0629","\u0633\u0627\u0639\u0629 \u0648\u0627\u062d\u062f\u0629",["\u0633\u0627\u0639\u062a\u0627\u0646","\u0633\u0627\u0639\u062a\u064a\u0646"],"%d \u0633\u0627\u0639\u0627\u062a","%d \u0633\u0627\u0639\u0629","%d \u0633\u0627\u0639\u0629"],d:["\u0623\u0642\u0644 \u0645\u0646 \u064a\u0648\u0645","\u064a\u0648\u0645 \u0648\u0627\u062d\u062f",["\u064a\u0648\u0645\u0627\u0646","\u064a\u0648\u0645\u064a\u0646"],"%d \u0623\u064a\u0627\u0645","%d \u064a\u0648\u0645\u064b\u0627","%d \u064a\u0648\u0645"],M:["\u0623\u0642\u0644 \u0645\u0646 \u0634\u0647\u0631","\u0634\u0647\u0631 \u0648\u0627\u062d\u062f",["\u0634\u0647\u0631\u0627\u0646","\u0634\u0647\u0631\u064a\u0646"],"%d \u0623\u0634\u0647\u0631","%d \u0634\u0647\u0631\u0627","%d \u0634\u0647\u0631"],y:["\u0623\u0642\u0644 \u0645\u0646 \u0639\u0627\u0645","\u0639\u0627\u0645 \u0648\u0627\u062d\u062f",["\u0639\u0627\u0645\u0627\u0646","\u0639\u0627\u0645\u064a\u0646"],"%d \u0623\u0639\u0648\u0627\u0645","%d \u0639\u0627\u0645\u064b\u0627","%d \u0639\u0627\u0645"]},_=function(n){return function(e,a,_,s){var d=r(e),t=i[n][r(e)];return 2===d&&(t=t[a?0:1]),t.replace(/%d/i,e)}},s=["\u064a\u0646\u0627\u064a\u0631","\u0641\u0628\u0631\u0627\u064a\u0631","\u0645\u0627\u0631\u0633","\u0623\u0628\u0631\u064a\u0644","\u0645\u0627\u064a\u0648","\u064a\u0648\u0646\u064a\u0648","\u064a\u0648\u0644\u064a\u0648","\u0623\u063a\u0633\u0637\u0633","\u0633\u0628\u062a\u0645\u0628\u0631","\u0623\u0643\u062a\u0648\u0628\u0631","\u0646\u0648\u0641\u0645\u0628\u0631","\u062f\u064a\u0633\u0645\u0628\u0631"];e.defineLocale("ar-ly",{months:s,monthsShort:s,weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"D/\u200fM/\u200fYYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0635|\u0645/,isPM:function(e){return"\u0645"===e},meridiem:function(e,a,_){return e<12?"\u0635":"\u0645"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u064b\u0627 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0628\u0639\u062f %s",past:"\u0645\u0646\u0630 %s",s:_("s"),ss:_("s"),m:_("m"),mm:_("m"),h:_("h"),hh:_("h"),d:_("d"),dd:_("d"),M:_("M"),MM:_("M"),y:_("y"),yy:_("y")},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return a[e]}).replace(/,/g,"\u060c")},week:{dow:6,doy:12}}),e.defineLocale("ar-ma",{months:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),monthsShort:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062a\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0627\u062d\u062f_\u0627\u062a\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},week:{dow:6,doy:12}});var d={1:"\u0661",2:"\u0662",3:"\u0663",4:"\u0664",5:"\u0665",6:"\u0666",7:"\u0667",8:"\u0668",9:"\u0669",0:"\u0660"},t={"\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u0660":"0"};e.defineLocale("ar-sa",{months:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a\u0648_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648_\u0623\u063a\u0633\u0637\u0633_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),monthsShort:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a\u0648_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648_\u0623\u063a\u0633\u0637\u0633_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0635|\u0645/,isPM:function(e){return"\u0645"===e},meridiem:function(e,a,_){return e<12?"\u0635":"\u0645"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},preparse:function(e){return e.replace(/[\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660]/g,function(e){return t[e]}).replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return d[e]}).replace(/,/g,"\u060c")},week:{dow:0,doy:6}}),e.defineLocale("ar-tn",{months:"\u062c\u0627\u0646\u0641\u064a_\u0641\u064a\u0641\u0631\u064a_\u0645\u0627\u0631\u0633_\u0623\u0641\u0631\u064a\u0644_\u0645\u0627\u064a_\u062c\u0648\u0627\u0646_\u062c\u0648\u064a\u0644\u064a\u0629_\u0623\u0648\u062a_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),monthsShort:"\u062c\u0627\u0646\u0641\u064a_\u0641\u064a\u0641\u0631\u064a_\u0645\u0627\u0631\u0633_\u0623\u0641\u0631\u064a\u0644_\u0645\u0627\u064a_\u062c\u0648\u0627\u0646_\u062c\u0648\u064a\u0644\u064a\u0629_\u0623\u0648\u062a_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},week:{dow:1,doy:4}});var n={1:"\u0661",2:"\u0662",3:"\u0663",4:"\u0664",5:"\u0665",6:"\u0666",7:"\u0667",8:"\u0668",9:"\u0669",0:"\u0660"},m={"\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u0660":"0"},o=function(e){return 0===e?0:1===e?1:2===e?2:3<=e%100&&e%100<=10?3:11<=e%100?4:5},u={s:["\u0623\u0642\u0644 \u0645\u0646 \u062b\u0627\u0646\u064a\u0629","\u062b\u0627\u0646\u064a\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062b\u0627\u0646\u064a\u062a\u0627\u0646","\u062b\u0627\u0646\u064a\u062a\u064a\u0646"],"%d \u062b\u0648\u0627\u0646","%d \u062b\u0627\u0646\u064a\u0629","%d \u062b\u0627\u0646\u064a\u0629"],m:["\u0623\u0642\u0644 \u0645\u0646 \u062f\u0642\u064a\u0642\u0629","\u062f\u0642\u064a\u0642\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062f\u0642\u064a\u0642\u062a\u0627\u0646","\u062f\u0642\u064a\u0642\u062a\u064a\u0646"],"%d \u062f\u0642\u0627\u0626\u0642","%d \u062f\u0642\u064a\u0642\u0629","%d \u062f\u0642\u064a\u0642\u0629"],h:["\u0623\u0642\u0644 \u0645\u0646 \u0633\u0627\u0639\u0629","\u0633\u0627\u0639\u0629 \u0648\u0627\u062d\u062f\u0629",["\u0633\u0627\u0639\u062a\u0627\u0646","\u0633\u0627\u0639\u062a\u064a\u0646"],"%d \u0633\u0627\u0639\u0627\u062a","%d \u0633\u0627\u0639\u0629","%d \u0633\u0627\u0639\u0629"],d:["\u0623\u0642\u0644 \u0645\u0646 \u064a\u0648\u0645","\u064a\u0648\u0645 \u0648\u0627\u062d\u062f",["\u064a\u0648\u0645\u0627\u0646","\u064a\u0648\u0645\u064a\u0646"],"%d \u0623\u064a\u0627\u0645","%d \u064a\u0648\u0645\u064b\u0627","%d \u064a\u0648\u0645"],M:["\u0623\u0642\u0644 \u0645\u0646 \u0634\u0647\u0631","\u0634\u0647\u0631 \u0648\u0627\u062d\u062f",["\u0634\u0647\u0631\u0627\u0646","\u0634\u0647\u0631\u064a\u0646"],"%d \u0623\u0634\u0647\u0631","%d \u0634\u0647\u0631\u0627","%d \u0634\u0647\u0631"],y:["\u0623\u0642\u0644 \u0645\u0646 \u0639\u0627\u0645","\u0639\u0627\u0645 \u0648\u0627\u062d\u062f",["\u0639\u0627\u0645\u0627\u0646","\u0639\u0627\u0645\u064a\u0646"],"%d \u0623\u0639\u0648\u0627\u0645","%d \u0639\u0627\u0645\u064b\u0627","%d \u0639\u0627\u0645"]},l=function(n){return function(e,a,_,s){var d=o(e),t=u[n][o(e)];return 2===d&&(t=t[a?0:1]),t.replace(/%d/i,e)}},M=["\u064a\u0646\u0627\u064a\u0631","\u0641\u0628\u0631\u0627\u064a\u0631","\u0645\u0627\u0631\u0633","\u0623\u0628\u0631\u064a\u0644","\u0645\u0627\u064a\u0648","\u064a\u0648\u0646\u064a\u0648","\u064a\u0648\u0644\u064a\u0648","\u0623\u063a\u0633\u0637\u0633","\u0633\u0628\u062a\u0645\u0628\u0631","\u0623\u0643\u062a\u0648\u0628\u0631","\u0646\u0648\u0641\u0645\u0628\u0631","\u062f\u064a\u0633\u0645\u0628\u0631"];e.defineLocale("ar",{months:M,monthsShort:M,weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"D/\u200fM/\u200fYYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0635|\u0645/,isPM:function(e){return"\u0645"===e},meridiem:function(e,a,_){return e<12?"\u0635":"\u0645"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u064b\u0627 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0628\u0639\u062f %s",past:"\u0645\u0646\u0630 %s",s:l("s"),ss:l("s"),m:l("m"),mm:l("m"),h:l("h"),hh:l("h"),d:l("d"),dd:l("d"),M:l("M"),MM:l("M"),y:l("y"),yy:l("y")},preparse:function(e){return e.replace(/[\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660]/g,function(e){return m[e]}).replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return n[e]}).replace(/,/g,"\u060c")},week:{dow:6,doy:12}});var L={1:"-inci",5:"-inci",8:"-inci",70:"-inci",80:"-inci",2:"-nci",7:"-nci",20:"-nci",50:"-nci",3:"-\xfcnc\xfc",4:"-\xfcnc\xfc",100:"-\xfcnc\xfc",6:"-nc\u0131",9:"-uncu",10:"-uncu",30:"-uncu",60:"-\u0131nc\u0131",90:"-\u0131nc\u0131"};function Y(e,a,_){var s,d;return"m"===_?a?"\u0445\u0432\u0456\u043b\u0456\u043d\u0430":"\u0445\u0432\u0456\u043b\u0456\u043d\u0443":"h"===_?a?"\u0433\u0430\u0434\u0437\u0456\u043d\u0430":"\u0433\u0430\u0434\u0437\u0456\u043d\u0443":e+" "+(s=+e,d={ss:a?"\u0441\u0435\u043a\u0443\u043d\u0434\u0430_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434":"\u0441\u0435\u043a\u0443\u043d\u0434\u0443_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434",mm:a?"\u0445\u0432\u0456\u043b\u0456\u043d\u0430_\u0445\u0432\u0456\u043b\u0456\u043d\u044b_\u0445\u0432\u0456\u043b\u0456\u043d":"\u0445\u0432\u0456\u043b\u0456\u043d\u0443_\u0445\u0432\u0456\u043b\u0456\u043d\u044b_\u0445\u0432\u0456\u043b\u0456\u043d",hh:a?"\u0433\u0430\u0434\u0437\u0456\u043d\u0430_\u0433\u0430\u0434\u0437\u0456\u043d\u044b_\u0433\u0430\u0434\u0437\u0456\u043d":"\u0433\u0430\u0434\u0437\u0456\u043d\u0443_\u0433\u0430\u0434\u0437\u0456\u043d\u044b_\u0433\u0430\u0434\u0437\u0456\u043d",dd:"\u0434\u0437\u0435\u043d\u044c_\u0434\u043d\u0456_\u0434\u0437\u0451\u043d",MM:"\u043c\u0435\u0441\u044f\u0446_\u043c\u0435\u0441\u044f\u0446\u044b_\u043c\u0435\u0441\u044f\u0446\u0430\u045e",yy:"\u0433\u043e\u0434_\u0433\u0430\u0434\u044b_\u0433\u0430\u0434\u043e\u045e"}[_].split("_"),s%10==1&&s%100!=11?d[0]:2<=s%10&&s%10<=4&&(s%100<10||20<=s%100)?d[1]:d[2])}e.defineLocale("az",{months:"yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),monthsShort:"yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),weekdays:"Bazar_Bazar ert\u0259si_\xc7\u0259r\u015f\u0259nb\u0259 ax\u015fam\u0131_\xc7\u0259r\u015f\u0259nb\u0259_C\xfcm\u0259 ax\u015fam\u0131_C\xfcm\u0259_\u015e\u0259nb\u0259".split("_"),weekdaysShort:"Baz_BzE_\xc7Ax_\xc7\u0259r_CAx_C\xfcm_\u015e\u0259n".split("_"),weekdaysMin:"Bz_BE_\xc7A_\xc7\u0259_CA_C\xfc_\u015e\u0259".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[bug\xfcn saat] LT",nextDay:"[sabah saat] LT",nextWeek:"[g\u0259l\u0259n h\u0259ft\u0259] dddd [saat] LT",lastDay:"[d\xfcn\u0259n] LT",lastWeek:"[ke\xe7\u0259n h\u0259ft\u0259] dddd [saat] LT",sameElse:"L"},relativeTime:{future:"%s sonra",past:"%s \u0259vv\u0259l",s:"birne\xe7\u0259 saniy\u0259",ss:"%d saniy\u0259",m:"bir d\u0259qiq\u0259",mm:"%d d\u0259qiq\u0259",h:"bir saat",hh:"%d saat",d:"bir g\xfcn",dd:"%d g\xfcn",M:"bir ay",MM:"%d ay",y:"bir il",yy:"%d il"},meridiemParse:/gec\u0259|s\u0259h\u0259r|g\xfcnd\xfcz|ax\u015fam/,isPM:function(e){return/^(g\xfcnd\xfcz|ax\u015fam)$/.test(e)},meridiem:function(e,a,_){return e<4?"gec\u0259":e<12?"s\u0259h\u0259r":e<17?"g\xfcnd\xfcz":"ax\u015fam"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0131nc\u0131|inci|nci|\xfcnc\xfc|nc\u0131|uncu)/,ordinal:function(e){if(0===e)return e+"-\u0131nc\u0131";var a=e%10;return e+(L[a]||L[e%100-a]||L[100<=e?100:null])},week:{dow:1,doy:7}}),e.defineLocale("be",{months:{format:"\u0441\u0442\u0443\u0434\u0437\u0435\u043d\u044f_\u043b\u044e\u0442\u0430\u0433\u0430_\u0441\u0430\u043a\u0430\u0432\u0456\u043a\u0430_\u043a\u0440\u0430\u0441\u0430\u0432\u0456\u043a\u0430_\u0442\u0440\u0430\u045e\u043d\u044f_\u0447\u044d\u0440\u0432\u0435\u043d\u044f_\u043b\u0456\u043f\u0435\u043d\u044f_\u0436\u043d\u0456\u045e\u043d\u044f_\u0432\u0435\u0440\u0430\u0441\u043d\u044f_\u043a\u0430\u0441\u0442\u0440\u044b\u0447\u043d\u0456\u043a\u0430_\u043b\u0456\u0441\u0442\u0430\u043f\u0430\u0434\u0430_\u0441\u043d\u0435\u0436\u043d\u044f".split("_"),standalone:"\u0441\u0442\u0443\u0434\u0437\u0435\u043d\u044c_\u043b\u044e\u0442\u044b_\u0441\u0430\u043a\u0430\u0432\u0456\u043a_\u043a\u0440\u0430\u0441\u0430\u0432\u0456\u043a_\u0442\u0440\u0430\u0432\u0435\u043d\u044c_\u0447\u044d\u0440\u0432\u0435\u043d\u044c_\u043b\u0456\u043f\u0435\u043d\u044c_\u0436\u043d\u0456\u0432\u0435\u043d\u044c_\u0432\u0435\u0440\u0430\u0441\u0435\u043d\u044c_\u043a\u0430\u0441\u0442\u0440\u044b\u0447\u043d\u0456\u043a_\u043b\u0456\u0441\u0442\u0430\u043f\u0430\u0434_\u0441\u043d\u0435\u0436\u0430\u043d\u044c".split("_")},monthsShort:"\u0441\u0442\u0443\u0434_\u043b\u044e\u0442_\u0441\u0430\u043a_\u043a\u0440\u0430\u0441_\u0442\u0440\u0430\u0432_\u0447\u044d\u0440\u0432_\u043b\u0456\u043f_\u0436\u043d\u0456\u0432_\u0432\u0435\u0440_\u043a\u0430\u0441\u0442_\u043b\u0456\u0441\u0442_\u0441\u043d\u0435\u0436".split("_"),weekdays:{format:"\u043d\u044f\u0434\u0437\u0435\u043b\u044e_\u043f\u0430\u043d\u044f\u0434\u0437\u0435\u043b\u0430\u043a_\u0430\u045e\u0442\u043e\u0440\u0430\u043a_\u0441\u0435\u0440\u0430\u0434\u0443_\u0447\u0430\u0446\u0432\u0435\u0440_\u043f\u044f\u0442\u043d\u0456\u0446\u0443_\u0441\u0443\u0431\u043e\u0442\u0443".split("_"),standalone:"\u043d\u044f\u0434\u0437\u0435\u043b\u044f_\u043f\u0430\u043d\u044f\u0434\u0437\u0435\u043b\u0430\u043a_\u0430\u045e\u0442\u043e\u0440\u0430\u043a_\u0441\u0435\u0440\u0430\u0434\u0430_\u0447\u0430\u0446\u0432\u0435\u0440_\u043f\u044f\u0442\u043d\u0456\u0446\u0430_\u0441\u0443\u0431\u043e\u0442\u0430".split("_"),isFormat:/\[ ?[\u0423\u0443\u045e] ?(?:\u043c\u0456\u043d\u0443\u043b\u0443\u044e|\u043d\u0430\u0441\u0442\u0443\u043f\u043d\u0443\u044e)? ?\] ?dddd/},weekdaysShort:"\u043d\u0434_\u043f\u043d_\u0430\u0442_\u0441\u0440_\u0447\u0446_\u043f\u0442_\u0441\u0431".split("_"),weekdaysMin:"\u043d\u0434_\u043f\u043d_\u0430\u0442_\u0441\u0440_\u0447\u0446_\u043f\u0442_\u0441\u0431".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0433.",LLL:"D MMMM YYYY \u0433., HH:mm",LLLL:"dddd, D MMMM YYYY \u0433., HH:mm"},calendar:{sameDay:"[\u0421\u0451\u043d\u043d\u044f \u045e] LT",nextDay:"[\u0417\u0430\u045e\u0442\u0440\u0430 \u045e] LT",lastDay:"[\u0423\u0447\u043e\u0440\u0430 \u045e] LT",nextWeek:function(){return"[\u0423] dddd [\u045e] LT"},lastWeek:function(){switch(this.day()){case 0:case 3:case 5:case 6:return"[\u0423 \u043c\u0456\u043d\u0443\u043b\u0443\u044e] dddd [\u045e] LT";case 1:case 2:case 4:return"[\u0423 \u043c\u0456\u043d\u0443\u043b\u044b] dddd [\u045e] LT"}},sameElse:"L"},relativeTime:{future:"\u043f\u0440\u0430\u0437 %s",past:"%s \u0442\u0430\u043c\u0443",s:"\u043d\u0435\u043a\u0430\u043b\u044c\u043a\u0456 \u0441\u0435\u043a\u0443\u043d\u0434",m:Y,mm:Y,h:Y,hh:Y,d:"\u0434\u0437\u0435\u043d\u044c",dd:Y,M:"\u043c\u0435\u0441\u044f\u0446",MM:Y,y:"\u0433\u043e\u0434",yy:Y},meridiemParse:/\u043d\u043e\u0447\u044b|\u0440\u0430\u043d\u0456\u0446\u044b|\u0434\u043d\u044f|\u0432\u0435\u0447\u0430\u0440\u0430/,isPM:function(e){return/^(\u0434\u043d\u044f|\u0432\u0435\u0447\u0430\u0440\u0430)$/.test(e)},meridiem:function(e,a,_){return e<4?"\u043d\u043e\u0447\u044b":e<12?"\u0440\u0430\u043d\u0456\u0446\u044b":e<17?"\u0434\u043d\u044f":"\u0432\u0435\u0447\u0430\u0440\u0430"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0456|\u044b|\u0433\u0430)/,ordinal:function(e,a){switch(a){case"M":case"d":case"DDD":case"w":case"W":return e%10!=2&&e%10!=3||e%100==12||e%100==13?e+"-\u044b":e+"-\u0456";case"D":return e+"-\u0433\u0430";default:return e}},week:{dow:1,doy:7}}),e.defineLocale("bg",{months:"\u044f\u043d\u0443\u0430\u0440\u0438_\u0444\u0435\u0432\u0440\u0443\u0430\u0440\u0438_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0438\u043b_\u043c\u0430\u0439_\u044e\u043d\u0438_\u044e\u043b\u0438_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043f\u0442\u0435\u043c\u0432\u0440\u0438_\u043e\u043a\u0442\u043e\u043c\u0432\u0440\u0438_\u043d\u043e\u0435\u043c\u0432\u0440\u0438_\u0434\u0435\u043a\u0435\u043c\u0432\u0440\u0438".split("_"),monthsShort:"\u044f\u043d\u0440_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0439_\u044e\u043d\u0438_\u044e\u043b\u0438_\u0430\u0432\u0433_\u0441\u0435\u043f_\u043e\u043a\u0442_\u043d\u043e\u0435_\u0434\u0435\u043a".split("_"),weekdays:"\u043d\u0435\u0434\u0435\u043b\u044f_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u044f\u0434\u0430_\u0447\u0435\u0442\u0432\u044a\u0440\u0442\u044a\u043a_\u043f\u0435\u0442\u044a\u043a_\u0441\u044a\u0431\u043e\u0442\u0430".split("_"),weekdaysShort:"\u043d\u0435\u0434_\u043f\u043e\u043d_\u0432\u0442\u043e_\u0441\u0440\u044f_\u0447\u0435\u0442_\u043f\u0435\u0442_\u0441\u044a\u0431".split("_"),weekdaysMin:"\u043d\u0434_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"D.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY H:mm",LLLL:"dddd, D MMMM YYYY H:mm"},calendar:{sameDay:"[\u0414\u043d\u0435\u0441 \u0432] LT",nextDay:"[\u0423\u0442\u0440\u0435 \u0432] LT",nextWeek:"dddd [\u0432] LT",lastDay:"[\u0412\u0447\u0435\u0440\u0430 \u0432] LT",lastWeek:function(){switch(this.day()){case 0:case 3:case 6:return"[\u0412 \u0438\u0437\u043c\u0438\u043d\u0430\u043b\u0430\u0442\u0430] dddd [\u0432] LT";case 1:case 2:case 4:case 5:return"[\u0412 \u0438\u0437\u043c\u0438\u043d\u0430\u043b\u0438\u044f] dddd [\u0432] LT"}},sameElse:"L"},relativeTime:{future:"\u0441\u043b\u0435\u0434 %s",past:"\u043f\u0440\u0435\u0434\u0438 %s",s:"\u043d\u044f\u043a\u043e\u043b\u043a\u043e \u0441\u0435\u043a\u0443\u043d\u0434\u0438",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434\u0438",m:"\u043c\u0438\u043d\u0443\u0442\u0430",mm:"%d \u043c\u0438\u043d\u0443\u0442\u0438",h:"\u0447\u0430\u0441",hh:"%d \u0447\u0430\u0441\u0430",d:"\u0434\u0435\u043d",dd:"%d \u0434\u043d\u0438",M:"\u043c\u0435\u0441\u0435\u0446",MM:"%d \u043c\u0435\u0441\u0435\u0446\u0430",y:"\u0433\u043e\u0434\u0438\u043d\u0430",yy:"%d \u0433\u043e\u0434\u0438\u043d\u0438"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0435\u0432|\u0435\u043d|\u0442\u0438|\u0432\u0438|\u0440\u0438|\u043c\u0438)/,ordinal:function(e){var a=e%10,_=e%100;return 0===e?e+"-\u0435\u0432":0===_?e+"-\u0435\u043d":10<_&&_<20?e+"-\u0442\u0438":1===a?e+"-\u0432\u0438":2===a?e+"-\u0440\u0438":7===a||8===a?e+"-\u043c\u0438":e+"-\u0442\u0438"},week:{dow:1,doy:7}}),e.defineLocale("bm",{months:"Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_M\u025bkalo_Zuw\u025bnkalo_Zuluyekalo_Utikalo_S\u025btanburukalo_\u0254kut\u0254burukalo_Nowanburukalo_Desanburukalo".split("_"),monthsShort:"Zan_Few_Mar_Awi_M\u025b_Zuw_Zul_Uti_S\u025bt_\u0254ku_Now_Des".split("_"),weekdays:"Kari_Nt\u025bn\u025bn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"),weekdaysShort:"Kar_Nt\u025b_Tar_Ara_Ala_Jum_Sib".split("_"),weekdaysMin:"Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"MMMM [tile] D [san] YYYY",LLL:"MMMM [tile] D [san] YYYY [l\u025br\u025b] HH:mm",LLLL:"dddd MMMM [tile] D [san] YYYY [l\u025br\u025b] HH:mm"},calendar:{sameDay:"[Bi l\u025br\u025b] LT",nextDay:"[Sini l\u025br\u025b] LT",nextWeek:"dddd [don l\u025br\u025b] LT",lastDay:"[Kunu l\u025br\u025b] LT",lastWeek:"dddd [t\u025bm\u025bnen l\u025br\u025b] LT",sameElse:"L"},relativeTime:{future:"%s k\u0254n\u0254",past:"a b\u025b %s b\u0254",s:"sanga dama dama",ss:"sekondi %d",m:"miniti kelen",mm:"miniti %d",h:"l\u025br\u025b kelen",hh:"l\u025br\u025b %d",d:"tile kelen",dd:"tile %d",M:"kalo kelen",MM:"kalo %d",y:"san kelen",yy:"san %d"},week:{dow:1,doy:4}});var h={1:"\u09e7",2:"\u09e8",3:"\u09e9",4:"\u09ea",5:"\u09eb",6:"\u09ec",7:"\u09ed",8:"\u09ee",9:"\u09ef",0:"\u09e6"},y={"\u09e7":"1","\u09e8":"2","\u09e9":"3","\u09ea":"4","\u09eb":"5","\u09ec":"6","\u09ed":"7","\u09ee":"8","\u09ef":"9","\u09e6":"0"};e.defineLocale("bn",{months:"\u099c\u09be\u09a8\u09c1\u09df\u09be\u09b0\u09c0_\u09ab\u09c7\u09ac\u09cd\u09b0\u09c1\u09df\u09be\u09b0\u09bf_\u09ae\u09be\u09b0\u09cd\u099a_\u098f\u09aa\u09cd\u09b0\u09bf\u09b2_\u09ae\u09c7_\u099c\u09c1\u09a8_\u099c\u09c1\u09b2\u09be\u0987_\u0986\u0997\u09b8\u09cd\u099f_\u09b8\u09c7\u09aa\u09cd\u099f\u09c7\u09ae\u09cd\u09ac\u09b0_\u0985\u0995\u09cd\u099f\u09cb\u09ac\u09b0_\u09a8\u09ad\u09c7\u09ae\u09cd\u09ac\u09b0_\u09a1\u09bf\u09b8\u09c7\u09ae\u09cd\u09ac\u09b0".split("_"),monthsShort:"\u099c\u09be\u09a8\u09c1_\u09ab\u09c7\u09ac_\u09ae\u09be\u09b0\u09cd\u099a_\u098f\u09aa\u09cd\u09b0_\u09ae\u09c7_\u099c\u09c1\u09a8_\u099c\u09c1\u09b2_\u0986\u0997_\u09b8\u09c7\u09aa\u09cd\u099f_\u0985\u0995\u09cd\u099f\u09cb_\u09a8\u09ad\u09c7_\u09a1\u09bf\u09b8\u09c7".split("_"),weekdays:"\u09b0\u09ac\u09bf\u09ac\u09be\u09b0_\u09b8\u09cb\u09ae\u09ac\u09be\u09b0_\u09ae\u0999\u09cd\u0997\u09b2\u09ac\u09be\u09b0_\u09ac\u09c1\u09a7\u09ac\u09be\u09b0_\u09ac\u09c3\u09b9\u09b8\u09cd\u09aa\u09a4\u09bf\u09ac\u09be\u09b0_\u09b6\u09c1\u0995\u09cd\u09b0\u09ac\u09be\u09b0_\u09b6\u09a8\u09bf\u09ac\u09be\u09b0".split("_"),weekdaysShort:"\u09b0\u09ac\u09bf_\u09b8\u09cb\u09ae_\u09ae\u0999\u09cd\u0997\u09b2_\u09ac\u09c1\u09a7_\u09ac\u09c3\u09b9\u09b8\u09cd\u09aa\u09a4\u09bf_\u09b6\u09c1\u0995\u09cd\u09b0_\u09b6\u09a8\u09bf".split("_"),weekdaysMin:"\u09b0\u09ac\u09bf_\u09b8\u09cb\u09ae_\u09ae\u0999\u09cd\u0997_\u09ac\u09c1\u09a7_\u09ac\u09c3\u09b9\u0983_\u09b6\u09c1\u0995\u09cd\u09b0_\u09b6\u09a8\u09bf".split("_"),longDateFormat:{LT:"A h:mm \u09b8\u09ae\u09df",LTS:"A h:mm:ss \u09b8\u09ae\u09df",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u09b8\u09ae\u09df",LLLL:"dddd, D MMMM YYYY, A h:mm \u09b8\u09ae\u09df"},calendar:{sameDay:"[\u0986\u099c] LT",nextDay:"[\u0986\u0997\u09be\u09ae\u09c0\u0995\u09be\u09b2] LT",nextWeek:"dddd, LT",lastDay:"[\u0997\u09a4\u0995\u09be\u09b2] LT",lastWeek:"[\u0997\u09a4] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u09aa\u09b0\u09c7",past:"%s \u0986\u0997\u09c7",s:"\u0995\u09df\u09c7\u0995 \u09b8\u09c7\u0995\u09c7\u09a8\u09cd\u09a1",ss:"%d \u09b8\u09c7\u0995\u09c7\u09a8\u09cd\u09a1",m:"\u098f\u0995 \u09ae\u09bf\u09a8\u09bf\u099f",mm:"%d \u09ae\u09bf\u09a8\u09bf\u099f",h:"\u098f\u0995 \u0998\u09a8\u09cd\u099f\u09be",hh:"%d \u0998\u09a8\u09cd\u099f\u09be",d:"\u098f\u0995 \u09a6\u09bf\u09a8",dd:"%d \u09a6\u09bf\u09a8",M:"\u098f\u0995 \u09ae\u09be\u09b8",MM:"%d \u09ae\u09be\u09b8",y:"\u098f\u0995 \u09ac\u099b\u09b0",yy:"%d \u09ac\u099b\u09b0"},preparse:function(e){return e.replace(/[\u09e7\u09e8\u09e9\u09ea\u09eb\u09ec\u09ed\u09ee\u09ef\u09e6]/g,function(e){return y[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return h[e]})},meridiemParse:/\u09b0\u09be\u09a4|\u09b8\u0995\u09be\u09b2|\u09a6\u09c1\u09aa\u09c1\u09b0|\u09ac\u09bf\u0995\u09be\u09b2|\u09b0\u09be\u09a4/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u09b0\u09be\u09a4"===a&&4<=e||"\u09a6\u09c1\u09aa\u09c1\u09b0"===a&&e<5||"\u09ac\u09bf\u0995\u09be\u09b2"===a?e+12:e},meridiem:function(e,a,_){return e<4?"\u09b0\u09be\u09a4":e<10?"\u09b8\u0995\u09be\u09b2":e<17?"\u09a6\u09c1\u09aa\u09c1\u09b0":e<20?"\u09ac\u09bf\u0995\u09be\u09b2":"\u09b0\u09be\u09a4"},week:{dow:0,doy:6}});var c={1:"\u0f21",2:"\u0f22",3:"\u0f23",4:"\u0f24",5:"\u0f25",6:"\u0f26",7:"\u0f27",8:"\u0f28",9:"\u0f29",0:"\u0f20"},k={"\u0f21":"1","\u0f22":"2","\u0f23":"3","\u0f24":"4","\u0f25":"5","\u0f26":"6","\u0f27":"7","\u0f28":"8","\u0f29":"9","\u0f20":"0"};function p(e,a,_){var s,d,t;return e+" "+(s={mm:"munutenn",MM:"miz",dd:"devezh"}[_],2!==e?s:void 0!==(t={m:"v",b:"v",d:"z"})[(d=s).charAt(0)]?t[d.charAt(0)]+d.substring(1):d)}function D(e,a,_){var s=e+" ";switch(_){case"ss":return s+=1===e?"sekunda":2===e||3===e||4===e?"sekunde":"sekundi";case"m":return a?"jedna minuta":"jedne minute";case"mm":return s+=1===e?"minuta":2===e||3===e||4===e?"minute":"minuta";case"h":return a?"jedan sat":"jednog sata";case"hh":return s+=1===e?"sat":2===e||3===e||4===e?"sata":"sati";case"dd":return s+=1===e?"dan":"dana";case"MM":return s+=1===e?"mjesec":2===e||3===e||4===e?"mjeseca":"mjeseci";case"yy":return s+=1===e?"godina":2===e||3===e||4===e?"godine":"godina"}}e.defineLocale("bo",{months:"\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0f44\u0f0b\u0f54\u0f7c_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f66\u0f74\u0f58\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f5e\u0f72\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f63\u0f94\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0fb2\u0f74\u0f42\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f51\u0f74\u0f53\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f62\u0f92\u0fb1\u0f51\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0f42\u0f74\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f42\u0f45\u0f72\u0f42\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f54".split("_"),monthsShort:"\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0f44\u0f0b\u0f54\u0f7c_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f66\u0f74\u0f58\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f5e\u0f72\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f63\u0f94\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0fb2\u0f74\u0f42\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f51\u0f74\u0f53\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f62\u0f92\u0fb1\u0f51\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0f42\u0f74\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f42\u0f45\u0f72\u0f42\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f54".split("_"),weekdays:"\u0f42\u0f5f\u0f60\u0f0b\u0f49\u0f72\u0f0b\u0f58\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f5f\u0fb3\u0f0b\u0f56\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f58\u0f72\u0f42\u0f0b\u0f51\u0f58\u0f62\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f63\u0fb7\u0f42\u0f0b\u0f54\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f55\u0f74\u0f62\u0f0b\u0f56\u0f74_\u0f42\u0f5f\u0f60\u0f0b\u0f54\u0f0b\u0f66\u0f44\u0f66\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f66\u0fa4\u0f7a\u0f53\u0f0b\u0f54\u0f0b".split("_"),weekdaysShort:"\u0f49\u0f72\u0f0b\u0f58\u0f0b_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b_\u0f58\u0f72\u0f42\u0f0b\u0f51\u0f58\u0f62\u0f0b_\u0f63\u0fb7\u0f42\u0f0b\u0f54\u0f0b_\u0f55\u0f74\u0f62\u0f0b\u0f56\u0f74_\u0f54\u0f0b\u0f66\u0f44\u0f66\u0f0b_\u0f66\u0fa4\u0f7a\u0f53\u0f0b\u0f54\u0f0b".split("_"),weekdaysMin:"\u0f49\u0f72\u0f0b\u0f58\u0f0b_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b_\u0f58\u0f72\u0f42\u0f0b\u0f51\u0f58\u0f62\u0f0b_\u0f63\u0fb7\u0f42\u0f0b\u0f54\u0f0b_\u0f55\u0f74\u0f62\u0f0b\u0f56\u0f74_\u0f54\u0f0b\u0f66\u0f44\u0f66\u0f0b_\u0f66\u0fa4\u0f7a\u0f53\u0f0b\u0f54\u0f0b".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm",LLLL:"dddd, D MMMM YYYY, A h:mm"},calendar:{sameDay:"[\u0f51\u0f72\u0f0b\u0f62\u0f72\u0f44] LT",nextDay:"[\u0f66\u0f44\u0f0b\u0f49\u0f72\u0f53] LT",nextWeek:"[\u0f56\u0f51\u0f74\u0f53\u0f0b\u0f55\u0fb2\u0f42\u0f0b\u0f62\u0f97\u0f7a\u0f66\u0f0b\u0f58], LT",lastDay:"[\u0f41\u0f0b\u0f66\u0f44] LT",lastWeek:"[\u0f56\u0f51\u0f74\u0f53\u0f0b\u0f55\u0fb2\u0f42\u0f0b\u0f58\u0f50\u0f60\u0f0b\u0f58] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0f63\u0f0b",past:"%s \u0f66\u0f94\u0f53\u0f0b\u0f63",s:"\u0f63\u0f58\u0f0b\u0f66\u0f44",ss:"%d \u0f66\u0f90\u0f62\u0f0b\u0f46\u0f0d",m:"\u0f66\u0f90\u0f62\u0f0b\u0f58\u0f0b\u0f42\u0f45\u0f72\u0f42",mm:"%d \u0f66\u0f90\u0f62\u0f0b\u0f58",h:"\u0f46\u0f74\u0f0b\u0f5a\u0f7c\u0f51\u0f0b\u0f42\u0f45\u0f72\u0f42",hh:"%d \u0f46\u0f74\u0f0b\u0f5a\u0f7c\u0f51",d:"\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f45\u0f72\u0f42",dd:"%d \u0f49\u0f72\u0f53\u0f0b",M:"\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f45\u0f72\u0f42",MM:"%d \u0f5f\u0fb3\u0f0b\u0f56",y:"\u0f63\u0f7c\u0f0b\u0f42\u0f45\u0f72\u0f42",yy:"%d \u0f63\u0f7c"},preparse:function(e){return e.replace(/[\u0f21\u0f22\u0f23\u0f24\u0f25\u0f26\u0f27\u0f28\u0f29\u0f20]/g,function(e){return k[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return c[e]})},meridiemParse:/\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c|\u0f5e\u0f7c\u0f42\u0f66\u0f0b\u0f40\u0f66|\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f74\u0f44|\u0f51\u0f42\u0f7c\u0f44\u0f0b\u0f51\u0f42|\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c"===a&&4<=e||"\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f74\u0f44"===a&&e<5||"\u0f51\u0f42\u0f7c\u0f44\u0f0b\u0f51\u0f42"===a?e+12:e},meridiem:function(e,a,_){return e<4?"\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c":e<10?"\u0f5e\u0f7c\u0f42\u0f66\u0f0b\u0f40\u0f66":e<17?"\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f74\u0f44":e<20?"\u0f51\u0f42\u0f7c\u0f44\u0f0b\u0f51\u0f42":"\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c"},week:{dow:0,doy:6}}),e.defineLocale("br",{months:"Genver_C'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),monthsShort:"Gen_C'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),weekdays:"Sul_Lun_Meurzh_Merc'her_Yaou_Gwener_Sadorn".split("_"),weekdaysShort:"Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),weekdaysMin:"Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"h[e]mm A",LTS:"h[e]mm:ss A",L:"DD/MM/YYYY",LL:"D [a viz] MMMM YYYY",LLL:"D [a viz] MMMM YYYY h[e]mm A",LLLL:"dddd, D [a viz] MMMM YYYY h[e]mm A"},calendar:{sameDay:"[Hiziv da] LT",nextDay:"[Warc'hoazh da] LT",nextWeek:"dddd [da] LT",lastDay:"[Dec'h da] LT",lastWeek:"dddd [paset da] LT",sameElse:"L"},relativeTime:{future:"a-benn %s",past:"%s 'zo",s:"un nebeud segondenno\xf9",ss:"%d eilenn",m:"ur vunutenn",mm:p,h:"un eur",hh:"%d eur",d:"un devezh",dd:p,M:"ur miz",MM:p,y:"ur bloaz",yy:function(e){switch(function e(a){return 9<a?e(a%10):a}(e)){case 1:case 3:case 4:case 5:case 9:return e+" bloaz";default:return e+" vloaz"}}},dayOfMonthOrdinalParse:/\d{1,2}(a\xf1|vet)/,ordinal:function(e){return e+(1===e?"a\xf1":"vet")},week:{dow:1,doy:4}}),e.defineLocale("bs",{months:"januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),monthsShort:"jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedjelja_ponedjeljak_utorak_srijeda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sri._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sutra u] LT",nextWeek:function(){switch(this.day()){case 0:return"[u] [nedjelju] [u] LT";case 3:return"[u] [srijedu] [u] LT";case 6:return"[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return"[u] dddd [u] LT"}},lastDay:"[ju\u010der u] LT",lastWeek:function(){switch(this.day()){case 0:case 3:return"[pro\u0161lu] dddd [u] LT";case 6:return"[pro\u0161le] [subote] [u] LT";case 1:case 2:case 4:case 5:return"[pro\u0161li] dddd [u] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"prije %s",s:"par sekundi",ss:D,m:D,mm:D,h:D,hh:D,d:"dan",dd:D,M:"mjesec",MM:D,y:"godinu",yy:D},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),e.defineLocale("ca",{months:{standalone:"gener_febrer_mar\xe7_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),format:"de gener_de febrer_de mar\xe7_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"),isFormat:/D[oD]?(\s)+MMMM/},monthsShort:"gen._febr._mar\xe7_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"),monthsParseExact:!0,weekdays:"diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),weekdaysShort:"dg._dl._dt._dc._dj._dv._ds.".split("_"),weekdaysMin:"dg_dl_dt_dc_dj_dv_ds".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM [de] YYYY",ll:"D MMM YYYY",LLL:"D MMMM [de] YYYY [a les] H:mm",lll:"D MMM YYYY, H:mm",LLLL:"dddd D MMMM [de] YYYY [a les] H:mm",llll:"ddd D MMM YYYY, H:mm"},calendar:{sameDay:function(){return"[avui a "+(1!==this.hours()?"les":"la")+"] LT"},nextDay:function(){return"[dem\xe0 a "+(1!==this.hours()?"les":"la")+"] LT"},nextWeek:function(){return"dddd [a "+(1!==this.hours()?"les":"la")+"] LT"},lastDay:function(){return"[ahir a "+(1!==this.hours()?"les":"la")+"] LT"},lastWeek:function(){return"[el] dddd [passat a "+(1!==this.hours()?"les":"la")+"] LT"},sameElse:"L"},relativeTime:{future:"d'aqu\xed %s",past:"fa %s",s:"uns segons",ss:"%d segons",m:"un minut",mm:"%d minuts",h:"una hora",hh:"%d hores",d:"un dia",dd:"%d dies",M:"un mes",MM:"%d mesos",y:"un any",yy:"%d anys"},dayOfMonthOrdinalParse:/\d{1,2}(r|n|t|\xe8|a)/,ordinal:function(e,a){var _=1===e?"r":2===e?"n":3===e?"r":4===e?"t":"\xe8";return"w"!==a&&"W"!==a||(_="a"),e+_},week:{dow:1,doy:4}});var T="leden_\xfanor_b\u0159ezen_duben_kv\u011bten_\u010derven_\u010dervenec_srpen_z\xe1\u0159\xed_\u0159\xedjen_listopad_prosinec".split("_"),f="led_\xfano_b\u0159e_dub_kv\u011b_\u010dvn_\u010dvc_srp_z\xe1\u0159_\u0159\xedj_lis_pro".split("_"),g=[/^led/i,/^\xfano/i,/^b\u0159e/i,/^dub/i,/^kv\u011b/i,/^(\u010dvn|\u010derven$|\u010dervna)/i,/^(\u010dvc|\u010dervenec|\u010dervence)/i,/^srp/i,/^z\xe1\u0159/i,/^\u0159\xedj/i,/^lis/i,/^pro/i],w=/^(leden|\xfanor|b\u0159ezen|duben|kv\u011bten|\u010dervenec|\u010dervence|\u010derven|\u010dervna|srpen|z\xe1\u0159\xed|\u0159\xedjen|listopad|prosinec|led|\xfano|b\u0159e|dub|kv\u011b|\u010dvn|\u010dvc|srp|z\xe1\u0159|\u0159\xedj|lis|pro)/i;function H(e){return 1<e&&e<5&&1!=~~(e/10)}function b(e,a,_,s){var d=e+" ";switch(_){case"s":return a||s?"p\xe1r sekund":"p\xe1r sekundami";case"ss":return a||s?d+(H(e)?"sekundy":"sekund"):d+"sekundami";break;case"m":return a?"minuta":s?"minutu":"minutou";case"mm":return a||s?d+(H(e)?"minuty":"minut"):d+"minutami";break;case"h":return a?"hodina":s?"hodinu":"hodinou";case"hh":return a||s?d+(H(e)?"hodiny":"hodin"):d+"hodinami";break;case"d":return a||s?"den":"dnem";case"dd":return a||s?d+(H(e)?"dny":"dn\xed"):d+"dny";break;case"M":return a||s?"m\u011bs\xedc":"m\u011bs\xedcem";case"MM":return a||s?d+(H(e)?"m\u011bs\xedce":"m\u011bs\xedc\u016f"):d+"m\u011bs\xedci";break;case"y":return a||s?"rok":"rokem";case"yy":return a||s?d+(H(e)?"roky":"let"):d+"lety";break}}function S(e,a,_,s){var d={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return a?d[_][0]:d[_][1]}function v(e,a,_,s){var d={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return a?d[_][0]:d[_][1]}function j(e,a,_,s){var d={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return a?d[_][0]:d[_][1]}e.defineLocale("cs",{months:T,monthsShort:f,monthsRegex:w,monthsShortRegex:w,monthsStrictRegex:/^(leden|ledna|\xfanora|\xfanor|b\u0159ezen|b\u0159ezna|duben|dubna|kv\u011bten|kv\u011btna|\u010dervenec|\u010dervence|\u010derven|\u010dervna|srpen|srpna|z\xe1\u0159\xed|\u0159\xedjen|\u0159\xedjna|listopadu|listopad|prosinec|prosince)/i,monthsShortStrictRegex:/^(led|\xfano|b\u0159e|dub|kv\u011b|\u010dvn|\u010dvc|srp|z\xe1\u0159|\u0159\xedj|lis|pro)/i,monthsParse:g,longMonthsParse:g,shortMonthsParse:g,weekdays:"ned\u011ble_pond\u011bl\xed_\xfater\xfd_st\u0159eda_\u010dtvrtek_p\xe1tek_sobota".split("_"),weekdaysShort:"ne_po_\xfat_st_\u010dt_p\xe1_so".split("_"),weekdaysMin:"ne_po_\xfat_st_\u010dt_p\xe1_so".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd D. MMMM YYYY H:mm",l:"D. M. YYYY"},calendar:{sameDay:"[dnes v] LT",nextDay:"[z\xedtra v] LT",nextWeek:function(){switch(this.day()){case 0:return"[v ned\u011bli v] LT";case 1:case 2:return"[v] dddd [v] LT";case 3:return"[ve st\u0159edu v] LT";case 4:return"[ve \u010dtvrtek v] LT";case 5:return"[v p\xe1tek v] LT";case 6:return"[v sobotu v] LT"}},lastDay:"[v\u010dera v] LT",lastWeek:function(){switch(this.day()){case 0:return"[minulou ned\u011bli v] LT";case 1:case 2:return"[minul\xe9] dddd [v] LT";case 3:return"[minulou st\u0159edu v] LT";case 4:case 5:return"[minul\xfd] dddd [v] LT";case 6:return"[minulou sobotu v] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"p\u0159ed %s",s:b,ss:b,m:b,mm:b,h:b,hh:b,d:b,dd:b,M:b,MM:b,y:b,yy:b},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("cv",{months:"\u043a\u04d1\u0440\u043b\u0430\u0447_\u043d\u0430\u0440\u04d1\u0441_\u043f\u0443\u0448_\u0430\u043a\u0430_\u043c\u0430\u0439_\u04ab\u04d7\u0440\u0442\u043c\u0435_\u0443\u0442\u04d1_\u04ab\u0443\u0440\u043b\u0430_\u0430\u0432\u04d1\u043d_\u044e\u043f\u0430_\u0447\u04f3\u043a_\u0440\u0430\u0448\u0442\u0430\u0432".split("_"),monthsShort:"\u043a\u04d1\u0440_\u043d\u0430\u0440_\u043f\u0443\u0448_\u0430\u043a\u0430_\u043c\u0430\u0439_\u04ab\u04d7\u0440_\u0443\u0442\u04d1_\u04ab\u0443\u0440_\u0430\u0432\u043d_\u044e\u043f\u0430_\u0447\u04f3\u043a_\u0440\u0430\u0448".split("_"),weekdays:"\u0432\u044b\u0440\u0441\u0430\u0440\u043d\u0438\u043a\u0443\u043d_\u0442\u0443\u043d\u0442\u0438\u043a\u0443\u043d_\u044b\u0442\u043b\u0430\u0440\u0438\u043a\u0443\u043d_\u044e\u043d\u043a\u0443\u043d_\u043a\u04d7\u04ab\u043d\u0435\u0440\u043d\u0438\u043a\u0443\u043d_\u044d\u0440\u043d\u0435\u043a\u0443\u043d_\u0448\u04d1\u043c\u0430\u0442\u043a\u0443\u043d".split("_"),weekdaysShort:"\u0432\u044b\u0440_\u0442\u0443\u043d_\u044b\u0442\u043b_\u044e\u043d_\u043a\u04d7\u04ab_\u044d\u0440\u043d_\u0448\u04d1\u043c".split("_"),weekdaysMin:"\u0432\u0440_\u0442\u043d_\u044b\u0442_\u044e\u043d_\u043a\u04ab_\u044d\u0440_\u0448\u043c".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"YYYY [\u04ab\u0443\u043b\u0445\u0438] MMMM [\u0443\u0439\u04d1\u0445\u04d7\u043d] D[-\u043c\u04d7\u0448\u04d7]",LLL:"YYYY [\u04ab\u0443\u043b\u0445\u0438] MMMM [\u0443\u0439\u04d1\u0445\u04d7\u043d] D[-\u043c\u04d7\u0448\u04d7], HH:mm",LLLL:"dddd, YYYY [\u04ab\u0443\u043b\u0445\u0438] MMMM [\u0443\u0439\u04d1\u0445\u04d7\u043d] D[-\u043c\u04d7\u0448\u04d7], HH:mm"},calendar:{sameDay:"[\u041f\u0430\u044f\u043d] LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",nextDay:"[\u042b\u0440\u0430\u043d] LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",lastDay:"[\u04d6\u043d\u0435\u0440] LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",nextWeek:"[\u04aa\u0438\u0442\u0435\u0441] dddd LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",lastWeek:"[\u0418\u0440\u0442\u043d\u04d7] dddd LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",sameElse:"L"},relativeTime:{future:function(e){return e+(/\u0441\u0435\u0445\u0435\u0442$/i.exec(e)?"\u0440\u0435\u043d":/\u04ab\u0443\u043b$/i.exec(e)?"\u0442\u0430\u043d":"\u0440\u0430\u043d")},past:"%s \u043a\u0430\u044f\u043b\u043b\u0430",s:"\u043f\u04d7\u0440-\u0438\u043a \u04ab\u0435\u043a\u043a\u0443\u043d\u0442",ss:"%d \u04ab\u0435\u043a\u043a\u0443\u043d\u0442",m:"\u043f\u04d7\u0440 \u043c\u0438\u043d\u0443\u0442",mm:"%d \u043c\u0438\u043d\u0443\u0442",h:"\u043f\u04d7\u0440 \u0441\u0435\u0445\u0435\u0442",hh:"%d \u0441\u0435\u0445\u0435\u0442",d:"\u043f\u04d7\u0440 \u043a\u0443\u043d",dd:"%d \u043a\u0443\u043d",M:"\u043f\u04d7\u0440 \u0443\u0439\u04d1\u0445",MM:"%d \u0443\u0439\u04d1\u0445",y:"\u043f\u04d7\u0440 \u04ab\u0443\u043b",yy:"%d \u04ab\u0443\u043b"},dayOfMonthOrdinalParse:/\d{1,2}-\u043c\u04d7\u0448/,ordinal:"%d-\u043c\u04d7\u0448",week:{dow:1,doy:7}}),e.defineLocale("cy",{months:"Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),monthsShort:"Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),weekdays:"Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),weekdaysShort:"Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),weekdaysMin:"Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Heddiw am] LT",nextDay:"[Yfory am] LT",nextWeek:"dddd [am] LT",lastDay:"[Ddoe am] LT",lastWeek:"dddd [diwethaf am] LT",sameElse:"L"},relativeTime:{future:"mewn %s",past:"%s yn \xf4l",s:"ychydig eiliadau",ss:"%d eiliad",m:"munud",mm:"%d munud",h:"awr",hh:"%d awr",d:"diwrnod",dd:"%d diwrnod",M:"mis",MM:"%d mis",y:"blwyddyn",yy:"%d flynedd"},dayOfMonthOrdinalParse:/\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,ordinal:function(e){var a="";return 20<e?a=40===e||50===e||60===e||80===e||100===e?"fed":"ain":0<e&&(a=["","af","il","ydd","ydd","ed","ed","ed","fed","fed","fed","eg","fed","eg","eg","fed","eg","eg","fed","eg","fed"][e]),e+a},week:{dow:1,doy:4}}),e.defineLocale("da",{months:"januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),monthsShort:"jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),weekdays:"s\xf8ndag_mandag_tirsdag_onsdag_torsdag_fredag_l\xf8rdag".split("_"),weekdaysShort:"s\xf8n_man_tir_ons_tor_fre_l\xf8r".split("_"),weekdaysMin:"s\xf8_ma_ti_on_to_fr_l\xf8".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd [d.] D. MMMM YYYY [kl.] HH:mm"},calendar:{sameDay:"[i dag kl.] LT",nextDay:"[i morgen kl.] LT",nextWeek:"p\xe5 dddd [kl.] LT",lastDay:"[i g\xe5r kl.] LT",lastWeek:"[i] dddd[s kl.] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"%s siden",s:"f\xe5 sekunder",ss:"%d sekunder",m:"et minut",mm:"%d minutter",h:"en time",hh:"%d timer",d:"en dag",dd:"%d dage",M:"en m\xe5ned",MM:"%d m\xe5neder",y:"et \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("de-at",{months:"J\xe4nner_Februar_M\xe4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"J\xe4n._Feb._M\xe4rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:S,mm:"%d Minuten",h:S,hh:"%d Stunden",d:S,dd:S,M:S,MM:S,y:S,yy:S},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("de-ch",{months:"Januar_Februar_M\xe4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan._Feb._M\xe4rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:v,mm:"%d Minuten",h:v,hh:"%d Stunden",d:v,dd:v,M:v,MM:v,y:v,yy:v},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("de",{months:"Januar_Februar_M\xe4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan._Feb._M\xe4rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:j,mm:"%d Minuten",h:j,hh:"%d Stunden",d:j,dd:j,M:j,MM:j,y:j,yy:j},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var x=["\u0796\u07ac\u0782\u07aa\u0787\u07a6\u0783\u07a9","\u078a\u07ac\u0784\u07b0\u0783\u07aa\u0787\u07a6\u0783\u07a9","\u0789\u07a7\u0783\u07a8\u0797\u07aa","\u0787\u07ad\u0795\u07b0\u0783\u07a9\u078d\u07aa","\u0789\u07ad","\u0796\u07ab\u0782\u07b0","\u0796\u07aa\u078d\u07a6\u0787\u07a8","\u0787\u07af\u078e\u07a6\u0790\u07b0\u0793\u07aa","\u0790\u07ac\u0795\u07b0\u0793\u07ac\u0789\u07b0\u0784\u07a6\u0783\u07aa","\u0787\u07ae\u0786\u07b0\u0793\u07af\u0784\u07a6\u0783\u07aa","\u0782\u07ae\u0788\u07ac\u0789\u07b0\u0784\u07a6\u0783\u07aa","\u0791\u07a8\u0790\u07ac\u0789\u07b0\u0784\u07a6\u0783\u07aa"],P=["\u0787\u07a7\u078b\u07a8\u0787\u07b0\u078c\u07a6","\u0780\u07af\u0789\u07a6","\u0787\u07a6\u0782\u07b0\u078e\u07a7\u0783\u07a6","\u0784\u07aa\u078b\u07a6","\u0784\u07aa\u0783\u07a7\u0790\u07b0\u078a\u07a6\u078c\u07a8","\u0780\u07aa\u0786\u07aa\u0783\u07aa","\u0780\u07ae\u0782\u07a8\u0780\u07a8\u0783\u07aa"];e.defineLocale("dv",{months:x,monthsShort:x,weekdays:P,weekdaysShort:P,weekdaysMin:"\u0787\u07a7\u078b\u07a8_\u0780\u07af\u0789\u07a6_\u0787\u07a6\u0782\u07b0_\u0784\u07aa\u078b\u07a6_\u0784\u07aa\u0783\u07a7_\u0780\u07aa\u0786\u07aa_\u0780\u07ae\u0782\u07a8".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"D/M/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0789\u0786|\u0789\u078a/,isPM:function(e){return"\u0789\u078a"===e},meridiem:function(e,a,_){return e<12?"\u0789\u0786":"\u0789\u078a"},calendar:{sameDay:"[\u0789\u07a8\u0787\u07a6\u078b\u07aa] LT",nextDay:"[\u0789\u07a7\u078b\u07a6\u0789\u07a7] LT",nextWeek:"dddd LT",lastDay:"[\u0787\u07a8\u0787\u07b0\u0794\u07ac] LT",lastWeek:"[\u078a\u07a7\u0787\u07a8\u078c\u07aa\u0788\u07a8] dddd LT",sameElse:"L"},relativeTime:{future:"\u078c\u07ac\u0783\u07ad\u078e\u07a6\u0787\u07a8 %s",past:"\u0786\u07aa\u0783\u07a8\u0782\u07b0 %s",s:"\u0790\u07a8\u0786\u07aa\u0782\u07b0\u078c\u07aa\u0786\u07ae\u0785\u07ac\u0787\u07b0",ss:"d% \u0790\u07a8\u0786\u07aa\u0782\u07b0\u078c\u07aa",m:"\u0789\u07a8\u0782\u07a8\u0793\u07ac\u0787\u07b0",mm:"\u0789\u07a8\u0782\u07a8\u0793\u07aa %d",h:"\u078e\u07a6\u0791\u07a8\u0787\u07a8\u0783\u07ac\u0787\u07b0",hh:"\u078e\u07a6\u0791\u07a8\u0787\u07a8\u0783\u07aa %d",d:"\u078b\u07aa\u0788\u07a6\u0780\u07ac\u0787\u07b0",dd:"\u078b\u07aa\u0788\u07a6\u0790\u07b0 %d",M:"\u0789\u07a6\u0780\u07ac\u0787\u07b0",MM:"\u0789\u07a6\u0790\u07b0 %d",y:"\u0787\u07a6\u0780\u07a6\u0783\u07ac\u0787\u07b0",yy:"\u0787\u07a6\u0780\u07a6\u0783\u07aa %d"},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:7,doy:12}}),e.defineLocale("el",{monthsNominativeEl:"\u0399\u03b1\u03bd\u03bf\u03c5\u03ac\u03c1\u03b9\u03bf\u03c2_\u03a6\u03b5\u03b2\u03c1\u03bf\u03c5\u03ac\u03c1\u03b9\u03bf\u03c2_\u039c\u03ac\u03c1\u03c4\u03b9\u03bf\u03c2_\u0391\u03c0\u03c1\u03af\u03bb\u03b9\u03bf\u03c2_\u039c\u03ac\u03b9\u03bf\u03c2_\u0399\u03bf\u03cd\u03bd\u03b9\u03bf\u03c2_\u0399\u03bf\u03cd\u03bb\u03b9\u03bf\u03c2_\u0391\u03cd\u03b3\u03bf\u03c5\u03c3\u03c4\u03bf\u03c2_\u03a3\u03b5\u03c0\u03c4\u03ad\u03bc\u03b2\u03c1\u03b9\u03bf\u03c2_\u039f\u03ba\u03c4\u03ce\u03b2\u03c1\u03b9\u03bf\u03c2_\u039d\u03bf\u03ad\u03bc\u03b2\u03c1\u03b9\u03bf\u03c2_\u0394\u03b5\u03ba\u03ad\u03bc\u03b2\u03c1\u03b9\u03bf\u03c2".split("_"),monthsGenitiveEl:"\u0399\u03b1\u03bd\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5_\u03a6\u03b5\u03b2\u03c1\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5_\u039c\u03b1\u03c1\u03c4\u03af\u03bf\u03c5_\u0391\u03c0\u03c1\u03b9\u03bb\u03af\u03bf\u03c5_\u039c\u03b1\u0390\u03bf\u03c5_\u0399\u03bf\u03c5\u03bd\u03af\u03bf\u03c5_\u0399\u03bf\u03c5\u03bb\u03af\u03bf\u03c5_\u0391\u03c5\u03b3\u03bf\u03cd\u03c3\u03c4\u03bf\u03c5_\u03a3\u03b5\u03c0\u03c4\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5_\u039f\u03ba\u03c4\u03c9\u03b2\u03c1\u03af\u03bf\u03c5_\u039d\u03bf\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5_\u0394\u03b5\u03ba\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5".split("_"),months:function(e,a){return e?"string"==typeof a&&/D/.test(a.substring(0,a.indexOf("MMMM")))?this._monthsGenitiveEl[e.month()]:this._monthsNominativeEl[e.month()]:this._monthsNominativeEl},monthsShort:"\u0399\u03b1\u03bd_\u03a6\u03b5\u03b2_\u039c\u03b1\u03c1_\u0391\u03c0\u03c1_\u039c\u03b1\u03ca_\u0399\u03bf\u03c5\u03bd_\u0399\u03bf\u03c5\u03bb_\u0391\u03c5\u03b3_\u03a3\u03b5\u03c0_\u039f\u03ba\u03c4_\u039d\u03bf\u03b5_\u0394\u03b5\u03ba".split("_"),weekdays:"\u039a\u03c5\u03c1\u03b9\u03b1\u03ba\u03ae_\u0394\u03b5\u03c5\u03c4\u03ad\u03c1\u03b1_\u03a4\u03c1\u03af\u03c4\u03b7_\u03a4\u03b5\u03c4\u03ac\u03c1\u03c4\u03b7_\u03a0\u03ad\u03bc\u03c0\u03c4\u03b7_\u03a0\u03b1\u03c1\u03b1\u03c3\u03ba\u03b5\u03c5\u03ae_\u03a3\u03ac\u03b2\u03b2\u03b1\u03c4\u03bf".split("_"),weekdaysShort:"\u039a\u03c5\u03c1_\u0394\u03b5\u03c5_\u03a4\u03c1\u03b9_\u03a4\u03b5\u03c4_\u03a0\u03b5\u03bc_\u03a0\u03b1\u03c1_\u03a3\u03b1\u03b2".split("_"),weekdaysMin:"\u039a\u03c5_\u0394\u03b5_\u03a4\u03c1_\u03a4\u03b5_\u03a0\u03b5_\u03a0\u03b1_\u03a3\u03b1".split("_"),meridiem:function(e,a,_){return 11<e?_?"\u03bc\u03bc":"\u039c\u039c":_?"\u03c0\u03bc":"\u03a0\u039c"},isPM:function(e){return"\u03bc"===(e+"").toLowerCase()[0]},meridiemParse:/[\u03a0\u039c]\.?\u039c?\.?/i,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendarEl:{sameDay:"[\u03a3\u03ae\u03bc\u03b5\u03c1\u03b1 {}] LT",nextDay:"[\u0391\u03cd\u03c1\u03b9\u03bf {}] LT",nextWeek:"dddd [{}] LT",lastDay:"[\u03a7\u03b8\u03b5\u03c2 {}] LT",lastWeek:function(){switch(this.day()){case 6:return"[\u03c4\u03bf \u03c0\u03c1\u03bf\u03b7\u03b3\u03bf\u03cd\u03bc\u03b5\u03bd\u03bf] dddd [{}] LT";default:return"[\u03c4\u03b7\u03bd \u03c0\u03c1\u03bf\u03b7\u03b3\u03bf\u03cd\u03bc\u03b5\u03bd\u03b7] dddd [{}] LT"}},sameElse:"L"},calendar:function(e,a){var _,s=this._calendarEl[e],d=a&&a.hours();return((_=s)instanceof Function||"[object Function]"===Object.prototype.toString.call(_))&&(s=s.apply(a)),s.replace("{}",d%12==1?"\u03c3\u03c4\u03b7":"\u03c3\u03c4\u03b9\u03c2")},relativeTime:{future:"\u03c3\u03b5 %s",past:"%s \u03c0\u03c1\u03b9\u03bd",s:"\u03bb\u03af\u03b3\u03b1 \u03b4\u03b5\u03c5\u03c4\u03b5\u03c1\u03cc\u03bb\u03b5\u03c0\u03c4\u03b1",ss:"%d \u03b4\u03b5\u03c5\u03c4\u03b5\u03c1\u03cc\u03bb\u03b5\u03c0\u03c4\u03b1",m:"\u03ad\u03bd\u03b1 \u03bb\u03b5\u03c0\u03c4\u03cc",mm:"%d \u03bb\u03b5\u03c0\u03c4\u03ac",h:"\u03bc\u03af\u03b1 \u03ce\u03c1\u03b1",hh:"%d \u03ce\u03c1\u03b5\u03c2",d:"\u03bc\u03af\u03b1 \u03bc\u03ad\u03c1\u03b1",dd:"%d \u03bc\u03ad\u03c1\u03b5\u03c2",M:"\u03ad\u03bd\u03b1\u03c2 \u03bc\u03ae\u03bd\u03b1\u03c2",MM:"%d \u03bc\u03ae\u03bd\u03b5\u03c2",y:"\u03ad\u03bd\u03b1\u03c2 \u03c7\u03c1\u03cc\u03bd\u03bf\u03c2",yy:"%d \u03c7\u03c1\u03cc\u03bd\u03b9\u03b1"},dayOfMonthOrdinalParse:/\d{1,2}\u03b7/,ordinal:"%d\u03b7",week:{dow:1,doy:4}}),e.defineLocale("en-SG",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}}),e.defineLocale("en-au",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}}),e.defineLocale("en-ca",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"YYYY-MM-DD",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")}}),e.defineLocale("en-gb",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}}),e.defineLocale("en-ie",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}}),e.defineLocale("en-il",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")}}),e.defineLocale("en-nz",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}}),e.defineLocale("eo",{months:"januaro_februaro_marto_aprilo_majo_junio_julio_a\u016dgusto_septembro_oktobro_novembro_decembro".split("_"),monthsShort:"jan_feb_mar_apr_maj_jun_jul_a\u016dg_sep_okt_nov_dec".split("_"),weekdays:"diman\u0109o_lundo_mardo_merkredo_\u0135a\u016ddo_vendredo_sabato".split("_"),weekdaysShort:"dim_lun_mard_merk_\u0135a\u016d_ven_sab".split("_"),weekdaysMin:"di_lu_ma_me_\u0135a_ve_sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"D[-a de] MMMM, YYYY",LLL:"D[-a de] MMMM, YYYY HH:mm",LLLL:"dddd, [la] D[-a de] MMMM, YYYY HH:mm"},meridiemParse:/[ap]\.t\.m/i,isPM:function(e){return"p"===e.charAt(0).toLowerCase()},meridiem:function(e,a,_){return 11<e?_?"p.t.m.":"P.T.M.":_?"a.t.m.":"A.T.M."},calendar:{sameDay:"[Hodia\u016d je] LT",nextDay:"[Morga\u016d je] LT",nextWeek:"dddd [je] LT",lastDay:"[Hiera\u016d je] LT",lastWeek:"[pasinta] dddd [je] LT",sameElse:"L"},relativeTime:{future:"post %s",past:"anta\u016d %s",s:"sekundoj",ss:"%d sekundoj",m:"minuto",mm:"%d minutoj",h:"horo",hh:"%d horoj",d:"tago",dd:"%d tagoj",M:"monato",MM:"%d monatoj",y:"jaro",yy:"%d jaroj"},dayOfMonthOrdinalParse:/\d{1,2}a/,ordinal:"%da",week:{dow:1,doy:7}});var W="ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),A="ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),O=[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],E=/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;e.defineLocale("es-do",{months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?A[e.month()]:W[e.month()]:W},monthsRegex:E,monthsShortRegex:E,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:O,longMonthsParse:O,shortMonthsParse:O,weekdays:"domingo_lunes_martes_mi\xe9rcoles_jueves_viernes_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._mi\xe9._jue._vie._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY h:mm A",LLLL:"dddd, D [de] MMMM [de] YYYY h:mm A"},calendar:{sameDay:function(){return"[hoy a la"+(1!==this.hours()?"s":"")+"] LT"},nextDay:function(){return"[ma\xf1ana a la"+(1!==this.hours()?"s":"")+"] LT"},nextWeek:function(){return"dddd [a la"+(1!==this.hours()?"s":"")+"] LT"},lastDay:function(){return"[ayer a la"+(1!==this.hours()?"s":"")+"] LT"},lastWeek:function(){return"[el] dddd [pasado a la"+(1!==this.hours()?"s":"")+"] LT"},sameElse:"L"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",M:"un mes",MM:"%d meses",y:"un a\xf1o",yy:"%d a\xf1os"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}});var F="ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),z="ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),J=[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],I=/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;e.defineLocale("es-us",{months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?z[e.month()]:F[e.month()]:F},monthsRegex:I,monthsShortRegex:I,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:J,longMonthsParse:J,shortMonthsParse:J,weekdays:"domingo_lunes_martes_mi\xe9rcoles_jueves_viernes_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._mi\xe9._jue._vie._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"MM/DD/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY h:mm A",LLLL:"dddd, D [de] MMMM [de] YYYY h:mm A"},calendar:{sameDay:function(){return"[hoy a la"+(1!==this.hours()?"s":"")+"] LT"},nextDay:function(){return"[ma\xf1ana a la"+(1!==this.hours()?"s":"")+"] LT"},nextWeek:function(){return"dddd [a la"+(1!==this.hours()?"s":"")+"] LT"},lastDay:function(){return"[ayer a la"+(1!==this.hours()?"s":"")+"] LT"},lastWeek:function(){return"[el] dddd [pasado a la"+(1!==this.hours()?"s":"")+"] LT"},sameElse:"L"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",M:"un mes",MM:"%d meses",y:"un a\xf1o",yy:"%d a\xf1os"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:0,doy:6}});var N="ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),R="ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),K=[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],C=/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;function G(e,a,_,s){var d={s:["m\xf5ne sekundi","m\xf5ni sekund","paar sekundit"],ss:[e+"sekundi",e+"sekundit"],m:["\xfche minuti","\xfcks minut"],mm:[e+" minuti",e+" minutit"],h:["\xfche tunni","tund aega","\xfcks tund"],hh:[e+" tunni",e+" tundi"],d:["\xfche p\xe4eva","\xfcks p\xe4ev"],M:["kuu aja","kuu aega","\xfcks kuu"],MM:[e+" kuu",e+" kuud"],y:["\xfche aasta","aasta","\xfcks aasta"],yy:[e+" aasta",e+" aastat"]};return a?d[_][2]?d[_][2]:d[_][1]:s?d[_][0]:d[_][1]}e.defineLocale("es",{months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?R[e.month()]:N[e.month()]:N},monthsRegex:C,monthsShortRegex:C,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:K,longMonthsParse:K,shortMonthsParse:K,weekdays:"domingo_lunes_martes_mi\xe9rcoles_jueves_viernes_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._mi\xe9._jue._vie._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY H:mm",LLLL:"dddd, D [de] MMMM [de] YYYY H:mm"},calendar:{sameDay:function(){return"[hoy a la"+(1!==this.hours()?"s":"")+"] LT"},nextDay:function(){return"[ma\xf1ana a la"+(1!==this.hours()?"s":"")+"] LT"},nextWeek:function(){return"dddd [a la"+(1!==this.hours()?"s":"")+"] LT"},lastDay:function(){return"[ayer a la"+(1!==this.hours()?"s":"")+"] LT"},lastWeek:function(){return"[el] dddd [pasado a la"+(1!==this.hours()?"s":"")+"] LT"},sameElse:"L"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",M:"un mes",MM:"%d meses",y:"un a\xf1o",yy:"%d a\xf1os"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),e.defineLocale("et",{months:"jaanuar_veebruar_m\xe4rts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),monthsShort:"jaan_veebr_m\xe4rts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),weekdays:"p\xfchap\xe4ev_esmasp\xe4ev_teisip\xe4ev_kolmap\xe4ev_neljap\xe4ev_reede_laup\xe4ev".split("_"),weekdaysShort:"P_E_T_K_N_R_L".split("_"),weekdaysMin:"P_E_T_K_N_R_L".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[T\xe4na,] LT",nextDay:"[Homme,] LT",nextWeek:"[J\xe4rgmine] dddd LT",lastDay:"[Eile,] LT",lastWeek:"[Eelmine] dddd LT",sameElse:"L"},relativeTime:{future:"%s p\xe4rast",past:"%s tagasi",s:G,ss:G,m:G,mm:G,h:G,hh:G,d:G,dd:"%d p\xe4eva",M:G,MM:G,y:G,yy:G},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("eu",{months:"urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),monthsShort:"urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),monthsParseExact:!0,weekdays:"igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),weekdaysShort:"ig._al._ar._az._og._ol._lr.".split("_"),weekdaysMin:"ig_al_ar_az_og_ol_lr".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY[ko] MMMM[ren] D[a]",LLL:"YYYY[ko] MMMM[ren] D[a] HH:mm",LLLL:"dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",l:"YYYY-M-D",ll:"YYYY[ko] MMM D[a]",lll:"YYYY[ko] MMM D[a] HH:mm",llll:"ddd, YYYY[ko] MMM D[a] HH:mm"},calendar:{sameDay:"[gaur] LT[etan]",nextDay:"[bihar] LT[etan]",nextWeek:"dddd LT[etan]",lastDay:"[atzo] LT[etan]",lastWeek:"[aurreko] dddd LT[etan]",sameElse:"L"},relativeTime:{future:"%s barru",past:"duela %s",s:"segundo batzuk",ss:"%d segundo",m:"minutu bat",mm:"%d minutu",h:"ordu bat",hh:"%d ordu",d:"egun bat",dd:"%d egun",M:"hilabete bat",MM:"%d hilabete",y:"urte bat",yy:"%d urte"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}});var B={1:"\u06f1",2:"\u06f2",3:"\u06f3",4:"\u06f4",5:"\u06f5",6:"\u06f6",7:"\u06f7",8:"\u06f8",9:"\u06f9",0:"\u06f0"},q={"\u06f1":"1","\u06f2":"2","\u06f3":"3","\u06f4":"4","\u06f5":"5","\u06f6":"6","\u06f7":"7","\u06f8":"8","\u06f9":"9","\u06f0":"0"};e.defineLocale("fa",{months:"\u0698\u0627\u0646\u0648\u06cc\u0647_\u0641\u0648\u0631\u06cc\u0647_\u0645\u0627\u0631\u0633_\u0622\u0648\u0631\u06cc\u0644_\u0645\u0647_\u0698\u0648\u0626\u0646_\u0698\u0648\u0626\u06cc\u0647_\u0627\u0648\u062a_\u0633\u067e\u062a\u0627\u0645\u0628\u0631_\u0627\u06a9\u062a\u0628\u0631_\u0646\u0648\u0627\u0645\u0628\u0631_\u062f\u0633\u0627\u0645\u0628\u0631".split("_"),monthsShort:"\u0698\u0627\u0646\u0648\u06cc\u0647_\u0641\u0648\u0631\u06cc\u0647_\u0645\u0627\u0631\u0633_\u0622\u0648\u0631\u06cc\u0644_\u0645\u0647_\u0698\u0648\u0626\u0646_\u0698\u0648\u0626\u06cc\u0647_\u0627\u0648\u062a_\u0633\u067e\u062a\u0627\u0645\u0628\u0631_\u0627\u06a9\u062a\u0628\u0631_\u0646\u0648\u0627\u0645\u0628\u0631_\u062f\u0633\u0627\u0645\u0628\u0631".split("_"),weekdays:"\u06cc\u06a9\u200c\u0634\u0646\u0628\u0647_\u062f\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200c\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067e\u0646\u062c\u200c\u0634\u0646\u0628\u0647_\u062c\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split("_"),weekdaysShort:"\u06cc\u06a9\u200c\u0634\u0646\u0628\u0647_\u062f\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200c\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067e\u0646\u062c\u200c\u0634\u0646\u0628\u0647_\u062c\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split("_"),weekdaysMin:"\u06cc_\u062f_\u0633_\u0686_\u067e_\u062c_\u0634".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},meridiemParse:/\u0642\u0628\u0644 \u0627\u0632 \u0638\u0647\u0631|\u0628\u0639\u062f \u0627\u0632 \u0638\u0647\u0631/,isPM:function(e){return/\u0628\u0639\u062f \u0627\u0632 \u0638\u0647\u0631/.test(e)},meridiem:function(e,a,_){return e<12?"\u0642\u0628\u0644 \u0627\u0632 \u0638\u0647\u0631":"\u0628\u0639\u062f \u0627\u0632 \u0638\u0647\u0631"},calendar:{sameDay:"[\u0627\u0645\u0631\u0648\u0632 \u0633\u0627\u0639\u062a] LT",nextDay:"[\u0641\u0631\u062f\u0627 \u0633\u0627\u0639\u062a] LT",nextWeek:"dddd [\u0633\u0627\u0639\u062a] LT",lastDay:"[\u062f\u06cc\u0631\u0648\u0632 \u0633\u0627\u0639\u062a] LT",lastWeek:"dddd [\u067e\u06cc\u0634] [\u0633\u0627\u0639\u062a] LT",sameElse:"L"},relativeTime:{future:"\u062f\u0631 %s",past:"%s \u067e\u06cc\u0634",s:"\u0686\u0646\u062f \u062b\u0627\u0646\u06cc\u0647",ss:"\u062b\u0627\u0646\u06cc\u0647 d%",m:"\u06cc\u06a9 \u062f\u0642\u06cc\u0642\u0647",mm:"%d \u062f\u0642\u06cc\u0642\u0647",h:"\u06cc\u06a9 \u0633\u0627\u0639\u062a",hh:"%d \u0633\u0627\u0639\u062a",d:"\u06cc\u06a9 \u0631\u0648\u0632",dd:"%d \u0631\u0648\u0632",M:"\u06cc\u06a9 \u0645\u0627\u0647",MM:"%d \u0645\u0627\u0647",y:"\u06cc\u06a9 \u0633\u0627\u0644",yy:"%d \u0633\u0627\u0644"},preparse:function(e){return e.replace(/[\u06f0-\u06f9]/g,function(e){return q[e]}).replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return B[e]}).replace(/,/g,"\u060c")},dayOfMonthOrdinalParse:/\d{1,2}\u0645/,ordinal:"%d\u0645",week:{dow:6,doy:12}});var U="nolla yksi kaksi kolme nelj\xe4 viisi kuusi seitsem\xe4n kahdeksan yhdeks\xe4n".split(" "),$=["nolla","yhden","kahden","kolmen","nelj\xe4n","viiden","kuuden",U[7],U[8],U[9]];function Q(e,a,_,s){var d,t,n="";switch(_){case"s":return s?"muutaman sekunnin":"muutama sekunti";case"ss":return s?"sekunnin":"sekuntia";case"m":return s?"minuutin":"minuutti";case"mm":n=s?"minuutin":"minuuttia";break;case"h":return s?"tunnin":"tunti";case"hh":n=s?"tunnin":"tuntia";break;case"d":return s?"p\xe4iv\xe4n":"p\xe4iv\xe4";case"dd":n=s?"p\xe4iv\xe4n":"p\xe4iv\xe4\xe4";break;case"M":return s?"kuukauden":"kuukausi";case"MM":n=s?"kuukauden":"kuukautta";break;case"y":return s?"vuoden":"vuosi";case"yy":n=s?"vuoden":"vuotta";break}return t=s,n=((d=e)<10?t?$[d]:U[d]:d)+" "+n}e.defineLocale("fi",{months:"tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kes\xe4kuu_hein\xe4kuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),monthsShort:"tammi_helmi_maalis_huhti_touko_kes\xe4_hein\xe4_elo_syys_loka_marras_joulu".split("_"),weekdays:"sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),weekdaysShort:"su_ma_ti_ke_to_pe_la".split("_"),weekdaysMin:"su_ma_ti_ke_to_pe_la".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD.MM.YYYY",LL:"Do MMMM[ta] YYYY",LLL:"Do MMMM[ta] YYYY, [klo] HH.mm",LLLL:"dddd, Do MMMM[ta] YYYY, [klo] HH.mm",l:"D.M.YYYY",ll:"Do MMM YYYY",lll:"Do MMM YYYY, [klo] HH.mm",llll:"ddd, Do MMM YYYY, [klo] HH.mm"},calendar:{sameDay:"[t\xe4n\xe4\xe4n] [klo] LT",nextDay:"[huomenna] [klo] LT",nextWeek:"dddd [klo] LT",lastDay:"[eilen] [klo] LT",lastWeek:"[viime] dddd[na] [klo] LT",sameElse:"L"},relativeTime:{future:"%s p\xe4\xe4st\xe4",past:"%s sitten",s:Q,ss:Q,m:Q,mm:Q,h:Q,hh:Q,d:Q,dd:Q,M:Q,MM:Q,y:Q,yy:Q},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("fo",{months:"januar_februar_mars_apr\xedl_mai_juni_juli_august_september_oktober_november_desember".split("_"),monthsShort:"jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),weekdays:"sunnudagur_m\xe1nadagur_t\xfdsdagur_mikudagur_h\xf3sdagur_fr\xedggjadagur_leygardagur".split("_"),weekdaysShort:"sun_m\xe1n_t\xfds_mik_h\xf3s_fr\xed_ley".split("_"),weekdaysMin:"su_m\xe1_t\xfd_mi_h\xf3_fr_le".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D. MMMM, YYYY HH:mm"},calendar:{sameDay:"[\xcd dag kl.] LT",nextDay:"[\xcd morgin kl.] LT",nextWeek:"dddd [kl.] LT",lastDay:"[\xcd gj\xe1r kl.] LT",lastWeek:"[s\xed\xf0stu] dddd [kl] LT",sameElse:"L"},relativeTime:{future:"um %s",past:"%s s\xed\xf0ani",s:"f\xe1 sekund",ss:"%d sekundir",m:"ein minuttur",mm:"%d minuttir",h:"ein t\xedmi",hh:"%d t\xedmar",d:"ein dagur",dd:"%d dagar",M:"ein m\xe1na\xf0ur",MM:"%d m\xe1na\xf0ir",y:"eitt \xe1r",yy:"%d \xe1r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("fr-ca",{months:"janvier_f\xe9vrier_mars_avril_mai_juin_juillet_ao\xfbt_septembre_octobre_novembre_d\xe9cembre".split("_"),monthsShort:"janv._f\xe9vr._mars_avr._mai_juin_juil._ao\xfbt_sept._oct._nov._d\xe9c.".split("_"),monthsParseExact:!0,weekdays:"dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),weekdaysShort:"dim._lun._mar._mer._jeu._ven._sam.".split("_"),weekdaysMin:"di_lu_ma_me_je_ve_sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Aujourd\u2019hui \xe0] LT",nextDay:"[Demain \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[Hier \xe0] LT",lastWeek:"dddd [dernier \xe0] LT",sameElse:"L"},relativeTime:{future:"dans %s",past:"il y a %s",s:"quelques secondes",ss:"%d secondes",m:"une minute",mm:"%d minutes",h:"une heure",hh:"%d heures",d:"un jour",dd:"%d jours",M:"un mois",MM:"%d mois",y:"un an",yy:"%d ans"},dayOfMonthOrdinalParse:/\d{1,2}(er|e)/,ordinal:function(e,a){switch(a){default:case"M":case"Q":case"D":case"DDD":case"d":return e+(1===e?"er":"e");case"w":case"W":return e+(1===e?"re":"e")}}}),e.defineLocale("fr-ch",{months:"janvier_f\xe9vrier_mars_avril_mai_juin_juillet_ao\xfbt_septembre_octobre_novembre_d\xe9cembre".split("_"),monthsShort:"janv._f\xe9vr._mars_avr._mai_juin_juil._ao\xfbt_sept._oct._nov._d\xe9c.".split("_"),monthsParseExact:!0,weekdays:"dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),weekdaysShort:"dim._lun._mar._mer._jeu._ven._sam.".split("_"),weekdaysMin:"di_lu_ma_me_je_ve_sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Aujourd\u2019hui \xe0] LT",nextDay:"[Demain \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[Hier \xe0] LT",lastWeek:"dddd [dernier \xe0] LT",sameElse:"L"},relativeTime:{future:"dans %s",past:"il y a %s",s:"quelques secondes",ss:"%d secondes",m:"une minute",mm:"%d minutes",h:"une heure",hh:"%d heures",d:"un jour",dd:"%d jours",M:"un mois",MM:"%d mois",y:"un an",yy:"%d ans"},dayOfMonthOrdinalParse:/\d{1,2}(er|e)/,ordinal:function(e,a){switch(a){default:case"M":case"Q":case"D":case"DDD":case"d":return e+(1===e?"er":"e");case"w":case"W":return e+(1===e?"re":"e")}},week:{dow:1,doy:4}}),e.defineLocale("fr",{months:"janvier_f\xe9vrier_mars_avril_mai_juin_juillet_ao\xfbt_septembre_octobre_novembre_d\xe9cembre".split("_"),monthsShort:"janv._f\xe9vr._mars_avr._mai_juin_juil._ao\xfbt_sept._oct._nov._d\xe9c.".split("_"),monthsParseExact:!0,weekdays:"dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),weekdaysShort:"dim._lun._mar._mer._jeu._ven._sam.".split("_"),weekdaysMin:"di_lu_ma_me_je_ve_sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Aujourd\u2019hui \xe0] LT",nextDay:"[Demain \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[Hier \xe0] LT",lastWeek:"dddd [dernier \xe0] LT",sameElse:"L"},relativeTime:{future:"dans %s",past:"il y a %s",s:"quelques secondes",ss:"%d secondes",m:"une minute",mm:"%d minutes",h:"une heure",hh:"%d heures",d:"un jour",dd:"%d jours",M:"un mois",MM:"%d mois",y:"un an",yy:"%d ans"},dayOfMonthOrdinalParse:/\d{1,2}(er|)/,ordinal:function(e,a){switch(a){case"D":return e+(1===e?"er":"");default:case"M":case"Q":case"DDD":case"d":return e+(1===e?"er":"e");case"w":case"W":return e+(1===e?"re":"e")}},week:{dow:1,doy:4}});var V="jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"),Z="jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");e.defineLocale("fy",{months:"jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?Z[e.month()]:V[e.month()]:V},monthsParseExact:!0,weekdays:"snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),weekdaysShort:"si._mo._ti._wo._to._fr._so.".split("_"),weekdaysMin:"Si_Mo_Ti_Wo_To_Fr_So".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[hjoed om] LT",nextDay:"[moarn om] LT",nextWeek:"dddd [om] LT",lastDay:"[juster om] LT",lastWeek:"[\xf4fr\xfbne] dddd [om] LT",sameElse:"L"},relativeTime:{future:"oer %s",past:"%s lyn",s:"in pear sekonden",ss:"%d sekonden",m:"ien min\xfat",mm:"%d minuten",h:"ien oere",hh:"%d oeren",d:"ien dei",dd:"%d dagen",M:"ien moanne",MM:"%d moannen",y:"ien jier",yy:"%d jierren"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}});e.defineLocale("ga",{months:["Ean\xe1ir","Feabhra","M\xe1rta","Aibre\xe1n","Bealtaine","M\xe9itheamh","I\xfail","L\xfanasa","Me\xe1n F\xf3mhair","Deaireadh F\xf3mhair","Samhain","Nollaig"],monthsShort:["Ean\xe1","Feab","M\xe1rt","Aibr","Beal","M\xe9it","I\xfail","L\xfana","Me\xe1n","Deai","Samh","Noll"],monthsParseExact:!0,weekdays:["D\xe9 Domhnaigh","D\xe9 Luain","D\xe9 M\xe1irt","D\xe9 C\xe9adaoin","D\xe9ardaoin","D\xe9 hAoine","D\xe9 Satharn"],weekdaysShort:["Dom","Lua","M\xe1i","C\xe9a","D\xe9a","hAo","Sat"],weekdaysMin:["Do","Lu","M\xe1","Ce","D\xe9","hA","Sa"],longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Inniu ag] LT",nextDay:"[Am\xe1rach ag] LT",nextWeek:"dddd [ag] LT",lastDay:"[Inn\xe9 aig] LT",lastWeek:"dddd [seo caite] [ag] LT",sameElse:"L"},relativeTime:{future:"i %s",past:"%s \xf3 shin",s:"c\xfapla soicind",ss:"%d soicind",m:"n\xf3im\xe9ad",mm:"%d n\xf3im\xe9ad",h:"uair an chloig",hh:"%d uair an chloig",d:"l\xe1",dd:"%d l\xe1",M:"m\xed",MM:"%d m\xed",y:"bliain",yy:"%d bliain"},dayOfMonthOrdinalParse:/\d{1,2}(d|na|mh)/,ordinal:function(e){return e+(1===e?"d":e%10==2?"na":"mh")},week:{dow:1,doy:4}});function X(e,a,_,s){var d={s:["thodde secondanim","thodde second"],ss:[e+" secondanim",e+" second"],m:["eka mintan","ek minute"],mm:[e+" mintanim",e+" mintam"],h:["eka voran","ek vor"],hh:[e+" voranim",e+" voram"],d:["eka disan","ek dis"],dd:[e+" disanim",e+" dis"],M:["eka mhoinean","ek mhoino"],MM:[e+" mhoineanim",e+" mhoine"],y:["eka vorsan","ek voros"],yy:[e+" vorsanim",e+" vorsam"]};return a?d[_][0]:d[_][1]}e.defineLocale("gd",{months:["Am Faoilleach","An Gearran","Am M\xe0rt","An Giblean","An C\xe8itean","An t-\xd2gmhios","An t-Iuchar","An L\xf9nastal","An t-Sultain","An D\xe0mhair","An t-Samhain","An D\xf9bhlachd"],monthsShort:["Faoi","Gear","M\xe0rt","Gibl","C\xe8it","\xd2gmh","Iuch","L\xf9n","Sult","D\xe0mh","Samh","D\xf9bh"],monthsParseExact:!0,weekdays:["Did\xf2mhnaich","Diluain","Dim\xe0irt","Diciadain","Diardaoin","Dihaoine","Disathairne"],weekdaysShort:["Did","Dil","Dim","Dic","Dia","Dih","Dis"],weekdaysMin:["D\xf2","Lu","M\xe0","Ci","Ar","Ha","Sa"],longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[An-diugh aig] LT",nextDay:"[A-m\xe0ireach aig] LT",nextWeek:"dddd [aig] LT",lastDay:"[An-d\xe8 aig] LT",lastWeek:"dddd [seo chaidh] [aig] LT",sameElse:"L"},relativeTime:{future:"ann an %s",past:"bho chionn %s",s:"beagan diogan",ss:"%d diogan",m:"mionaid",mm:"%d mionaidean",h:"uair",hh:"%d uairean",d:"latha",dd:"%d latha",M:"m\xecos",MM:"%d m\xecosan",y:"bliadhna",yy:"%d bliadhna"},dayOfMonthOrdinalParse:/\d{1,2}(d|na|mh)/,ordinal:function(e){return e+(1===e?"d":e%10==2?"na":"mh")},week:{dow:1,doy:4}}),e.defineLocale("gl",{months:"xaneiro_febreiro_marzo_abril_maio_xu\xf1o_xullo_agosto_setembro_outubro_novembro_decembro".split("_"),monthsShort:"xan._feb._mar._abr._mai._xu\xf1._xul._ago._set._out._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"domingo_luns_martes_m\xe9rcores_xoves_venres_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._m\xe9r._xov._ven._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_m\xe9_xo_ve_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY H:mm",LLLL:"dddd, D [de] MMMM [de] YYYY H:mm"},calendar:{sameDay:function(){return"[hoxe "+(1!==this.hours()?"\xe1s":"\xe1")+"] LT"},nextDay:function(){return"[ma\xf1\xe1 "+(1!==this.hours()?"\xe1s":"\xe1")+"] LT"},nextWeek:function(){return"dddd ["+(1!==this.hours()?"\xe1s":"a")+"] LT"},lastDay:function(){return"[onte "+(1!==this.hours()?"\xe1":"a")+"] LT"},lastWeek:function(){return"[o] dddd [pasado "+(1!==this.hours()?"\xe1s":"a")+"] LT"},sameElse:"L"},relativeTime:{future:function(e){return 0===e.indexOf("un")?"n"+e:"en "+e},past:"hai %s",s:"uns segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"unha hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",M:"un mes",MM:"%d meses",y:"un ano",yy:"%d anos"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),e.defineLocale("gom-latn",{months:"Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"),monthsShort:"Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son'var".split("_"),weekdaysShort:"Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),weekdaysMin:"Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"A h:mm [vazta]",LTS:"A h:mm:ss [vazta]",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY A h:mm [vazta]",LLLL:"dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]",llll:"ddd, D MMM YYYY, A h:mm [vazta]"},calendar:{sameDay:"[Aiz] LT",nextDay:"[Faleam] LT",nextWeek:"[Ieta to] dddd[,] LT",lastDay:"[Kal] LT",lastWeek:"[Fatlo] dddd[,] LT",sameElse:"L"},relativeTime:{future:"%s",past:"%s adim",s:X,ss:X,m:X,mm:X,h:X,hh:X,d:X,dd:X,M:X,MM:X,y:X,yy:X},dayOfMonthOrdinalParse:/\d{1,2}(er)/,ordinal:function(e,a){switch(a){case"D":return e+"er";default:case"M":case"Q":case"DDD":case"d":case"w":case"W":return e}},week:{dow:1,doy:4},meridiemParse:/rati|sokalli|donparam|sanje/,meridiemHour:function(e,a){return 12===e&&(e=0),"rati"===a?e<4?e:e+12:"sokalli"===a?e:"donparam"===a?12<e?e:e+12:"sanje"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"rati":e<12?"sokalli":e<16?"donparam":e<20?"sanje":"rati"}});var ee={1:"\u0ae7",2:"\u0ae8",3:"\u0ae9",4:"\u0aea",5:"\u0aeb",6:"\u0aec",7:"\u0aed",8:"\u0aee",9:"\u0aef",0:"\u0ae6"},ae={"\u0ae7":"1","\u0ae8":"2","\u0ae9":"3","\u0aea":"4","\u0aeb":"5","\u0aec":"6","\u0aed":"7","\u0aee":"8","\u0aef":"9","\u0ae6":"0"};e.defineLocale("gu",{months:"\u0a9c\u0abe\u0aa8\u0acd\u0aaf\u0ac1\u0a86\u0ab0\u0ac0_\u0aab\u0ac7\u0aac\u0acd\u0ab0\u0ac1\u0a86\u0ab0\u0ac0_\u0aae\u0abe\u0ab0\u0acd\u0a9a_\u0a8f\u0aaa\u0acd\u0ab0\u0abf\u0ab2_\u0aae\u0ac7_\u0a9c\u0ac2\u0aa8_\u0a9c\u0ac1\u0ab2\u0abe\u0a88_\u0a91\u0a97\u0ab8\u0acd\u0a9f_\u0ab8\u0aaa\u0acd\u0a9f\u0ac7\u0aae\u0acd\u0aac\u0ab0_\u0a91\u0a95\u0acd\u0a9f\u0acd\u0aac\u0ab0_\u0aa8\u0ab5\u0ac7\u0aae\u0acd\u0aac\u0ab0_\u0aa1\u0abf\u0ab8\u0ac7\u0aae\u0acd\u0aac\u0ab0".split("_"),monthsShort:"\u0a9c\u0abe\u0aa8\u0acd\u0aaf\u0ac1._\u0aab\u0ac7\u0aac\u0acd\u0ab0\u0ac1._\u0aae\u0abe\u0ab0\u0acd\u0a9a_\u0a8f\u0aaa\u0acd\u0ab0\u0abf._\u0aae\u0ac7_\u0a9c\u0ac2\u0aa8_\u0a9c\u0ac1\u0ab2\u0abe._\u0a91\u0a97._\u0ab8\u0aaa\u0acd\u0a9f\u0ac7._\u0a91\u0a95\u0acd\u0a9f\u0acd._\u0aa8\u0ab5\u0ac7._\u0aa1\u0abf\u0ab8\u0ac7.".split("_"),monthsParseExact:!0,weekdays:"\u0ab0\u0ab5\u0abf\u0ab5\u0abe\u0ab0_\u0ab8\u0acb\u0aae\u0ab5\u0abe\u0ab0_\u0aae\u0a82\u0a97\u0ab3\u0ab5\u0abe\u0ab0_\u0aac\u0ac1\u0aa7\u0acd\u0ab5\u0abe\u0ab0_\u0a97\u0ac1\u0ab0\u0ac1\u0ab5\u0abe\u0ab0_\u0ab6\u0ac1\u0a95\u0acd\u0ab0\u0ab5\u0abe\u0ab0_\u0ab6\u0aa8\u0abf\u0ab5\u0abe\u0ab0".split("_"),weekdaysShort:"\u0ab0\u0ab5\u0abf_\u0ab8\u0acb\u0aae_\u0aae\u0a82\u0a97\u0ab3_\u0aac\u0ac1\u0aa7\u0acd_\u0a97\u0ac1\u0ab0\u0ac1_\u0ab6\u0ac1\u0a95\u0acd\u0ab0_\u0ab6\u0aa8\u0abf".split("_"),weekdaysMin:"\u0ab0_\u0ab8\u0acb_\u0aae\u0a82_\u0aac\u0ac1_\u0a97\u0ac1_\u0ab6\u0ac1_\u0ab6".split("_"),longDateFormat:{LT:"A h:mm \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7",LTS:"A h:mm:ss \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7",LLLL:"dddd, D MMMM YYYY, A h:mm \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7"},calendar:{sameDay:"[\u0a86\u0a9c] LT",nextDay:"[\u0a95\u0abe\u0ab2\u0ac7] LT",nextWeek:"dddd, LT",lastDay:"[\u0a97\u0a87\u0a95\u0abe\u0ab2\u0ac7] LT",lastWeek:"[\u0aaa\u0abe\u0a9b\u0ab2\u0abe] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0aae\u0abe",past:"%s \u0aaa\u0ac7\u0ab9\u0ab2\u0abe",s:"\u0a85\u0aae\u0ac1\u0a95 \u0aaa\u0ab3\u0acb",ss:"%d \u0ab8\u0ac7\u0a95\u0a82\u0aa1",m:"\u0a8f\u0a95 \u0aae\u0abf\u0aa8\u0abf\u0a9f",mm:"%d \u0aae\u0abf\u0aa8\u0abf\u0a9f",h:"\u0a8f\u0a95 \u0a95\u0ab2\u0abe\u0a95",hh:"%d \u0a95\u0ab2\u0abe\u0a95",d:"\u0a8f\u0a95 \u0aa6\u0abf\u0ab5\u0ab8",dd:"%d \u0aa6\u0abf\u0ab5\u0ab8",M:"\u0a8f\u0a95 \u0aae\u0ab9\u0abf\u0aa8\u0acb",MM:"%d \u0aae\u0ab9\u0abf\u0aa8\u0acb",y:"\u0a8f\u0a95 \u0ab5\u0ab0\u0acd\u0ab7",yy:"%d \u0ab5\u0ab0\u0acd\u0ab7"},preparse:function(e){return e.replace(/[\u0ae7\u0ae8\u0ae9\u0aea\u0aeb\u0aec\u0aed\u0aee\u0aef\u0ae6]/g,function(e){return ae[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return ee[e]})},meridiemParse:/\u0ab0\u0abe\u0aa4|\u0aac\u0aaa\u0acb\u0ab0|\u0ab8\u0ab5\u0abe\u0ab0|\u0ab8\u0abe\u0a82\u0a9c/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0ab0\u0abe\u0aa4"===a?e<4?e:e+12:"\u0ab8\u0ab5\u0abe\u0ab0"===a?e:"\u0aac\u0aaa\u0acb\u0ab0"===a?10<=e?e:e+12:"\u0ab8\u0abe\u0a82\u0a9c"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0ab0\u0abe\u0aa4":e<10?"\u0ab8\u0ab5\u0abe\u0ab0":e<17?"\u0aac\u0aaa\u0acb\u0ab0":e<20?"\u0ab8\u0abe\u0a82\u0a9c":"\u0ab0\u0abe\u0aa4"},week:{dow:0,doy:6}}),e.defineLocale("he",{months:"\u05d9\u05e0\u05d5\u05d0\u05e8_\u05e4\u05d1\u05e8\u05d5\u05d0\u05e8_\u05de\u05e8\u05e5_\u05d0\u05e4\u05e8\u05d9\u05dc_\u05de\u05d0\u05d9_\u05d9\u05d5\u05e0\u05d9_\u05d9\u05d5\u05dc\u05d9_\u05d0\u05d5\u05d2\u05d5\u05e1\u05d8_\u05e1\u05e4\u05d8\u05de\u05d1\u05e8_\u05d0\u05d5\u05e7\u05d8\u05d5\u05d1\u05e8_\u05e0\u05d5\u05d1\u05de\u05d1\u05e8_\u05d3\u05e6\u05de\u05d1\u05e8".split("_"),monthsShort:"\u05d9\u05e0\u05d5\u05f3_\u05e4\u05d1\u05e8\u05f3_\u05de\u05e8\u05e5_\u05d0\u05e4\u05e8\u05f3_\u05de\u05d0\u05d9_\u05d9\u05d5\u05e0\u05d9_\u05d9\u05d5\u05dc\u05d9_\u05d0\u05d5\u05d2\u05f3_\u05e1\u05e4\u05d8\u05f3_\u05d0\u05d5\u05e7\u05f3_\u05e0\u05d5\u05d1\u05f3_\u05d3\u05e6\u05de\u05f3".split("_"),weekdays:"\u05e8\u05d0\u05e9\u05d5\u05df_\u05e9\u05e0\u05d9_\u05e9\u05dc\u05d9\u05e9\u05d9_\u05e8\u05d1\u05d9\u05e2\u05d9_\u05d7\u05de\u05d9\u05e9\u05d9_\u05e9\u05d9\u05e9\u05d9_\u05e9\u05d1\u05ea".split("_"),weekdaysShort:"\u05d0\u05f3_\u05d1\u05f3_\u05d2\u05f3_\u05d3\u05f3_\u05d4\u05f3_\u05d5\u05f3_\u05e9\u05f3".split("_"),weekdaysMin:"\u05d0_\u05d1_\u05d2_\u05d3_\u05d4_\u05d5_\u05e9".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [\u05d1]MMMM YYYY",LLL:"D [\u05d1]MMMM YYYY HH:mm",LLLL:"dddd, D [\u05d1]MMMM YYYY HH:mm",l:"D/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"},calendar:{sameDay:"[\u05d4\u05d9\u05d5\u05dd \u05d1\u05be]LT",nextDay:"[\u05de\u05d7\u05e8 \u05d1\u05be]LT",nextWeek:"dddd [\u05d1\u05e9\u05e2\u05d4] LT",lastDay:"[\u05d0\u05ea\u05de\u05d5\u05dc \u05d1\u05be]LT",lastWeek:"[\u05d1\u05d9\u05d5\u05dd] dddd [\u05d4\u05d0\u05d7\u05e8\u05d5\u05df \u05d1\u05e9\u05e2\u05d4] LT",sameElse:"L"},relativeTime:{future:"\u05d1\u05e2\u05d5\u05d3 %s",past:"\u05dc\u05e4\u05e0\u05d9 %s",s:"\u05de\u05e1\u05e4\u05e8 \u05e9\u05e0\u05d9\u05d5\u05ea",ss:"%d \u05e9\u05e0\u05d9\u05d5\u05ea",m:"\u05d3\u05e7\u05d4",mm:"%d \u05d3\u05e7\u05d5\u05ea",h:"\u05e9\u05e2\u05d4",hh:function(e){return 2===e?"\u05e9\u05e2\u05ea\u05d9\u05d9\u05dd":e+" \u05e9\u05e2\u05d5\u05ea"},d:"\u05d9\u05d5\u05dd",dd:function(e){return 2===e?"\u05d9\u05d5\u05de\u05d9\u05d9\u05dd":e+" \u05d9\u05de\u05d9\u05dd"},M:"\u05d7\u05d5\u05d3\u05e9",MM:function(e){return 2===e?"\u05d7\u05d5\u05d3\u05e9\u05d9\u05d9\u05dd":e+" \u05d7\u05d5\u05d3\u05e9\u05d9\u05dd"},y:"\u05e9\u05e0\u05d4",yy:function(e){return 2===e?"\u05e9\u05e0\u05ea\u05d9\u05d9\u05dd":e%10==0&&10!==e?e+" \u05e9\u05e0\u05d4":e+" \u05e9\u05e0\u05d9\u05dd"}},meridiemParse:/\u05d0\u05d7\u05d4"\u05e6|\u05dc\u05e4\u05e0\u05d4"\u05e6|\u05d0\u05d7\u05e8\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd|\u05dc\u05e4\u05e0\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd|\u05dc\u05e4\u05e0\u05d5\u05ea \u05d1\u05d5\u05e7\u05e8|\u05d1\u05d1\u05d5\u05e7\u05e8|\u05d1\u05e2\u05e8\u05d1/i,isPM:function(e){return/^(\u05d0\u05d7\u05d4"\u05e6|\u05d0\u05d7\u05e8\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd|\u05d1\u05e2\u05e8\u05d1)$/.test(e)},meridiem:function(e,a,_){return e<5?"\u05dc\u05e4\u05e0\u05d5\u05ea \u05d1\u05d5\u05e7\u05e8":e<10?"\u05d1\u05d1\u05d5\u05e7\u05e8":e<12?_?'\u05dc\u05e4\u05e0\u05d4"\u05e6':"\u05dc\u05e4\u05e0\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd":e<18?_?'\u05d0\u05d7\u05d4"\u05e6':"\u05d0\u05d7\u05e8\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd":"\u05d1\u05e2\u05e8\u05d1"}});var _e={1:"\u0967",2:"\u0968",3:"\u0969",4:"\u096a",5:"\u096b",6:"\u096c",7:"\u096d",8:"\u096e",9:"\u096f",0:"\u0966"},se={"\u0967":"1","\u0968":"2","\u0969":"3","\u096a":"4","\u096b":"5","\u096c":"6","\u096d":"7","\u096e":"8","\u096f":"9","\u0966":"0"};function de(e,a,_){var s=e+" ";switch(_){case"ss":return s+=1===e?"sekunda":2===e||3===e||4===e?"sekunde":"sekundi";case"m":return a?"jedna minuta":"jedne minute";case"mm":return s+=1===e?"minuta":2===e||3===e||4===e?"minute":"minuta";case"h":return a?"jedan sat":"jednog sata";case"hh":return s+=1===e?"sat":2===e||3===e||4===e?"sata":"sati";case"dd":return s+=1===e?"dan":"dana";case"MM":return s+=1===e?"mjesec":2===e||3===e||4===e?"mjeseca":"mjeseci";case"yy":return s+=1===e?"godina":2===e||3===e||4===e?"godine":"godina"}}e.defineLocale("hi",{months:"\u091c\u0928\u0935\u0930\u0940_\u092b\u093c\u0930\u0935\u0930\u0940_\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u0948\u0932_\u092e\u0908_\u091c\u0942\u0928_\u091c\u0941\u0932\u093e\u0908_\u0905\u0917\u0938\u094d\u0924_\u0938\u093f\u0924\u092e\u094d\u092c\u0930_\u0905\u0915\u094d\u091f\u0942\u092c\u0930_\u0928\u0935\u092e\u094d\u092c\u0930_\u0926\u093f\u0938\u092e\u094d\u092c\u0930".split("_"),monthsShort:"\u091c\u0928._\u092b\u093c\u0930._\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u0948._\u092e\u0908_\u091c\u0942\u0928_\u091c\u0941\u0932._\u0905\u0917._\u0938\u093f\u0924._\u0905\u0915\u094d\u091f\u0942._\u0928\u0935._\u0926\u093f\u0938.".split("_"),monthsParseExact:!0,weekdays:"\u0930\u0935\u093f\u0935\u093e\u0930_\u0938\u094b\u092e\u0935\u093e\u0930_\u092e\u0902\u0917\u0932\u0935\u093e\u0930_\u092c\u0941\u0927\u0935\u093e\u0930_\u0917\u0941\u0930\u0942\u0935\u093e\u0930_\u0936\u0941\u0915\u094d\u0930\u0935\u093e\u0930_\u0936\u0928\u093f\u0935\u093e\u0930".split("_"),weekdaysShort:"\u0930\u0935\u093f_\u0938\u094b\u092e_\u092e\u0902\u0917\u0932_\u092c\u0941\u0927_\u0917\u0941\u0930\u0942_\u0936\u0941\u0915\u094d\u0930_\u0936\u0928\u093f".split("_"),weekdaysMin:"\u0930_\u0938\u094b_\u092e\u0902_\u092c\u0941_\u0917\u0941_\u0936\u0941_\u0936".split("_"),longDateFormat:{LT:"A h:mm \u092c\u091c\u0947",LTS:"A h:mm:ss \u092c\u091c\u0947",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u092c\u091c\u0947",LLLL:"dddd, D MMMM YYYY, A h:mm \u092c\u091c\u0947"},calendar:{sameDay:"[\u0906\u091c] LT",nextDay:"[\u0915\u0932] LT",nextWeek:"dddd, LT",lastDay:"[\u0915\u0932] LT",lastWeek:"[\u092a\u093f\u091b\u0932\u0947] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u092e\u0947\u0902",past:"%s \u092a\u0939\u0932\u0947",s:"\u0915\u0941\u091b \u0939\u0940 \u0915\u094d\u0937\u0923",ss:"%d \u0938\u0947\u0915\u0902\u0921",m:"\u090f\u0915 \u092e\u093f\u0928\u091f",mm:"%d \u092e\u093f\u0928\u091f",h:"\u090f\u0915 \u0918\u0902\u091f\u093e",hh:"%d \u0918\u0902\u091f\u0947",d:"\u090f\u0915 \u0926\u093f\u0928",dd:"%d \u0926\u093f\u0928",M:"\u090f\u0915 \u092e\u0939\u0940\u0928\u0947",MM:"%d \u092e\u0939\u0940\u0928\u0947",y:"\u090f\u0915 \u0935\u0930\u094d\u0937",yy:"%d \u0935\u0930\u094d\u0937"},preparse:function(e){return e.replace(/[\u0967\u0968\u0969\u096a\u096b\u096c\u096d\u096e\u096f\u0966]/g,function(e){return se[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return _e[e]})},meridiemParse:/\u0930\u093e\u0924|\u0938\u0941\u092c\u0939|\u0926\u094b\u092a\u0939\u0930|\u0936\u093e\u092e/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0930\u093e\u0924"===a?e<4?e:e+12:"\u0938\u0941\u092c\u0939"===a?e:"\u0926\u094b\u092a\u0939\u0930"===a?10<=e?e:e+12:"\u0936\u093e\u092e"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0930\u093e\u0924":e<10?"\u0938\u0941\u092c\u0939":e<17?"\u0926\u094b\u092a\u0939\u0930":e<20?"\u0936\u093e\u092e":"\u0930\u093e\u0924"},week:{dow:0,doy:6}}),e.defineLocale("hr",{months:{format:"sije\u010dnja_velja\u010de_o\u017eujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"),standalone:"sije\u010danj_velja\u010da_o\u017eujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_")},monthsShort:"sij._velj._o\u017eu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),monthsParseExact:!0,weekdays:"nedjelja_ponedjeljak_utorak_srijeda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sri._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sutra u] LT",nextWeek:function(){switch(this.day()){case 0:return"[u] [nedjelju] [u] LT";case 3:return"[u] [srijedu] [u] LT";case 6:return"[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return"[u] dddd [u] LT"}},lastDay:"[ju\u010der u] LT",lastWeek:function(){switch(this.day()){case 0:case 3:return"[pro\u0161lu] dddd [u] LT";case 6:return"[pro\u0161le] [subote] [u] LT";case 1:case 2:case 4:case 5:return"[pro\u0161li] dddd [u] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"prije %s",s:"par sekundi",ss:de,m:de,mm:de,h:de,hh:de,d:"dan",dd:de,M:"mjesec",MM:de,y:"godinu",yy:de},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}});var te="vas\xe1rnap h\xe9tf\u0151n kedden szerd\xe1n cs\xfct\xf6rt\xf6k\xf6n p\xe9nteken szombaton".split(" ");function ne(e,a,_,s){var d=e;switch(_){case"s":return s||a?"n\xe9h\xe1ny m\xe1sodperc":"n\xe9h\xe1ny m\xe1sodperce";case"ss":return d+(s||a)?" m\xe1sodperc":" m\xe1sodperce";case"m":return"egy"+(s||a?" perc":" perce");case"mm":return d+(s||a?" perc":" perce");case"h":return"egy"+(s||a?" \xf3ra":" \xf3r\xe1ja");case"hh":return d+(s||a?" \xf3ra":" \xf3r\xe1ja");case"d":return"egy"+(s||a?" nap":" napja");case"dd":return d+(s||a?" nap":" napja");case"M":return"egy"+(s||a?" h\xf3nap":" h\xf3napja");case"MM":return d+(s||a?" h\xf3nap":" h\xf3napja");case"y":return"egy"+(s||a?" \xe9v":" \xe9ve");case"yy":return d+(s||a?" \xe9v":" \xe9ve")}return""}function re(e){return(e?"":"[m\xfalt] ")+"["+te[this.day()]+"] LT[-kor]"}function ie(e){return e%100==11||e%10!=1}function me(e,a,_,s){var d=e+" ";switch(_){case"s":return a||s?"nokkrar sek\xfandur":"nokkrum sek\xfandum";case"ss":return ie(e)?d+(a||s?"sek\xfandur":"sek\xfandum"):d+"sek\xfanda";case"m":return a?"m\xedn\xfata":"m\xedn\xfatu";case"mm":return ie(e)?d+(a||s?"m\xedn\xfatur":"m\xedn\xfatum"):a?d+"m\xedn\xfata":d+"m\xedn\xfatu";case"hh":return ie(e)?d+(a||s?"klukkustundir":"klukkustundum"):d+"klukkustund";case"d":return a?"dagur":s?"dag":"degi";case"dd":return ie(e)?a?d+"dagar":d+(s?"daga":"d\xf6gum"):a?d+"dagur":d+(s?"dag":"degi");case"M":return a?"m\xe1nu\xf0ur":s?"m\xe1nu\xf0":"m\xe1nu\xf0i";case"MM":return ie(e)?a?d+"m\xe1nu\xf0ir":d+(s?"m\xe1nu\xf0i":"m\xe1nu\xf0um"):a?d+"m\xe1nu\xf0ur":d+(s?"m\xe1nu\xf0":"m\xe1nu\xf0i");case"y":return a||s?"\xe1r":"\xe1ri";case"yy":return ie(e)?d+(a||s?"\xe1r":"\xe1rum"):d+(a||s?"\xe1r":"\xe1ri")}}e.defineLocale("hu",{months:"janu\xe1r_febru\xe1r_m\xe1rcius_\xe1prilis_m\xe1jus_j\xfanius_j\xfalius_augusztus_szeptember_okt\xf3ber_november_december".split("_"),monthsShort:"jan_feb_m\xe1rc_\xe1pr_m\xe1j_j\xfan_j\xfal_aug_szept_okt_nov_dec".split("_"),weekdays:"vas\xe1rnap_h\xe9tf\u0151_kedd_szerda_cs\xfct\xf6rt\xf6k_p\xe9ntek_szombat".split("_"),weekdaysShort:"vas_h\xe9t_kedd_sze_cs\xfct_p\xe9n_szo".split("_"),weekdaysMin:"v_h_k_sze_cs_p_szo".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"YYYY.MM.DD.",LL:"YYYY. MMMM D.",LLL:"YYYY. MMMM D. H:mm",LLLL:"YYYY. MMMM D., dddd H:mm"},meridiemParse:/de|du/i,isPM:function(e){return"u"===e.charAt(1).toLowerCase()},meridiem:function(e,a,_){return e<12?!0===_?"de":"DE":!0===_?"du":"DU"},calendar:{sameDay:"[ma] LT[-kor]",nextDay:"[holnap] LT[-kor]",nextWeek:function(){return re.call(this,!0)},lastDay:"[tegnap] LT[-kor]",lastWeek:function(){return re.call(this,!1)},sameElse:"L"},relativeTime:{future:"%s m\xfalva",past:"%s",s:ne,ss:ne,m:ne,mm:ne,h:ne,hh:ne,d:ne,dd:ne,M:ne,MM:ne,y:ne,yy:ne},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("hy-am",{months:{format:"\u0570\u0578\u0582\u0576\u057e\u0561\u0580\u056b_\u0583\u0565\u057f\u0580\u057e\u0561\u0580\u056b_\u0574\u0561\u0580\u057f\u056b_\u0561\u057a\u0580\u056b\u056c\u056b_\u0574\u0561\u0575\u056b\u057d\u056b_\u0570\u0578\u0582\u0576\u056b\u057d\u056b_\u0570\u0578\u0582\u056c\u056b\u057d\u056b_\u0585\u0563\u0578\u057d\u057f\u0578\u057d\u056b_\u057d\u0565\u057a\u057f\u0565\u0574\u0562\u0565\u0580\u056b_\u0570\u0578\u056f\u057f\u0565\u0574\u0562\u0565\u0580\u056b_\u0576\u0578\u0575\u0565\u0574\u0562\u0565\u0580\u056b_\u0564\u0565\u056f\u057f\u0565\u0574\u0562\u0565\u0580\u056b".split("_"),standalone:"\u0570\u0578\u0582\u0576\u057e\u0561\u0580_\u0583\u0565\u057f\u0580\u057e\u0561\u0580_\u0574\u0561\u0580\u057f_\u0561\u057a\u0580\u056b\u056c_\u0574\u0561\u0575\u056b\u057d_\u0570\u0578\u0582\u0576\u056b\u057d_\u0570\u0578\u0582\u056c\u056b\u057d_\u0585\u0563\u0578\u057d\u057f\u0578\u057d_\u057d\u0565\u057a\u057f\u0565\u0574\u0562\u0565\u0580_\u0570\u0578\u056f\u057f\u0565\u0574\u0562\u0565\u0580_\u0576\u0578\u0575\u0565\u0574\u0562\u0565\u0580_\u0564\u0565\u056f\u057f\u0565\u0574\u0562\u0565\u0580".split("_")},monthsShort:"\u0570\u0576\u057e_\u0583\u057f\u0580_\u0574\u0580\u057f_\u0561\u057a\u0580_\u0574\u0575\u057d_\u0570\u0576\u057d_\u0570\u056c\u057d_\u0585\u0563\u057d_\u057d\u057a\u057f_\u0570\u056f\u057f_\u0576\u0574\u0562_\u0564\u056f\u057f".split("_"),weekdays:"\u056f\u056b\u0580\u0561\u056f\u056b_\u0565\u0580\u056f\u0578\u0582\u0577\u0561\u0562\u0569\u056b_\u0565\u0580\u0565\u0584\u0577\u0561\u0562\u0569\u056b_\u0579\u0578\u0580\u0565\u0584\u0577\u0561\u0562\u0569\u056b_\u0570\u056b\u0576\u0563\u0577\u0561\u0562\u0569\u056b_\u0578\u0582\u0580\u0562\u0561\u0569_\u0577\u0561\u0562\u0561\u0569".split("_"),weekdaysShort:"\u056f\u0580\u056f_\u0565\u0580\u056f_\u0565\u0580\u0584_\u0579\u0580\u0584_\u0570\u0576\u0563_\u0578\u0582\u0580\u0562_\u0577\u0562\u0569".split("_"),weekdaysMin:"\u056f\u0580\u056f_\u0565\u0580\u056f_\u0565\u0580\u0584_\u0579\u0580\u0584_\u0570\u0576\u0563_\u0578\u0582\u0580\u0562_\u0577\u0562\u0569".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0569.",LLL:"D MMMM YYYY \u0569., HH:mm",LLLL:"dddd, D MMMM YYYY \u0569., HH:mm"},calendar:{sameDay:"[\u0561\u0575\u057d\u0585\u0580] LT",nextDay:"[\u057e\u0561\u0572\u0568] LT",lastDay:"[\u0565\u0580\u0565\u056f] LT",nextWeek:function(){return"dddd [\u0585\u0580\u0568 \u056a\u0561\u0574\u0568] LT"},lastWeek:function(){return"[\u0561\u0576\u0581\u0561\u056e] dddd [\u0585\u0580\u0568 \u056a\u0561\u0574\u0568] LT"},sameElse:"L"},relativeTime:{future:"%s \u0570\u0565\u057f\u0578",past:"%s \u0561\u057c\u0561\u057b",s:"\u0574\u056b \u0584\u0561\u0576\u056b \u057e\u0561\u0575\u0580\u056f\u0575\u0561\u0576",ss:"%d \u057e\u0561\u0575\u0580\u056f\u0575\u0561\u0576",m:"\u0580\u0578\u057a\u0565",mm:"%d \u0580\u0578\u057a\u0565",h:"\u056a\u0561\u0574",hh:"%d \u056a\u0561\u0574",d:"\u0585\u0580",dd:"%d \u0585\u0580",M:"\u0561\u0574\u056b\u057d",MM:"%d \u0561\u0574\u056b\u057d",y:"\u057f\u0561\u0580\u056b",yy:"%d \u057f\u0561\u0580\u056b"},meridiemParse:/\u0563\u056b\u0577\u0565\u0580\u057e\u0561|\u0561\u057c\u0561\u057e\u0578\u057f\u057e\u0561|\u0581\u0565\u0580\u0565\u056f\u057e\u0561|\u0565\u0580\u0565\u056f\u0578\u0575\u0561\u0576/,isPM:function(e){return/^(\u0581\u0565\u0580\u0565\u056f\u057e\u0561|\u0565\u0580\u0565\u056f\u0578\u0575\u0561\u0576)$/.test(e)},meridiem:function(e){return e<4?"\u0563\u056b\u0577\u0565\u0580\u057e\u0561":e<12?"\u0561\u057c\u0561\u057e\u0578\u057f\u057e\u0561":e<17?"\u0581\u0565\u0580\u0565\u056f\u057e\u0561":"\u0565\u0580\u0565\u056f\u0578\u0575\u0561\u0576"},dayOfMonthOrdinalParse:/\d{1,2}|\d{1,2}-(\u056b\u0576|\u0580\u0564)/,ordinal:function(e,a){switch(a){case"DDD":case"w":case"W":case"DDDo":return 1===e?e+"-\u056b\u0576":e+"-\u0580\u0564";default:return e}},week:{dow:1,doy:7}}),e.defineLocale("id",{months:"Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),monthsShort:"Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"),weekdays:"Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),weekdaysShort:"Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),weekdaysMin:"Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/pagi|siang|sore|malam/,meridiemHour:function(e,a){return 12===e&&(e=0),"pagi"===a?e:"siang"===a?11<=e?e:e+12:"sore"===a||"malam"===a?e+12:void 0},meridiem:function(e,a,_){return e<11?"pagi":e<15?"siang":e<19?"sore":"malam"},calendar:{sameDay:"[Hari ini pukul] LT",nextDay:"[Besok pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kemarin pukul] LT",lastWeek:"dddd [lalu pukul] LT",sameElse:"L"},relativeTime:{future:"dalam %s",past:"%s yang lalu",s:"beberapa detik",ss:"%d detik",m:"semenit",mm:"%d menit",h:"sejam",hh:"%d jam",d:"sehari",dd:"%d hari",M:"sebulan",MM:"%d bulan",y:"setahun",yy:"%d tahun"},week:{dow:1,doy:7}}),e.defineLocale("is",{months:"jan\xfaar_febr\xfaar_mars_apr\xedl_ma\xed_j\xfan\xed_j\xfal\xed_\xe1g\xfast_september_okt\xf3ber_n\xf3vember_desember".split("_"),monthsShort:"jan_feb_mar_apr_ma\xed_j\xfan_j\xfal_\xe1g\xfa_sep_okt_n\xf3v_des".split("_"),weekdays:"sunnudagur_m\xe1nudagur_\xferi\xf0judagur_mi\xf0vikudagur_fimmtudagur_f\xf6studagur_laugardagur".split("_"),weekdaysShort:"sun_m\xe1n_\xferi_mi\xf0_fim_f\xf6s_lau".split("_"),weekdaysMin:"Su_M\xe1_\xder_Mi_Fi_F\xf6_La".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY [kl.] H:mm",LLLL:"dddd, D. MMMM YYYY [kl.] H:mm"},calendar:{sameDay:"[\xed dag kl.] LT",nextDay:"[\xe1 morgun kl.] LT",nextWeek:"dddd [kl.] LT",lastDay:"[\xed g\xe6r kl.] LT",lastWeek:"[s\xed\xf0asta] dddd [kl.] LT",sameElse:"L"},relativeTime:{future:"eftir %s",past:"fyrir %s s\xed\xf0an",s:me,ss:me,m:me,mm:me,h:"klukkustund",hh:me,d:me,dd:me,M:me,MM:me,y:me,yy:me},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("it-ch",{months:"gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),monthsShort:"gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),weekdays:"domenica_luned\xec_marted\xec_mercoled\xec_gioved\xec_venerd\xec_sabato".split("_"),weekdaysShort:"dom_lun_mar_mer_gio_ven_sab".split("_"),weekdaysMin:"do_lu_ma_me_gi_ve_sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Oggi alle] LT",nextDay:"[Domani alle] LT",nextWeek:"dddd [alle] LT",lastDay:"[Ieri alle] LT",lastWeek:function(){switch(this.day()){case 0:return"[la scorsa] dddd [alle] LT";default:return"[lo scorso] dddd [alle] LT"}},sameElse:"L"},relativeTime:{future:function(e){return(/^[0-9].+$/.test(e)?"tra":"in")+" "+e},past:"%s fa",s:"alcuni secondi",ss:"%d secondi",m:"un minuto",mm:"%d minuti",h:"un'ora",hh:"%d ore",d:"un giorno",dd:"%d giorni",M:"un mese",MM:"%d mesi",y:"un anno",yy:"%d anni"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),e.defineLocale("it",{months:"gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),monthsShort:"gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),weekdays:"domenica_luned\xec_marted\xec_mercoled\xec_gioved\xec_venerd\xec_sabato".split("_"),weekdaysShort:"dom_lun_mar_mer_gio_ven_sab".split("_"),weekdaysMin:"do_lu_ma_me_gi_ve_sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Oggi alle] LT",nextDay:"[Domani alle] LT",nextWeek:"dddd [alle] LT",lastDay:"[Ieri alle] LT",lastWeek:function(){switch(this.day()){case 0:return"[la scorsa] dddd [alle] LT";default:return"[lo scorso] dddd [alle] LT"}},sameElse:"L"},relativeTime:{future:function(e){return(/^[0-9].+$/.test(e)?"tra":"in")+" "+e},past:"%s fa",s:"alcuni secondi",ss:"%d secondi",m:"un minuto",mm:"%d minuti",h:"un'ora",hh:"%d ore",d:"un giorno",dd:"%d giorni",M:"un mese",MM:"%d mesi",y:"un anno",yy:"%d anni"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),e.defineLocale("ja",{months:"\u4e00\u6708_\u4e8c\u6708_\u4e09\u6708_\u56db\u6708_\u4e94\u6708_\u516d\u6708_\u4e03\u6708_\u516b\u6708_\u4e5d\u6708_\u5341\u6708_\u5341\u4e00\u6708_\u5341\u4e8c\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u65e5\u66dc\u65e5_\u6708\u66dc\u65e5_\u706b\u66dc\u65e5_\u6c34\u66dc\u65e5_\u6728\u66dc\u65e5_\u91d1\u66dc\u65e5_\u571f\u66dc\u65e5".split("_"),weekdaysShort:"\u65e5_\u6708_\u706b_\u6c34_\u6728_\u91d1_\u571f".split("_"),weekdaysMin:"\u65e5_\u6708_\u706b_\u6c34_\u6728_\u91d1_\u571f".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5 HH:mm",LLLL:"YYYY\u5e74M\u6708D\u65e5 dddd HH:mm",l:"YYYY/MM/DD",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5(ddd) HH:mm"},meridiemParse:/\u5348\u524d|\u5348\u5f8c/i,isPM:function(e){return"\u5348\u5f8c"===e},meridiem:function(e,a,_){return e<12?"\u5348\u524d":"\u5348\u5f8c"},calendar:{sameDay:"[\u4eca\u65e5] LT",nextDay:"[\u660e\u65e5] LT",nextWeek:function(e){return e.week()<this.week()?"[\u6765\u9031]dddd LT":"dddd LT"},lastDay:"[\u6628\u65e5] LT",lastWeek:function(e){return this.week()<e.week()?"[\u5148\u9031]dddd LT":"dddd LT"},sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}\u65e5/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";default:return e}},relativeTime:{future:"%s\u5f8c",past:"%s\u524d",s:"\u6570\u79d2",ss:"%d\u79d2",m:"1\u5206",mm:"%d\u5206",h:"1\u6642\u9593",hh:"%d\u6642\u9593",d:"1\u65e5",dd:"%d\u65e5",M:"1\u30f6\u6708",MM:"%d\u30f6\u6708",y:"1\u5e74",yy:"%d\u5e74"}}),e.defineLocale("jv",{months:"Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"),monthsShort:"Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),weekdays:"Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),weekdaysShort:"Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),weekdaysMin:"Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/enjing|siyang|sonten|ndalu/,meridiemHour:function(e,a){return 12===e&&(e=0),"enjing"===a?e:"siyang"===a?11<=e?e:e+12:"sonten"===a||"ndalu"===a?e+12:void 0},meridiem:function(e,a,_){return e<11?"enjing":e<15?"siyang":e<19?"sonten":"ndalu"},calendar:{sameDay:"[Dinten puniko pukul] LT",nextDay:"[Mbenjang pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kala wingi pukul] LT",lastWeek:"dddd [kepengker pukul] LT",sameElse:"L"},relativeTime:{future:"wonten ing %s",past:"%s ingkang kepengker",s:"sawetawis detik",ss:"%d detik",m:"setunggal menit",mm:"%d menit",h:"setunggal jam",hh:"%d jam",d:"sedinten",dd:"%d dinten",M:"sewulan",MM:"%d wulan",y:"setaun",yy:"%d taun"},week:{dow:1,doy:7}}),e.defineLocale("ka",{months:{standalone:"\u10d8\u10d0\u10dc\u10d5\u10d0\u10e0\u10d8_\u10d7\u10d4\u10d1\u10d4\u10e0\u10d5\u10d0\u10da\u10d8_\u10db\u10d0\u10e0\u10e2\u10d8_\u10d0\u10de\u10e0\u10d8\u10da\u10d8_\u10db\u10d0\u10d8\u10e1\u10d8_\u10d8\u10d5\u10dc\u10d8\u10e1\u10d8_\u10d8\u10d5\u10da\u10d8\u10e1\u10d8_\u10d0\u10d2\u10d5\u10d8\u10e1\u10e2\u10dd_\u10e1\u10d4\u10e5\u10e2\u10d4\u10db\u10d1\u10d4\u10e0\u10d8_\u10dd\u10e5\u10e2\u10dd\u10db\u10d1\u10d4\u10e0\u10d8_\u10dc\u10dd\u10d4\u10db\u10d1\u10d4\u10e0\u10d8_\u10d3\u10d4\u10d9\u10d4\u10db\u10d1\u10d4\u10e0\u10d8".split("_"),format:"\u10d8\u10d0\u10dc\u10d5\u10d0\u10e0\u10e1_\u10d7\u10d4\u10d1\u10d4\u10e0\u10d5\u10d0\u10da\u10e1_\u10db\u10d0\u10e0\u10e2\u10e1_\u10d0\u10de\u10e0\u10d8\u10da\u10d8\u10e1_\u10db\u10d0\u10d8\u10e1\u10e1_\u10d8\u10d5\u10dc\u10d8\u10e1\u10e1_\u10d8\u10d5\u10da\u10d8\u10e1\u10e1_\u10d0\u10d2\u10d5\u10d8\u10e1\u10e2\u10e1_\u10e1\u10d4\u10e5\u10e2\u10d4\u10db\u10d1\u10d4\u10e0\u10e1_\u10dd\u10e5\u10e2\u10dd\u10db\u10d1\u10d4\u10e0\u10e1_\u10dc\u10dd\u10d4\u10db\u10d1\u10d4\u10e0\u10e1_\u10d3\u10d4\u10d9\u10d4\u10db\u10d1\u10d4\u10e0\u10e1".split("_")},monthsShort:"\u10d8\u10d0\u10dc_\u10d7\u10d4\u10d1_\u10db\u10d0\u10e0_\u10d0\u10de\u10e0_\u10db\u10d0\u10d8_\u10d8\u10d5\u10dc_\u10d8\u10d5\u10da_\u10d0\u10d2\u10d5_\u10e1\u10d4\u10e5_\u10dd\u10e5\u10e2_\u10dc\u10dd\u10d4_\u10d3\u10d4\u10d9".split("_"),weekdays:{standalone:"\u10d9\u10d5\u10d8\u10e0\u10d0_\u10dd\u10e0\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10e1\u10d0\u10db\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10dd\u10d7\u10ee\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10ee\u10e3\u10d7\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10de\u10d0\u10e0\u10d0\u10e1\u10d9\u10d4\u10d5\u10d8_\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8".split("_"),format:"\u10d9\u10d5\u10d8\u10e0\u10d0\u10e1_\u10dd\u10e0\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10e1\u10d0\u10db\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10dd\u10d7\u10ee\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10ee\u10e3\u10d7\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10de\u10d0\u10e0\u10d0\u10e1\u10d9\u10d4\u10d5\u10e1_\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1".split("_"),isFormat:/(\u10ec\u10d8\u10dc\u10d0|\u10e8\u10d4\u10db\u10d3\u10d4\u10d2)/},weekdaysShort:"\u10d9\u10d5\u10d8_\u10dd\u10e0\u10e8_\u10e1\u10d0\u10db_\u10dd\u10d7\u10ee_\u10ee\u10e3\u10d7_\u10de\u10d0\u10e0_\u10e8\u10d0\u10d1".split("_"),weekdaysMin:"\u10d9\u10d5_\u10dd\u10e0_\u10e1\u10d0_\u10dd\u10d7_\u10ee\u10e3_\u10de\u10d0_\u10e8\u10d0".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[\u10d3\u10e6\u10d4\u10e1] LT[-\u10d6\u10d4]",nextDay:"[\u10ee\u10d5\u10d0\u10da] LT[-\u10d6\u10d4]",lastDay:"[\u10d2\u10e3\u10e8\u10d8\u10dc] LT[-\u10d6\u10d4]",nextWeek:"[\u10e8\u10d4\u10db\u10d3\u10d4\u10d2] dddd LT[-\u10d6\u10d4]",lastWeek:"[\u10ec\u10d8\u10dc\u10d0] dddd LT-\u10d6\u10d4",sameElse:"L"},relativeTime:{future:function(e){return/(\u10ec\u10d0\u10db\u10d8|\u10ec\u10e3\u10d7\u10d8|\u10e1\u10d0\u10d0\u10d7\u10d8|\u10ec\u10d4\u10da\u10d8)/.test(e)?e.replace(/\u10d8$/,"\u10e8\u10d8"):e+"\u10e8\u10d8"},past:function(e){return/(\u10ec\u10d0\u10db\u10d8|\u10ec\u10e3\u10d7\u10d8|\u10e1\u10d0\u10d0\u10d7\u10d8|\u10d3\u10e6\u10d4|\u10d7\u10d5\u10d4)/.test(e)?e.replace(/(\u10d8|\u10d4)$/,"\u10d8\u10e1 \u10ec\u10d8\u10dc"):/\u10ec\u10d4\u10da\u10d8/.test(e)?e.replace(/\u10ec\u10d4\u10da\u10d8$/,"\u10ec\u10da\u10d8\u10e1 \u10ec\u10d8\u10dc"):void 0},s:"\u10e0\u10d0\u10db\u10d3\u10d4\u10dc\u10d8\u10db\u10d4 \u10ec\u10d0\u10db\u10d8",ss:"%d \u10ec\u10d0\u10db\u10d8",m:"\u10ec\u10e3\u10d7\u10d8",mm:"%d \u10ec\u10e3\u10d7\u10d8",h:"\u10e1\u10d0\u10d0\u10d7\u10d8",hh:"%d \u10e1\u10d0\u10d0\u10d7\u10d8",d:"\u10d3\u10e6\u10d4",dd:"%d \u10d3\u10e6\u10d4",M:"\u10d7\u10d5\u10d4",MM:"%d \u10d7\u10d5\u10d4",y:"\u10ec\u10d4\u10da\u10d8",yy:"%d \u10ec\u10d4\u10da\u10d8"},dayOfMonthOrdinalParse:/0|1-\u10da\u10d8|\u10db\u10d4-\d{1,2}|\d{1,2}-\u10d4/,ordinal:function(e){return 0===e?e:1===e?e+"-\u10da\u10d8":e<20||e<=100&&e%20==0||e%100==0?"\u10db\u10d4-"+e:e+"-\u10d4"},week:{dow:1,doy:7}});var oe={0:"-\u0448\u0456",1:"-\u0448\u0456",2:"-\u0448\u0456",3:"-\u0448\u0456",4:"-\u0448\u0456",5:"-\u0448\u0456",6:"-\u0448\u044b",7:"-\u0448\u0456",8:"-\u0448\u0456",9:"-\u0448\u044b",10:"-\u0448\u044b",20:"-\u0448\u044b",30:"-\u0448\u044b",40:"-\u0448\u044b",50:"-\u0448\u0456",60:"-\u0448\u044b",70:"-\u0448\u0456",80:"-\u0448\u0456",90:"-\u0448\u044b",100:"-\u0448\u0456"};e.defineLocale("kk",{months:"\u049b\u0430\u04a3\u0442\u0430\u0440_\u0430\u049b\u043f\u0430\u043d_\u043d\u0430\u0443\u0440\u044b\u0437_\u0441\u04d9\u0443\u0456\u0440_\u043c\u0430\u043c\u044b\u0440_\u043c\u0430\u0443\u0441\u044b\u043c_\u0448\u0456\u043b\u0434\u0435_\u0442\u0430\u043c\u044b\u0437_\u049b\u044b\u0440\u043a\u04af\u0439\u0435\u043a_\u049b\u0430\u0437\u0430\u043d_\u049b\u0430\u0440\u0430\u0448\u0430_\u0436\u0435\u043b\u0442\u043e\u049b\u0441\u0430\u043d".split("_"),monthsShort:"\u049b\u0430\u04a3_\u0430\u049b\u043f_\u043d\u0430\u0443_\u0441\u04d9\u0443_\u043c\u0430\u043c_\u043c\u0430\u0443_\u0448\u0456\u043b_\u0442\u0430\u043c_\u049b\u044b\u0440_\u049b\u0430\u0437_\u049b\u0430\u0440_\u0436\u0435\u043b".split("_"),weekdays:"\u0436\u0435\u043a\u0441\u0435\u043d\u0431\u0456_\u0434\u04af\u0439\u0441\u0435\u043d\u0431\u0456_\u0441\u0435\u0439\u0441\u0435\u043d\u0431\u0456_\u0441\u04d9\u0440\u0441\u0435\u043d\u0431\u0456_\u0431\u0435\u0439\u0441\u0435\u043d\u0431\u0456_\u0436\u04b1\u043c\u0430_\u0441\u0435\u043d\u0431\u0456".split("_"),weekdaysShort:"\u0436\u0435\u043a_\u0434\u04af\u0439_\u0441\u0435\u0439_\u0441\u04d9\u0440_\u0431\u0435\u0439_\u0436\u04b1\u043c_\u0441\u0435\u043d".split("_"),weekdaysMin:"\u0436\u043a_\u0434\u0439_\u0441\u0439_\u0441\u0440_\u0431\u0439_\u0436\u043c_\u0441\u043d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0411\u04af\u0433\u0456\u043d \u0441\u0430\u0493\u0430\u0442] LT",nextDay:"[\u0415\u0440\u0442\u0435\u04a3 \u0441\u0430\u0493\u0430\u0442] LT",nextWeek:"dddd [\u0441\u0430\u0493\u0430\u0442] LT",lastDay:"[\u041a\u0435\u0448\u0435 \u0441\u0430\u0493\u0430\u0442] LT",lastWeek:"[\u04e8\u0442\u043a\u0435\u043d \u0430\u043f\u0442\u0430\u043d\u044b\u04a3] dddd [\u0441\u0430\u0493\u0430\u0442] LT",sameElse:"L"},relativeTime:{future:"%s \u0456\u0448\u0456\u043d\u0434\u0435",past:"%s \u0431\u04b1\u0440\u044b\u043d",s:"\u0431\u0456\u0440\u043d\u0435\u0448\u0435 \u0441\u0435\u043a\u0443\u043d\u0434",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434",m:"\u0431\u0456\u0440 \u043c\u0438\u043d\u0443\u0442",mm:"%d \u043c\u0438\u043d\u0443\u0442",h:"\u0431\u0456\u0440 \u0441\u0430\u0493\u0430\u0442",hh:"%d \u0441\u0430\u0493\u0430\u0442",d:"\u0431\u0456\u0440 \u043a\u04af\u043d",dd:"%d \u043a\u04af\u043d",M:"\u0431\u0456\u0440 \u0430\u0439",MM:"%d \u0430\u0439",y:"\u0431\u0456\u0440 \u0436\u044b\u043b",yy:"%d \u0436\u044b\u043b"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0448\u0456|\u0448\u044b)/,ordinal:function(e){return e+(oe[e]||oe[e%10]||oe[100<=e?100:null])},week:{dow:1,doy:7}});var ue={1:"\u17e1",2:"\u17e2",3:"\u17e3",4:"\u17e4",5:"\u17e5",6:"\u17e6",7:"\u17e7",8:"\u17e8",9:"\u17e9",0:"\u17e0"},le={"\u17e1":"1","\u17e2":"2","\u17e3":"3","\u17e4":"4","\u17e5":"5","\u17e6":"6","\u17e7":"7","\u17e8":"8","\u17e9":"9","\u17e0":"0"};e.defineLocale("km",{months:"\u1798\u1780\u179a\u17b6_\u1780\u17bb\u1798\u17d2\u1797\u17c8_\u1798\u17b8\u1793\u17b6_\u1798\u17c1\u179f\u17b6_\u17a7\u179f\u1797\u17b6_\u1798\u17b7\u1790\u17bb\u1793\u17b6_\u1780\u1780\u17d2\u1780\u178a\u17b6_\u179f\u17b8\u17a0\u17b6_\u1780\u1789\u17d2\u1789\u17b6_\u178f\u17bb\u179b\u17b6_\u179c\u17b7\u1785\u17d2\u1786\u17b7\u1780\u17b6_\u1792\u17d2\u1793\u17bc".split("_"),monthsShort:"\u1798\u1780\u179a\u17b6_\u1780\u17bb\u1798\u17d2\u1797\u17c8_\u1798\u17b8\u1793\u17b6_\u1798\u17c1\u179f\u17b6_\u17a7\u179f\u1797\u17b6_\u1798\u17b7\u1790\u17bb\u1793\u17b6_\u1780\u1780\u17d2\u1780\u178a\u17b6_\u179f\u17b8\u17a0\u17b6_\u1780\u1789\u17d2\u1789\u17b6_\u178f\u17bb\u179b\u17b6_\u179c\u17b7\u1785\u17d2\u1786\u17b7\u1780\u17b6_\u1792\u17d2\u1793\u17bc".split("_"),weekdays:"\u17a2\u17b6\u1791\u17b7\u178f\u17d2\u1799_\u1785\u17d0\u1793\u17d2\u1791_\u17a2\u1784\u17d2\u1782\u17b6\u179a_\u1796\u17bb\u1792_\u1796\u17d2\u179a\u17a0\u179f\u17d2\u1794\u178f\u17b7\u17cd_\u179f\u17bb\u1780\u17d2\u179a_\u179f\u17c5\u179a\u17cd".split("_"),weekdaysShort:"\u17a2\u17b6_\u1785_\u17a2_\u1796_\u1796\u17d2\u179a_\u179f\u17bb_\u179f".split("_"),weekdaysMin:"\u17a2\u17b6_\u1785_\u17a2_\u1796_\u1796\u17d2\u179a_\u179f\u17bb_\u179f".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},meridiemParse:/\u1796\u17d2\u179a\u17b9\u1780|\u179b\u17d2\u1784\u17b6\u1785/,isPM:function(e){return"\u179b\u17d2\u1784\u17b6\u1785"===e},meridiem:function(e,a,_){return e<12?"\u1796\u17d2\u179a\u17b9\u1780":"\u179b\u17d2\u1784\u17b6\u1785"},calendar:{sameDay:"[\u1790\u17d2\u1784\u17c3\u1793\u17c1\u17c7 \u1798\u17c9\u17c4\u1784] LT",nextDay:"[\u179f\u17d2\u17a2\u17c2\u1780 \u1798\u17c9\u17c4\u1784] LT",nextWeek:"dddd [\u1798\u17c9\u17c4\u1784] LT",lastDay:"[\u1798\u17d2\u179f\u17b7\u179b\u1798\u17b7\u1789 \u1798\u17c9\u17c4\u1784] LT",lastWeek:"dddd [\u179f\u1794\u17d2\u178f\u17b6\u17a0\u17cd\u1798\u17bb\u1793] [\u1798\u17c9\u17c4\u1784] LT",sameElse:"L"},relativeTime:{future:"%s\u1791\u17c0\u178f",past:"%s\u1798\u17bb\u1793",s:"\u1794\u17c9\u17bb\u1793\u17d2\u1798\u17b6\u1793\u179c\u17b7\u1793\u17b6\u1791\u17b8",ss:"%d \u179c\u17b7\u1793\u17b6\u1791\u17b8",m:"\u1798\u17bd\u1799\u1793\u17b6\u1791\u17b8",mm:"%d \u1793\u17b6\u1791\u17b8",h:"\u1798\u17bd\u1799\u1798\u17c9\u17c4\u1784",hh:"%d \u1798\u17c9\u17c4\u1784",d:"\u1798\u17bd\u1799\u1790\u17d2\u1784\u17c3",dd:"%d \u1790\u17d2\u1784\u17c3",M:"\u1798\u17bd\u1799\u1781\u17c2",MM:"%d \u1781\u17c2",y:"\u1798\u17bd\u1799\u1786\u17d2\u1793\u17b6\u17c6",yy:"%d \u1786\u17d2\u1793\u17b6\u17c6"},dayOfMonthOrdinalParse:/\u1791\u17b8\d{1,2}/,ordinal:"\u1791\u17b8%d",preparse:function(e){return e.replace(/[\u17e1\u17e2\u17e3\u17e4\u17e5\u17e6\u17e7\u17e8\u17e9\u17e0]/g,function(e){return le[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return ue[e]})},week:{dow:1,doy:4}});var Me={1:"\u0ce7",2:"\u0ce8",3:"\u0ce9",4:"\u0cea",5:"\u0ceb",6:"\u0cec",7:"\u0ced",8:"\u0cee",9:"\u0cef",0:"\u0ce6"},Le={"\u0ce7":"1","\u0ce8":"2","\u0ce9":"3","\u0cea":"4","\u0ceb":"5","\u0cec":"6","\u0ced":"7","\u0cee":"8","\u0cef":"9","\u0ce6":"0"};e.defineLocale("kn",{months:"\u0c9c\u0ca8\u0cb5\u0cb0\u0cbf_\u0cab\u0cc6\u0cac\u0ccd\u0cb0\u0cb5\u0cb0\u0cbf_\u0cae\u0cbe\u0cb0\u0ccd\u0c9a\u0ccd_\u0c8f\u0caa\u0ccd\u0cb0\u0cbf\u0cb2\u0ccd_\u0cae\u0cc6\u0cd5_\u0c9c\u0cc2\u0ca8\u0ccd_\u0c9c\u0cc1\u0cb2\u0cc6\u0cd6_\u0c86\u0c97\u0cb8\u0ccd\u0c9f\u0ccd_\u0cb8\u0cc6\u0caa\u0ccd\u0c9f\u0cc6\u0c82\u0cac\u0cb0\u0ccd_\u0c85\u0c95\u0ccd\u0c9f\u0cc6\u0cc2\u0cd5\u0cac\u0cb0\u0ccd_\u0ca8\u0cb5\u0cc6\u0c82\u0cac\u0cb0\u0ccd_\u0ca1\u0cbf\u0cb8\u0cc6\u0c82\u0cac\u0cb0\u0ccd".split("_"),monthsShort:"\u0c9c\u0ca8_\u0cab\u0cc6\u0cac\u0ccd\u0cb0_\u0cae\u0cbe\u0cb0\u0ccd\u0c9a\u0ccd_\u0c8f\u0caa\u0ccd\u0cb0\u0cbf\u0cb2\u0ccd_\u0cae\u0cc6\u0cd5_\u0c9c\u0cc2\u0ca8\u0ccd_\u0c9c\u0cc1\u0cb2\u0cc6\u0cd6_\u0c86\u0c97\u0cb8\u0ccd\u0c9f\u0ccd_\u0cb8\u0cc6\u0caa\u0ccd\u0c9f\u0cc6\u0c82_\u0c85\u0c95\u0ccd\u0c9f\u0cc6\u0cc2\u0cd5_\u0ca8\u0cb5\u0cc6\u0c82_\u0ca1\u0cbf\u0cb8\u0cc6\u0c82".split("_"),monthsParseExact:!0,weekdays:"\u0cad\u0cbe\u0ca8\u0cc1\u0cb5\u0cbe\u0cb0_\u0cb8\u0cc6\u0cc2\u0cd5\u0cae\u0cb5\u0cbe\u0cb0_\u0cae\u0c82\u0c97\u0cb3\u0cb5\u0cbe\u0cb0_\u0cac\u0cc1\u0ca7\u0cb5\u0cbe\u0cb0_\u0c97\u0cc1\u0cb0\u0cc1\u0cb5\u0cbe\u0cb0_\u0cb6\u0cc1\u0c95\u0ccd\u0cb0\u0cb5\u0cbe\u0cb0_\u0cb6\u0ca8\u0cbf\u0cb5\u0cbe\u0cb0".split("_"),weekdaysShort:"\u0cad\u0cbe\u0ca8\u0cc1_\u0cb8\u0cc6\u0cc2\u0cd5\u0cae_\u0cae\u0c82\u0c97\u0cb3_\u0cac\u0cc1\u0ca7_\u0c97\u0cc1\u0cb0\u0cc1_\u0cb6\u0cc1\u0c95\u0ccd\u0cb0_\u0cb6\u0ca8\u0cbf".split("_"),weekdaysMin:"\u0cad\u0cbe_\u0cb8\u0cc6\u0cc2\u0cd5_\u0cae\u0c82_\u0cac\u0cc1_\u0c97\u0cc1_\u0cb6\u0cc1_\u0cb6".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm",LLLL:"dddd, D MMMM YYYY, A h:mm"},calendar:{sameDay:"[\u0c87\u0c82\u0ca6\u0cc1] LT",nextDay:"[\u0ca8\u0cbe\u0cb3\u0cc6] LT",nextWeek:"dddd, LT",lastDay:"[\u0ca8\u0cbf\u0ca8\u0ccd\u0ca8\u0cc6] LT",lastWeek:"[\u0c95\u0cc6\u0cc2\u0ca8\u0cc6\u0caf] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0ca8\u0c82\u0ca4\u0cb0",past:"%s \u0cb9\u0cbf\u0c82\u0ca6\u0cc6",s:"\u0c95\u0cc6\u0cb2\u0cb5\u0cc1 \u0c95\u0ccd\u0cb7\u0ca3\u0c97\u0cb3\u0cc1",ss:"%d \u0cb8\u0cc6\u0c95\u0cc6\u0c82\u0ca1\u0cc1\u0c97\u0cb3\u0cc1",m:"\u0c92\u0c82\u0ca6\u0cc1 \u0ca8\u0cbf\u0cae\u0cbf\u0cb7",mm:"%d \u0ca8\u0cbf\u0cae\u0cbf\u0cb7",h:"\u0c92\u0c82\u0ca6\u0cc1 \u0c97\u0c82\u0c9f\u0cc6",hh:"%d \u0c97\u0c82\u0c9f\u0cc6",d:"\u0c92\u0c82\u0ca6\u0cc1 \u0ca6\u0cbf\u0ca8",dd:"%d \u0ca6\u0cbf\u0ca8",M:"\u0c92\u0c82\u0ca6\u0cc1 \u0ca4\u0cbf\u0c82\u0c97\u0cb3\u0cc1",MM:"%d \u0ca4\u0cbf\u0c82\u0c97\u0cb3\u0cc1",y:"\u0c92\u0c82\u0ca6\u0cc1 \u0cb5\u0cb0\u0ccd\u0cb7",yy:"%d \u0cb5\u0cb0\u0ccd\u0cb7"},preparse:function(e){return e.replace(/[\u0ce7\u0ce8\u0ce9\u0cea\u0ceb\u0cec\u0ced\u0cee\u0cef\u0ce6]/g,function(e){return Le[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Me[e]})},meridiemParse:/\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf|\u0cac\u0cc6\u0cb3\u0cbf\u0c97\u0ccd\u0c97\u0cc6|\u0cae\u0ca7\u0ccd\u0caf\u0cbe\u0cb9\u0ccd\u0ca8|\u0cb8\u0c82\u0c9c\u0cc6/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf"===a?e<4?e:e+12:"\u0cac\u0cc6\u0cb3\u0cbf\u0c97\u0ccd\u0c97\u0cc6"===a?e:"\u0cae\u0ca7\u0ccd\u0caf\u0cbe\u0cb9\u0ccd\u0ca8"===a?10<=e?e:e+12:"\u0cb8\u0c82\u0c9c\u0cc6"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf":e<10?"\u0cac\u0cc6\u0cb3\u0cbf\u0c97\u0ccd\u0c97\u0cc6":e<17?"\u0cae\u0ca7\u0ccd\u0caf\u0cbe\u0cb9\u0ccd\u0ca8":e<20?"\u0cb8\u0c82\u0c9c\u0cc6":"\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf"},dayOfMonthOrdinalParse:/\d{1,2}(\u0ca8\u0cc6\u0cd5)/,ordinal:function(e){return e+"\u0ca8\u0cc6\u0cd5"},week:{dow:0,doy:6}}),e.defineLocale("ko",{months:"1\uc6d4_2\uc6d4_3\uc6d4_4\uc6d4_5\uc6d4_6\uc6d4_7\uc6d4_8\uc6d4_9\uc6d4_10\uc6d4_11\uc6d4_12\uc6d4".split("_"),monthsShort:"1\uc6d4_2\uc6d4_3\uc6d4_4\uc6d4_5\uc6d4_6\uc6d4_7\uc6d4_8\uc6d4_9\uc6d4_10\uc6d4_11\uc6d4_12\uc6d4".split("_"),weekdays:"\uc77c\uc694\uc77c_\uc6d4\uc694\uc77c_\ud654\uc694\uc77c_\uc218\uc694\uc77c_\ubaa9\uc694\uc77c_\uae08\uc694\uc77c_\ud1a0\uc694\uc77c".split("_"),weekdaysShort:"\uc77c_\uc6d4_\ud654_\uc218_\ubaa9_\uae08_\ud1a0".split("_"),weekdaysMin:"\uc77c_\uc6d4_\ud654_\uc218_\ubaa9_\uae08_\ud1a0".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"YYYY.MM.DD.",LL:"YYYY\ub144 MMMM D\uc77c",LLL:"YYYY\ub144 MMMM D\uc77c A h:mm",LLLL:"YYYY\ub144 MMMM D\uc77c dddd A h:mm",l:"YYYY.MM.DD.",ll:"YYYY\ub144 MMMM D\uc77c",lll:"YYYY\ub144 MMMM D\uc77c A h:mm",llll:"YYYY\ub144 MMMM D\uc77c dddd A h:mm"},calendar:{sameDay:"\uc624\ub298 LT",nextDay:"\ub0b4\uc77c LT",nextWeek:"dddd LT",lastDay:"\uc5b4\uc81c LT",lastWeek:"\uc9c0\ub09c\uc8fc dddd LT",sameElse:"L"},relativeTime:{future:"%s \ud6c4",past:"%s \uc804",s:"\uba87 \ucd08",ss:"%d\ucd08",m:"1\ubd84",mm:"%d\ubd84",h:"\ud55c \uc2dc\uac04",hh:"%d\uc2dc\uac04",d:"\ud558\ub8e8",dd:"%d\uc77c",M:"\ud55c \ub2ec",MM:"%d\ub2ec",y:"\uc77c \ub144",yy:"%d\ub144"},dayOfMonthOrdinalParse:/\d{1,2}(\uc77c|\uc6d4|\uc8fc)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\uc77c";case"M":return e+"\uc6d4";case"w":case"W":return e+"\uc8fc";default:return e}},meridiemParse:/\uc624\uc804|\uc624\ud6c4/,isPM:function(e){return"\uc624\ud6c4"===e},meridiem:function(e,a,_){return e<12?"\uc624\uc804":"\uc624\ud6c4"}});var Ye={1:"\u0661",2:"\u0662",3:"\u0663",4:"\u0664",5:"\u0665",6:"\u0666",7:"\u0667",8:"\u0668",9:"\u0669",0:"\u0660"},he={"\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u0660":"0"},ye=["\u06a9\u0627\u0646\u0648\u0646\u06cc \u062f\u0648\u0648\u06d5\u0645","\u0634\u0648\u0628\u0627\u062a","\u0626\u0627\u0632\u0627\u0631","\u0646\u06cc\u0633\u0627\u0646","\u0626\u0627\u06cc\u0627\u0631","\u062d\u0648\u0632\u06d5\u06cc\u0631\u0627\u0646","\u062a\u06d5\u0645\u0645\u0648\u0632","\u0626\u0627\u0628","\u0626\u06d5\u06cc\u0644\u0648\u0648\u0644","\u062a\u0634\u0631\u06cc\u0646\u06cc \u06cc\u06d5\u0643\u06d5\u0645","\u062a\u0634\u0631\u06cc\u0646\u06cc \u062f\u0648\u0648\u06d5\u0645","\u0643\u0627\u0646\u0648\u0646\u06cc \u06cc\u06d5\u06a9\u06d5\u0645"];e.defineLocale("ku",{months:ye,monthsShort:ye,weekdays:"\u06cc\u0647\u200c\u0643\u0634\u0647\u200c\u0645\u0645\u0647\u200c_\u062f\u0648\u0648\u0634\u0647\u200c\u0645\u0645\u0647\u200c_\u0633\u06ce\u0634\u0647\u200c\u0645\u0645\u0647\u200c_\u0686\u0648\u0627\u0631\u0634\u0647\u200c\u0645\u0645\u0647\u200c_\u067e\u06ce\u0646\u062c\u0634\u0647\u200c\u0645\u0645\u0647\u200c_\u0647\u0647\u200c\u06cc\u0646\u06cc_\u0634\u0647\u200c\u0645\u0645\u0647\u200c".split("_"),weekdaysShort:"\u06cc\u0647\u200c\u0643\u0634\u0647\u200c\u0645_\u062f\u0648\u0648\u0634\u0647\u200c\u0645_\u0633\u06ce\u0634\u0647\u200c\u0645_\u0686\u0648\u0627\u0631\u0634\u0647\u200c\u0645_\u067e\u06ce\u0646\u062c\u0634\u0647\u200c\u0645_\u0647\u0647\u200c\u06cc\u0646\u06cc_\u0634\u0647\u200c\u0645\u0645\u0647\u200c".split("_"),weekdaysMin:"\u06cc_\u062f_\u0633_\u0686_\u067e_\u0647_\u0634".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},meridiemParse:/\u0626\u06ce\u0648\u0627\u0631\u0647\u200c|\u0628\u0647\u200c\u06cc\u0627\u0646\u06cc/,isPM:function(e){return/\u0626\u06ce\u0648\u0627\u0631\u0647\u200c/.test(e)},meridiem:function(e,a,_){return e<12?"\u0628\u0647\u200c\u06cc\u0627\u0646\u06cc":"\u0626\u06ce\u0648\u0627\u0631\u0647\u200c"},calendar:{sameDay:"[\u0626\u0647\u200c\u0645\u0631\u06c6 \u0643\u0627\u062a\u0698\u0645\u06ce\u0631] LT",nextDay:"[\u0628\u0647\u200c\u06cc\u0627\u0646\u06cc \u0643\u0627\u062a\u0698\u0645\u06ce\u0631] LT",nextWeek:"dddd [\u0643\u0627\u062a\u0698\u0645\u06ce\u0631] LT",lastDay:"[\u062f\u0648\u06ce\u0646\u06ce \u0643\u0627\u062a\u0698\u0645\u06ce\u0631] LT",lastWeek:"dddd [\u0643\u0627\u062a\u0698\u0645\u06ce\u0631] LT",sameElse:"L"},relativeTime:{future:"\u0644\u0647\u200c %s",past:"%s",s:"\u0686\u0647\u200c\u0646\u062f \u0686\u0631\u0643\u0647\u200c\u06cc\u0647\u200c\u0643",ss:"\u0686\u0631\u0643\u0647\u200c %d",m:"\u06cc\u0647\u200c\u0643 \u062e\u0648\u0644\u0647\u200c\u0643",mm:"%d \u062e\u0648\u0644\u0647\u200c\u0643",h:"\u06cc\u0647\u200c\u0643 \u0643\u0627\u062a\u0698\u0645\u06ce\u0631",hh:"%d \u0643\u0627\u062a\u0698\u0645\u06ce\u0631",d:"\u06cc\u0647\u200c\u0643 \u0695\u06c6\u0698",dd:"%d \u0695\u06c6\u0698",M:"\u06cc\u0647\u200c\u0643 \u0645\u0627\u0646\u06af",MM:"%d \u0645\u0627\u0646\u06af",y:"\u06cc\u0647\u200c\u0643 \u0633\u0627\u06b5",yy:"%d \u0633\u0627\u06b5"},preparse:function(e){return e.replace(/[\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660]/g,function(e){return he[e]}).replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return Ye[e]}).replace(/,/g,"\u060c")},week:{dow:6,doy:12}});var ce={0:"-\u0447\u04af",1:"-\u0447\u0438",2:"-\u0447\u0438",3:"-\u0447\u04af",4:"-\u0447\u04af",5:"-\u0447\u0438",6:"-\u0447\u044b",7:"-\u0447\u0438",8:"-\u0447\u0438",9:"-\u0447\u0443",10:"-\u0447\u0443",20:"-\u0447\u044b",30:"-\u0447\u0443",40:"-\u0447\u044b",50:"-\u0447\u04af",60:"-\u0447\u044b",70:"-\u0447\u0438",80:"-\u0447\u0438",90:"-\u0447\u0443",100:"-\u0447\u04af"};function ke(e,a,_,s){var d={m:["eng Minutt","enger Minutt"],h:["eng Stonn","enger Stonn"],d:["een Dag","engem Dag"],M:["ee Mount","engem Mount"],y:["ee Joer","engem Joer"]};return a?d[_][0]:d[_][1]}function pe(e){if(e=parseInt(e,10),isNaN(e))return!1;if(e<0)return!0;if(e<10)return 4<=e&&e<=7;if(e<100){var a=e%10;return pe(0===a?e/10:a)}if(e<1e4){for(;10<=e;)e/=10;return pe(e)}return pe(e/=1e3)}e.defineLocale("ky",{months:"\u044f\u043d\u0432\u0430\u0440\u044c_\u0444\u0435\u0432\u0440\u0430\u043b\u044c_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b\u044c_\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440\u044c_\u043e\u043a\u0442\u044f\u0431\u0440\u044c_\u043d\u043e\u044f\u0431\u0440\u044c_\u0434\u0435\u043a\u0430\u0431\u0440\u044c".split("_"),monthsShort:"\u044f\u043d\u0432_\u0444\u0435\u0432_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440_\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433_\u0441\u0435\u043d_\u043e\u043a\u0442_\u043d\u043e\u044f_\u0434\u0435\u043a".split("_"),weekdays:"\u0416\u0435\u043a\u0448\u0435\u043c\u0431\u0438_\u0414\u04af\u0439\u0448\u04e9\u043c\u0431\u04af_\u0428\u0435\u0439\u0448\u0435\u043c\u0431\u0438_\u0428\u0430\u0440\u0448\u0435\u043c\u0431\u0438_\u0411\u0435\u0439\u0448\u0435\u043c\u0431\u0438_\u0416\u0443\u043c\u0430_\u0418\u0448\u0435\u043c\u0431\u0438".split("_"),weekdaysShort:"\u0416\u0435\u043a_\u0414\u04af\u0439_\u0428\u0435\u0439_\u0428\u0430\u0440_\u0411\u0435\u0439_\u0416\u0443\u043c_\u0418\u0448\u0435".split("_"),weekdaysMin:"\u0416\u043a_\u0414\u0439_\u0428\u0439_\u0428\u0440_\u0411\u0439_\u0416\u043c_\u0418\u0448".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0411\u04af\u0433\u04af\u043d \u0441\u0430\u0430\u0442] LT",nextDay:"[\u042d\u0440\u0442\u0435\u04a3 \u0441\u0430\u0430\u0442] LT",nextWeek:"dddd [\u0441\u0430\u0430\u0442] LT",lastDay:"[\u041a\u0435\u0447\u044d\u044d \u0441\u0430\u0430\u0442] LT",lastWeek:"[\u04e8\u0442\u043a\u04e9\u043d \u0430\u043f\u0442\u0430\u043d\u044b\u043d] dddd [\u043a\u04af\u043d\u04af] [\u0441\u0430\u0430\u0442] LT",sameElse:"L"},relativeTime:{future:"%s \u0438\u0447\u0438\u043d\u0434\u0435",past:"%s \u043c\u0443\u0440\u0443\u043d",s:"\u0431\u0438\u0440\u043d\u0435\u0447\u0435 \u0441\u0435\u043a\u0443\u043d\u0434",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434",m:"\u0431\u0438\u0440 \u043c\u04af\u043d\u04e9\u0442",mm:"%d \u043c\u04af\u043d\u04e9\u0442",h:"\u0431\u0438\u0440 \u0441\u0430\u0430\u0442",hh:"%d \u0441\u0430\u0430\u0442",d:"\u0431\u0438\u0440 \u043a\u04af\u043d",dd:"%d \u043a\u04af\u043d",M:"\u0431\u0438\u0440 \u0430\u0439",MM:"%d \u0430\u0439",y:"\u0431\u0438\u0440 \u0436\u044b\u043b",yy:"%d \u0436\u044b\u043b"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0447\u0438|\u0447\u044b|\u0447\u04af|\u0447\u0443)/,ordinal:function(e){return e+(ce[e]||ce[e%10]||ce[100<=e?100:null])},week:{dow:1,doy:7}}),e.defineLocale("lb",{months:"Januar_Februar_M\xe4erz_Abr\xebll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonndeg_M\xe9indeg_D\xebnschdeg_M\xebttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),weekdaysShort:"So._M\xe9._D\xeb._M\xeb._Do._Fr._Sa.".split("_"),weekdaysMin:"So_M\xe9_D\xeb_M\xeb_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm [Auer]",LTS:"H:mm:ss [Auer]",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm [Auer]",LLLL:"dddd, D. MMMM YYYY H:mm [Auer]"},calendar:{sameDay:"[Haut um] LT",sameElse:"L",nextDay:"[Muer um] LT",nextWeek:"dddd [um] LT",lastDay:"[G\xebschter um] LT",lastWeek:function(){switch(this.day()){case 2:case 4:return"[Leschten] dddd [um] LT";default:return"[Leschte] dddd [um] LT"}}},relativeTime:{future:function(e){return pe(e.substr(0,e.indexOf(" ")))?"a "+e:"an "+e},past:function(e){return pe(e.substr(0,e.indexOf(" ")))?"viru "+e:"virun "+e},s:"e puer Sekonnen",ss:"%d Sekonnen",m:ke,mm:"%d Minutten",h:ke,hh:"%d Stonnen",d:ke,dd:"%d Deeg",M:ke,MM:"%d M\xe9int",y:ke,yy:"%d Joer"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("lo",{months:"\u0ea1\u0eb1\u0e87\u0e81\u0ead\u0e99_\u0e81\u0eb8\u0ea1\u0e9e\u0eb2_\u0ea1\u0eb5\u0e99\u0eb2_\u0ec0\u0ea1\u0eaa\u0eb2_\u0e9e\u0eb6\u0e94\u0eaa\u0eb0\u0e9e\u0eb2_\u0ea1\u0eb4\u0e96\u0eb8\u0e99\u0eb2_\u0e81\u0ecd\u0ea5\u0eb0\u0e81\u0ebb\u0e94_\u0eaa\u0eb4\u0e87\u0eab\u0eb2_\u0e81\u0eb1\u0e99\u0e8d\u0eb2_\u0e95\u0eb8\u0ea5\u0eb2_\u0e9e\u0eb0\u0e88\u0eb4\u0e81_\u0e97\u0eb1\u0e99\u0ea7\u0eb2".split("_"),monthsShort:"\u0ea1\u0eb1\u0e87\u0e81\u0ead\u0e99_\u0e81\u0eb8\u0ea1\u0e9e\u0eb2_\u0ea1\u0eb5\u0e99\u0eb2_\u0ec0\u0ea1\u0eaa\u0eb2_\u0e9e\u0eb6\u0e94\u0eaa\u0eb0\u0e9e\u0eb2_\u0ea1\u0eb4\u0e96\u0eb8\u0e99\u0eb2_\u0e81\u0ecd\u0ea5\u0eb0\u0e81\u0ebb\u0e94_\u0eaa\u0eb4\u0e87\u0eab\u0eb2_\u0e81\u0eb1\u0e99\u0e8d\u0eb2_\u0e95\u0eb8\u0ea5\u0eb2_\u0e9e\u0eb0\u0e88\u0eb4\u0e81_\u0e97\u0eb1\u0e99\u0ea7\u0eb2".split("_"),weekdays:"\u0ead\u0eb2\u0e97\u0eb4\u0e94_\u0e88\u0eb1\u0e99_\u0ead\u0eb1\u0e87\u0e84\u0eb2\u0e99_\u0e9e\u0eb8\u0e94_\u0e9e\u0eb0\u0eab\u0eb1\u0e94_\u0eaa\u0eb8\u0e81_\u0ec0\u0eaa\u0ebb\u0eb2".split("_"),weekdaysShort:"\u0e97\u0eb4\u0e94_\u0e88\u0eb1\u0e99_\u0ead\u0eb1\u0e87\u0e84\u0eb2\u0e99_\u0e9e\u0eb8\u0e94_\u0e9e\u0eb0\u0eab\u0eb1\u0e94_\u0eaa\u0eb8\u0e81_\u0ec0\u0eaa\u0ebb\u0eb2".split("_"),weekdaysMin:"\u0e97_\u0e88_\u0ead\u0e84_\u0e9e_\u0e9e\u0eab_\u0eaa\u0e81_\u0eaa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"\u0ea7\u0eb1\u0e99dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0e95\u0ead\u0e99\u0ec0\u0e8a\u0ebb\u0ec9\u0eb2|\u0e95\u0ead\u0e99\u0ec1\u0ea5\u0e87/,isPM:function(e){return"\u0e95\u0ead\u0e99\u0ec1\u0ea5\u0e87"===e},meridiem:function(e,a,_){return e<12?"\u0e95\u0ead\u0e99\u0ec0\u0e8a\u0ebb\u0ec9\u0eb2":"\u0e95\u0ead\u0e99\u0ec1\u0ea5\u0e87"},calendar:{sameDay:"[\u0ea1\u0eb7\u0ec9\u0e99\u0eb5\u0ec9\u0ec0\u0ea7\u0ea5\u0eb2] LT",nextDay:"[\u0ea1\u0eb7\u0ec9\u0ead\u0eb7\u0ec8\u0e99\u0ec0\u0ea7\u0ea5\u0eb2] LT",nextWeek:"[\u0ea7\u0eb1\u0e99]dddd[\u0edc\u0ec9\u0eb2\u0ec0\u0ea7\u0ea5\u0eb2] LT",lastDay:"[\u0ea1\u0eb7\u0ec9\u0ea7\u0eb2\u0e99\u0e99\u0eb5\u0ec9\u0ec0\u0ea7\u0ea5\u0eb2] LT",lastWeek:"[\u0ea7\u0eb1\u0e99]dddd[\u0ec1\u0ea5\u0ec9\u0ea7\u0e99\u0eb5\u0ec9\u0ec0\u0ea7\u0ea5\u0eb2] LT",sameElse:"L"},relativeTime:{future:"\u0ead\u0eb5\u0e81 %s",past:"%s\u0e9c\u0ec8\u0eb2\u0e99\u0ea1\u0eb2",s:"\u0e9a\u0ecd\u0ec8\u0ec0\u0e97\u0ebb\u0ec8\u0eb2\u0ec3\u0e94\u0ea7\u0eb4\u0e99\u0eb2\u0e97\u0eb5",ss:"%d \u0ea7\u0eb4\u0e99\u0eb2\u0e97\u0eb5",m:"1 \u0e99\u0eb2\u0e97\u0eb5",mm:"%d \u0e99\u0eb2\u0e97\u0eb5",h:"1 \u0e8a\u0ebb\u0ec8\u0ea7\u0ec2\u0ea1\u0e87",hh:"%d \u0e8a\u0ebb\u0ec8\u0ea7\u0ec2\u0ea1\u0e87",d:"1 \u0ea1\u0eb7\u0ec9",dd:"%d \u0ea1\u0eb7\u0ec9",M:"1 \u0ec0\u0e94\u0eb7\u0ead\u0e99",MM:"%d \u0ec0\u0e94\u0eb7\u0ead\u0e99",y:"1 \u0e9b\u0eb5",yy:"%d \u0e9b\u0eb5"},dayOfMonthOrdinalParse:/(\u0e97\u0eb5\u0ec8)\d{1,2}/,ordinal:function(e){return"\u0e97\u0eb5\u0ec8"+e}});var De={ss:"sekund\u0117_sekund\u017ei\u0173_sekundes",m:"minut\u0117_minut\u0117s_minut\u0119",mm:"minut\u0117s_minu\u010di\u0173_minutes",h:"valanda_valandos_valand\u0105",hh:"valandos_valand\u0173_valandas",d:"diena_dienos_dien\u0105",dd:"dienos_dien\u0173_dienas",M:"m\u0117nuo_m\u0117nesio_m\u0117nes\u012f",MM:"m\u0117nesiai_m\u0117nesi\u0173_m\u0117nesius",y:"metai_met\u0173_metus",yy:"metai_met\u0173_metus"};function Te(e,a,_,s){return a?ge(_)[0]:s?ge(_)[1]:ge(_)[2]}function fe(e){return e%10==0||10<e&&e<20}function ge(e){return De[e].split("_")}function we(e,a,_,s){var d=e+" ";return 1===e?d+Te(0,a,_[0],s):a?d+(fe(e)?ge(_)[1]:ge(_)[0]):s?d+ge(_)[1]:d+(fe(e)?ge(_)[1]:ge(_)[2])}e.defineLocale("lt",{months:{format:"sausio_vasario_kovo_baland\u017eio_gegu\u017e\u0117s_bir\u017eelio_liepos_rugpj\u016b\u010dio_rugs\u0117jo_spalio_lapkri\u010dio_gruod\u017eio".split("_"),standalone:"sausis_vasaris_kovas_balandis_gegu\u017e\u0117_bir\u017eelis_liepa_rugpj\u016btis_rugs\u0117jis_spalis_lapkritis_gruodis".split("_"),isFormat:/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/},monthsShort:"sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),weekdays:{format:"sekmadien\u012f_pirmadien\u012f_antradien\u012f_tre\u010diadien\u012f_ketvirtadien\u012f_penktadien\u012f_\u0161e\u0161tadien\u012f".split("_"),standalone:"sekmadienis_pirmadienis_antradienis_tre\u010diadienis_ketvirtadienis_penktadienis_\u0161e\u0161tadienis".split("_"),isFormat:/dddd HH:mm/},weekdaysShort:"Sek_Pir_Ant_Tre_Ket_Pen_\u0160e\u0161".split("_"),weekdaysMin:"S_P_A_T_K_Pn_\u0160".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY [m.] MMMM D [d.]",LLL:"YYYY [m.] MMMM D [d.], HH:mm [val.]",LLLL:"YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",l:"YYYY-MM-DD",ll:"YYYY [m.] MMMM D [d.]",lll:"YYYY [m.] MMMM D [d.], HH:mm [val.]",llll:"YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"},calendar:{sameDay:"[\u0160iandien] LT",nextDay:"[Rytoj] LT",nextWeek:"dddd LT",lastDay:"[Vakar] LT",lastWeek:"[Pra\u0117jus\u012f] dddd LT",sameElse:"L"},relativeTime:{future:"po %s",past:"prie\u0161 %s",s:function(e,a,_,s){return a?"kelios sekund\u0117s":s?"keli\u0173 sekund\u017ei\u0173":"kelias sekundes"},ss:we,m:Te,mm:we,h:Te,hh:we,d:Te,dd:we,M:Te,MM:we,y:Te,yy:we},dayOfMonthOrdinalParse:/\d{1,2}-oji/,ordinal:function(e){return e+"-oji"},week:{dow:1,doy:4}});var He={ss:"sekundes_sekund\u0113m_sekunde_sekundes".split("_"),m:"min\u016btes_min\u016bt\u0113m_min\u016bte_min\u016btes".split("_"),mm:"min\u016btes_min\u016bt\u0113m_min\u016bte_min\u016btes".split("_"),h:"stundas_stund\u0101m_stunda_stundas".split("_"),hh:"stundas_stund\u0101m_stunda_stundas".split("_"),d:"dienas_dien\u0101m_diena_dienas".split("_"),dd:"dienas_dien\u0101m_diena_dienas".split("_"),M:"m\u0113ne\u0161a_m\u0113ne\u0161iem_m\u0113nesis_m\u0113ne\u0161i".split("_"),MM:"m\u0113ne\u0161a_m\u0113ne\u0161iem_m\u0113nesis_m\u0113ne\u0161i".split("_"),y:"gada_gadiem_gads_gadi".split("_"),yy:"gada_gadiem_gads_gadi".split("_")};function be(e,a,_){return _?a%10==1&&a%100!=11?e[2]:e[3]:a%10==1&&a%100!=11?e[0]:e[1]}function Se(e,a,_){return e+" "+be(He[_],e,a)}function ve(e,a,_){return be(He[_],e,a)}e.defineLocale("lv",{months:"janv\u0101ris_febru\u0101ris_marts_apr\u012blis_maijs_j\u016bnijs_j\u016blijs_augusts_septembris_oktobris_novembris_decembris".split("_"),monthsShort:"jan_feb_mar_apr_mai_j\u016bn_j\u016bl_aug_sep_okt_nov_dec".split("_"),weekdays:"sv\u0113tdiena_pirmdiena_otrdiena_tre\u0161diena_ceturtdiena_piektdiena_sestdiena".split("_"),weekdaysShort:"Sv_P_O_T_C_Pk_S".split("_"),weekdaysMin:"Sv_P_O_T_C_Pk_S".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY.",LL:"YYYY. [gada] D. MMMM",LLL:"YYYY. [gada] D. MMMM, HH:mm",LLLL:"YYYY. [gada] D. MMMM, dddd, HH:mm"},calendar:{sameDay:"[\u0160odien pulksten] LT",nextDay:"[R\u012bt pulksten] LT",nextWeek:"dddd [pulksten] LT",lastDay:"[Vakar pulksten] LT",lastWeek:"[Pag\u0101ju\u0161\u0101] dddd [pulksten] LT",sameElse:"L"},relativeTime:{future:"p\u0113c %s",past:"pirms %s",s:function(e,a){return a?"da\u017eas sekundes":"da\u017e\u0101m sekund\u0113m"},ss:Se,m:ve,mm:Se,h:ve,hh:Se,d:ve,dd:Se,M:ve,MM:Se,y:ve,yy:Se},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var je={words:{ss:["sekund","sekunda","sekundi"],m:["jedan minut","jednog minuta"],mm:["minut","minuta","minuta"],h:["jedan sat","jednog sata"],hh:["sat","sata","sati"],dd:["dan","dana","dana"],MM:["mjesec","mjeseca","mjeseci"],yy:["godina","godine","godina"]},correctGrammaticalCase:function(e,a){return 1===e?a[0]:2<=e&&e<=4?a[1]:a[2]},translate:function(e,a,_){var s=je.words[_];return 1===_.length?a?s[0]:s[1]:e+" "+je.correctGrammaticalCase(e,s)}};function xe(e,a,_,s){switch(_){case"s":return a?"\u0445\u044d\u0434\u0445\u044d\u043d \u0441\u0435\u043a\u0443\u043d\u0434":"\u0445\u044d\u0434\u0445\u044d\u043d \u0441\u0435\u043a\u0443\u043d\u0434\u044b\u043d";case"ss":return e+(a?" \u0441\u0435\u043a\u0443\u043d\u0434":" \u0441\u0435\u043a\u0443\u043d\u0434\u044b\u043d");case"m":case"mm":return e+(a?" \u043c\u0438\u043d\u0443\u0442":" \u043c\u0438\u043d\u0443\u0442\u044b\u043d");case"h":case"hh":return e+(a?" \u0446\u0430\u0433":" \u0446\u0430\u0433\u0438\u0439\u043d");case"d":case"dd":return e+(a?" \u04e9\u0434\u04e9\u0440":" \u04e9\u0434\u0440\u0438\u0439\u043d");case"M":case"MM":return e+(a?" \u0441\u0430\u0440":" \u0441\u0430\u0440\u044b\u043d");case"y":case"yy":return e+(a?" \u0436\u0438\u043b":" \u0436\u0438\u043b\u0438\u0439\u043d");default:return e}}e.defineLocale("me",{months:"januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),monthsShort:"jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedjelja_ponedjeljak_utorak_srijeda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sri._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sjutra u] LT",nextWeek:function(){switch(this.day()){case 0:return"[u] [nedjelju] [u] LT";case 3:return"[u] [srijedu] [u] LT";case 6:return"[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return"[u] dddd [u] LT"}},lastDay:"[ju\u010de u] LT",lastWeek:function(){return["[pro\u0161le] [nedjelje] [u] LT","[pro\u0161log] [ponedjeljka] [u] LT","[pro\u0161log] [utorka] [u] LT","[pro\u0161le] [srijede] [u] LT","[pro\u0161log] [\u010detvrtka] [u] LT","[pro\u0161log] [petka] [u] LT","[pro\u0161le] [subote] [u] LT"][this.day()]},sameElse:"L"},relativeTime:{future:"za %s",past:"prije %s",s:"nekoliko sekundi",ss:je.translate,m:je.translate,mm:je.translate,h:je.translate,hh:je.translate,d:"dan",dd:je.translate,M:"mjesec",MM:je.translate,y:"godinu",yy:je.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),e.defineLocale("mi",{months:"Kohi-t\u0101te_Hui-tanguru_Pout\u016b-te-rangi_Paenga-wh\u0101wh\u0101_Haratua_Pipiri_H\u014dngoingoi_Here-turi-k\u014dk\u0101_Mahuru_Whiringa-\u0101-nuku_Whiringa-\u0101-rangi_Hakihea".split("_"),monthsShort:"Kohi_Hui_Pou_Pae_Hara_Pipi_H\u014dngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"),monthsRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsStrictRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsShortRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsShortStrictRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,weekdays:"R\u0101tapu_Mane_T\u016brei_Wenerei_T\u0101ite_Paraire_H\u0101tarei".split("_"),weekdaysShort:"Ta_Ma_T\u016b_We_T\u0101i_Pa_H\u0101".split("_"),weekdaysMin:"Ta_Ma_T\u016b_We_T\u0101i_Pa_H\u0101".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [i] HH:mm",LLLL:"dddd, D MMMM YYYY [i] HH:mm"},calendar:{sameDay:"[i teie mahana, i] LT",nextDay:"[apopo i] LT",nextWeek:"dddd [i] LT",lastDay:"[inanahi i] LT",lastWeek:"dddd [whakamutunga i] LT",sameElse:"L"},relativeTime:{future:"i roto i %s",past:"%s i mua",s:"te h\u0113kona ruarua",ss:"%d h\u0113kona",m:"he meneti",mm:"%d meneti",h:"te haora",hh:"%d haora",d:"he ra",dd:"%d ra",M:"he marama",MM:"%d marama",y:"he tau",yy:"%d tau"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),e.defineLocale("mk",{months:"\u0458\u0430\u043d\u0443\u0430\u0440\u0438_\u0444\u0435\u0432\u0440\u0443\u0430\u0440\u0438_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0438\u043b_\u043c\u0430\u0458_\u0458\u0443\u043d\u0438_\u0458\u0443\u043b\u0438_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043f\u0442\u0435\u043c\u0432\u0440\u0438_\u043e\u043a\u0442\u043e\u043c\u0432\u0440\u0438_\u043d\u043e\u0435\u043c\u0432\u0440\u0438_\u0434\u0435\u043a\u0435\u043c\u0432\u0440\u0438".split("_"),monthsShort:"\u0458\u0430\u043d_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0458_\u0458\u0443\u043d_\u0458\u0443\u043b_\u0430\u0432\u0433_\u0441\u0435\u043f_\u043e\u043a\u0442_\u043d\u043e\u0435_\u0434\u0435\u043a".split("_"),weekdays:"\u043d\u0435\u0434\u0435\u043b\u0430_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0440\u0442\u043e\u043a_\u043f\u0435\u0442\u043e\u043a_\u0441\u0430\u0431\u043e\u0442\u0430".split("_"),weekdaysShort:"\u043d\u0435\u0434_\u043f\u043e\u043d_\u0432\u0442\u043e_\u0441\u0440\u0435_\u0447\u0435\u0442_\u043f\u0435\u0442_\u0441\u0430\u0431".split("_"),weekdaysMin:"\u043de_\u043fo_\u0432\u0442_\u0441\u0440_\u0447\u0435_\u043f\u0435_\u0441a".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"D.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY H:mm",LLLL:"dddd, D MMMM YYYY H:mm"},calendar:{sameDay:"[\u0414\u0435\u043d\u0435\u0441 \u0432\u043e] LT",nextDay:"[\u0423\u0442\u0440\u0435 \u0432\u043e] LT",nextWeek:"[\u0412\u043e] dddd [\u0432\u043e] LT",lastDay:"[\u0412\u0447\u0435\u0440\u0430 \u0432\u043e] LT",lastWeek:function(){switch(this.day()){case 0:case 3:case 6:return"[\u0418\u0437\u043c\u0438\u043d\u0430\u0442\u0430\u0442\u0430] dddd [\u0432\u043e] LT";case 1:case 2:case 4:case 5:return"[\u0418\u0437\u043c\u0438\u043d\u0430\u0442\u0438\u043e\u0442] dddd [\u0432\u043e] LT"}},sameElse:"L"},relativeTime:{future:"\u043f\u043e\u0441\u043b\u0435 %s",past:"\u043f\u0440\u0435\u0434 %s",s:"\u043d\u0435\u043a\u043e\u043b\u043a\u0443 \u0441\u0435\u043a\u0443\u043d\u0434\u0438",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434\u0438",m:"\u043c\u0438\u043d\u0443\u0442\u0430",mm:"%d \u043c\u0438\u043d\u0443\u0442\u0438",h:"\u0447\u0430\u0441",hh:"%d \u0447\u0430\u0441\u0430",d:"\u0434\u0435\u043d",dd:"%d \u0434\u0435\u043d\u0430",M:"\u043c\u0435\u0441\u0435\u0446",MM:"%d \u043c\u0435\u0441\u0435\u0446\u0438",y:"\u0433\u043e\u0434\u0438\u043d\u0430",yy:"%d \u0433\u043e\u0434\u0438\u043d\u0438"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0435\u0432|\u0435\u043d|\u0442\u0438|\u0432\u0438|\u0440\u0438|\u043c\u0438)/,ordinal:function(e){var a=e%10,_=e%100;return 0===e?e+"-\u0435\u0432":0===_?e+"-\u0435\u043d":10<_&&_<20?e+"-\u0442\u0438":1===a?e+"-\u0432\u0438":2===a?e+"-\u0440\u0438":7===a||8===a?e+"-\u043c\u0438":e+"-\u0442\u0438"},week:{dow:1,doy:7}}),e.defineLocale("ml",{months:"\u0d1c\u0d28\u0d41\u0d35\u0d30\u0d3f_\u0d2b\u0d46\u0d2c\u0d4d\u0d30\u0d41\u0d35\u0d30\u0d3f_\u0d2e\u0d3e\u0d7c\u0d1a\u0d4d\u0d1a\u0d4d_\u0d0f\u0d2a\u0d4d\u0d30\u0d3f\u0d7d_\u0d2e\u0d47\u0d2f\u0d4d_\u0d1c\u0d42\u0d7a_\u0d1c\u0d42\u0d32\u0d48_\u0d13\u0d17\u0d38\u0d4d\u0d31\u0d4d\u0d31\u0d4d_\u0d38\u0d46\u0d2a\u0d4d\u0d31\u0d4d\u0d31\u0d02\u0d2c\u0d7c_\u0d12\u0d15\u0d4d\u0d1f\u0d4b\u0d2c\u0d7c_\u0d28\u0d35\u0d02\u0d2c\u0d7c_\u0d21\u0d3f\u0d38\u0d02\u0d2c\u0d7c".split("_"),monthsShort:"\u0d1c\u0d28\u0d41._\u0d2b\u0d46\u0d2c\u0d4d\u0d30\u0d41._\u0d2e\u0d3e\u0d7c._\u0d0f\u0d2a\u0d4d\u0d30\u0d3f._\u0d2e\u0d47\u0d2f\u0d4d_\u0d1c\u0d42\u0d7a_\u0d1c\u0d42\u0d32\u0d48._\u0d13\u0d17._\u0d38\u0d46\u0d2a\u0d4d\u0d31\u0d4d\u0d31._\u0d12\u0d15\u0d4d\u0d1f\u0d4b._\u0d28\u0d35\u0d02._\u0d21\u0d3f\u0d38\u0d02.".split("_"),monthsParseExact:!0,weekdays:"\u0d1e\u0d3e\u0d2f\u0d31\u0d3e\u0d34\u0d4d\u0d1a_\u0d24\u0d3f\u0d19\u0d4d\u0d15\u0d33\u0d3e\u0d34\u0d4d\u0d1a_\u0d1a\u0d4a\u0d35\u0d4d\u0d35\u0d3e\u0d34\u0d4d\u0d1a_\u0d2c\u0d41\u0d27\u0d28\u0d3e\u0d34\u0d4d\u0d1a_\u0d35\u0d4d\u0d2f\u0d3e\u0d34\u0d3e\u0d34\u0d4d\u0d1a_\u0d35\u0d46\u0d33\u0d4d\u0d33\u0d3f\u0d2f\u0d3e\u0d34\u0d4d\u0d1a_\u0d36\u0d28\u0d3f\u0d2f\u0d3e\u0d34\u0d4d\u0d1a".split("_"),weekdaysShort:"\u0d1e\u0d3e\u0d2f\u0d7c_\u0d24\u0d3f\u0d19\u0d4d\u0d15\u0d7e_\u0d1a\u0d4a\u0d35\u0d4d\u0d35_\u0d2c\u0d41\u0d27\u0d7b_\u0d35\u0d4d\u0d2f\u0d3e\u0d34\u0d02_\u0d35\u0d46\u0d33\u0d4d\u0d33\u0d3f_\u0d36\u0d28\u0d3f".split("_"),weekdaysMin:"\u0d1e\u0d3e_\u0d24\u0d3f_\u0d1a\u0d4a_\u0d2c\u0d41_\u0d35\u0d4d\u0d2f\u0d3e_\u0d35\u0d46_\u0d36".split("_"),longDateFormat:{LT:"A h:mm -\u0d28\u0d41",LTS:"A h:mm:ss -\u0d28\u0d41",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm -\u0d28\u0d41",LLLL:"dddd, D MMMM YYYY, A h:mm -\u0d28\u0d41"},calendar:{sameDay:"[\u0d07\u0d28\u0d4d\u0d28\u0d4d] LT",nextDay:"[\u0d28\u0d3e\u0d33\u0d46] LT",nextWeek:"dddd, LT",lastDay:"[\u0d07\u0d28\u0d4d\u0d28\u0d32\u0d46] LT",lastWeek:"[\u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d",past:"%s \u0d2e\u0d41\u0d7b\u0d2a\u0d4d",s:"\u0d05\u0d7d\u0d2a \u0d28\u0d3f\u0d2e\u0d3f\u0d37\u0d19\u0d4d\u0d19\u0d7e",ss:"%d \u0d38\u0d46\u0d15\u0d4d\u0d15\u0d7b\u0d21\u0d4d",m:"\u0d12\u0d30\u0d41 \u0d2e\u0d3f\u0d28\u0d3f\u0d31\u0d4d\u0d31\u0d4d",mm:"%d \u0d2e\u0d3f\u0d28\u0d3f\u0d31\u0d4d\u0d31\u0d4d",h:"\u0d12\u0d30\u0d41 \u0d2e\u0d23\u0d3f\u0d15\u0d4d\u0d15\u0d42\u0d7c",hh:"%d \u0d2e\u0d23\u0d3f\u0d15\u0d4d\u0d15\u0d42\u0d7c",d:"\u0d12\u0d30\u0d41 \u0d26\u0d3f\u0d35\u0d38\u0d02",dd:"%d \u0d26\u0d3f\u0d35\u0d38\u0d02",M:"\u0d12\u0d30\u0d41 \u0d2e\u0d3e\u0d38\u0d02",MM:"%d \u0d2e\u0d3e\u0d38\u0d02",y:"\u0d12\u0d30\u0d41 \u0d35\u0d7c\u0d37\u0d02",yy:"%d \u0d35\u0d7c\u0d37\u0d02"},meridiemParse:/\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f|\u0d30\u0d3e\u0d35\u0d3f\u0d32\u0d46|\u0d09\u0d1a\u0d4d\u0d1a \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d|\u0d35\u0d48\u0d15\u0d41\u0d28\u0d4d\u0d28\u0d47\u0d30\u0d02|\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f/i,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f"===a&&4<=e||"\u0d09\u0d1a\u0d4d\u0d1a \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d"===a||"\u0d35\u0d48\u0d15\u0d41\u0d28\u0d4d\u0d28\u0d47\u0d30\u0d02"===a?e+12:e},meridiem:function(e,a,_){return e<4?"\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f":e<12?"\u0d30\u0d3e\u0d35\u0d3f\u0d32\u0d46":e<17?"\u0d09\u0d1a\u0d4d\u0d1a \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d":e<20?"\u0d35\u0d48\u0d15\u0d41\u0d28\u0d4d\u0d28\u0d47\u0d30\u0d02":"\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f"}}),e.defineLocale("mn",{months:"\u041d\u044d\u0433\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0425\u043e\u0451\u0440\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0413\u0443\u0440\u0430\u0432\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0414\u04e9\u0440\u04e9\u0432\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0422\u0430\u0432\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0417\u0443\u0440\u0433\u0430\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0414\u043e\u043b\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u041d\u0430\u0439\u043c\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0415\u0441\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0410\u0440\u0430\u0432\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0410\u0440\u0432\u0430\u043d \u043d\u044d\u0433\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0410\u0440\u0432\u0430\u043d \u0445\u043e\u0451\u0440\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440".split("_"),monthsShort:"1 \u0441\u0430\u0440_2 \u0441\u0430\u0440_3 \u0441\u0430\u0440_4 \u0441\u0430\u0440_5 \u0441\u0430\u0440_6 \u0441\u0430\u0440_7 \u0441\u0430\u0440_8 \u0441\u0430\u0440_9 \u0441\u0430\u0440_10 \u0441\u0430\u0440_11 \u0441\u0430\u0440_12 \u0441\u0430\u0440".split("_"),monthsParseExact:!0,weekdays:"\u041d\u044f\u043c_\u0414\u0430\u0432\u0430\u0430_\u041c\u044f\u0433\u043c\u0430\u0440_\u041b\u0445\u0430\u0433\u0432\u0430_\u041f\u04af\u0440\u044d\u0432_\u0411\u0430\u0430\u0441\u0430\u043d_\u0411\u044f\u043c\u0431\u0430".split("_"),weekdaysShort:"\u041d\u044f\u043c_\u0414\u0430\u0432_\u041c\u044f\u0433_\u041b\u0445\u0430_\u041f\u04af\u0440_\u0411\u0430\u0430_\u0411\u044f\u043c".split("_"),weekdaysMin:"\u041d\u044f_\u0414\u0430_\u041c\u044f_\u041b\u0445_\u041f\u04af_\u0411\u0430_\u0411\u044f".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY \u043e\u043d\u044b MMMM\u044b\u043d D",LLL:"YYYY \u043e\u043d\u044b MMMM\u044b\u043d D HH:mm",LLLL:"dddd, YYYY \u043e\u043d\u044b MMMM\u044b\u043d D HH:mm"},meridiemParse:/\u04ae\u04e8|\u04ae\u0425/i,isPM:function(e){return"\u04ae\u0425"===e},meridiem:function(e,a,_){return e<12?"\u04ae\u04e8":"\u04ae\u0425"},calendar:{sameDay:"[\u04e8\u043d\u04e9\u04e9\u0434\u04e9\u0440] LT",nextDay:"[\u041c\u0430\u0440\u0433\u0430\u0430\u0448] LT",nextWeek:"[\u0418\u0440\u044d\u0445] dddd LT",lastDay:"[\u04e8\u0447\u0438\u0433\u0434\u04e9\u0440] LT",lastWeek:"[\u04e8\u043d\u0433\u04e9\u0440\u0441\u04e9\u043d] dddd LT",sameElse:"L"},relativeTime:{future:"%s \u0434\u0430\u0440\u0430\u0430",past:"%s \u04e9\u043c\u043d\u04e9",s:xe,ss:xe,m:xe,mm:xe,h:xe,hh:xe,d:xe,dd:xe,M:xe,MM:xe,y:xe,yy:xe},dayOfMonthOrdinalParse:/\d{1,2} \u04e9\u0434\u04e9\u0440/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+" \u04e9\u0434\u04e9\u0440";default:return e}}});var Pe={1:"\u0967",2:"\u0968",3:"\u0969",4:"\u096a",5:"\u096b",6:"\u096c",7:"\u096d",8:"\u096e",9:"\u096f",0:"\u0966"},We={"\u0967":"1","\u0968":"2","\u0969":"3","\u096a":"4","\u096b":"5","\u096c":"6","\u096d":"7","\u096e":"8","\u096f":"9","\u0966":"0"};function Ae(e,a,_,s){var d="";if(a)switch(_){case"s":d="\u0915\u093e\u0939\u0940 \u0938\u0947\u0915\u0902\u0926";break;case"ss":d="%d \u0938\u0947\u0915\u0902\u0926";break;case"m":d="\u090f\u0915 \u092e\u093f\u0928\u093f\u091f";break;case"mm":d="%d \u092e\u093f\u0928\u093f\u091f\u0947";break;case"h":d="\u090f\u0915 \u0924\u093e\u0938";break;case"hh":d="%d \u0924\u093e\u0938";break;case"d":d="\u090f\u0915 \u0926\u093f\u0935\u0938";break;case"dd":d="%d \u0926\u093f\u0935\u0938";break;case"M":d="\u090f\u0915 \u092e\u0939\u093f\u0928\u093e";break;case"MM":d="%d \u092e\u0939\u093f\u0928\u0947";break;case"y":d="\u090f\u0915 \u0935\u0930\u094d\u0937";break;case"yy":d="%d \u0935\u0930\u094d\u0937\u0947";break}else switch(_){case"s":d="\u0915\u093e\u0939\u0940 \u0938\u0947\u0915\u0902\u0926\u093e\u0902";break;case"ss":d="%d \u0938\u0947\u0915\u0902\u0926\u093e\u0902";break;case"m":d="\u090f\u0915\u093e \u092e\u093f\u0928\u093f\u091f\u093e";break;case"mm":d="%d \u092e\u093f\u0928\u093f\u091f\u093e\u0902";break;case"h":d="\u090f\u0915\u093e \u0924\u093e\u0938\u093e";break;case"hh":d="%d \u0924\u093e\u0938\u093e\u0902";break;case"d":d="\u090f\u0915\u093e \u0926\u093f\u0935\u0938\u093e";break;case"dd":d="%d \u0926\u093f\u0935\u0938\u093e\u0902";break;case"M":d="\u090f\u0915\u093e \u092e\u0939\u093f\u0928\u094d\u092f\u093e";break;case"MM":d="%d \u092e\u0939\u093f\u0928\u094d\u092f\u093e\u0902";break;case"y":d="\u090f\u0915\u093e \u0935\u0930\u094d\u0937\u093e";break;case"yy":d="%d \u0935\u0930\u094d\u0937\u093e\u0902";break}return d.replace(/%d/i,e)}e.defineLocale("mr",{months:"\u091c\u093e\u0928\u0947\u0935\u093e\u0930\u0940_\u092b\u0947\u092c\u094d\u0930\u0941\u0935\u093e\u0930\u0940_\u092e\u093e\u0930\u094d\u091a_\u090f\u092a\u094d\u0930\u093f\u0932_\u092e\u0947_\u091c\u0942\u0928_\u091c\u0941\u0932\u0948_\u0911\u0917\u0938\u094d\u091f_\u0938\u092a\u094d\u091f\u0947\u0902\u092c\u0930_\u0911\u0915\u094d\u091f\u094b\u092c\u0930_\u0928\u094b\u0935\u094d\u0939\u0947\u0902\u092c\u0930_\u0921\u093f\u0938\u0947\u0902\u092c\u0930".split("_"),monthsShort:"\u091c\u093e\u0928\u0947._\u092b\u0947\u092c\u094d\u0930\u0941._\u092e\u093e\u0930\u094d\u091a._\u090f\u092a\u094d\u0930\u093f._\u092e\u0947._\u091c\u0942\u0928._\u091c\u0941\u0932\u0948._\u0911\u0917._\u0938\u092a\u094d\u091f\u0947\u0902._\u0911\u0915\u094d\u091f\u094b._\u0928\u094b\u0935\u094d\u0939\u0947\u0902._\u0921\u093f\u0938\u0947\u0902.".split("_"),monthsParseExact:!0,weekdays:"\u0930\u0935\u093f\u0935\u093e\u0930_\u0938\u094b\u092e\u0935\u093e\u0930_\u092e\u0902\u0917\u0933\u0935\u093e\u0930_\u092c\u0941\u0927\u0935\u093e\u0930_\u0917\u0941\u0930\u0942\u0935\u093e\u0930_\u0936\u0941\u0915\u094d\u0930\u0935\u093e\u0930_\u0936\u0928\u093f\u0935\u093e\u0930".split("_"),weekdaysShort:"\u0930\u0935\u093f_\u0938\u094b\u092e_\u092e\u0902\u0917\u0933_\u092c\u0941\u0927_\u0917\u0941\u0930\u0942_\u0936\u0941\u0915\u094d\u0930_\u0936\u0928\u093f".split("_"),weekdaysMin:"\u0930_\u0938\u094b_\u092e\u0902_\u092c\u0941_\u0917\u0941_\u0936\u0941_\u0936".split("_"),longDateFormat:{LT:"A h:mm \u0935\u093e\u091c\u0924\u093e",LTS:"A h:mm:ss \u0935\u093e\u091c\u0924\u093e",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u0935\u093e\u091c\u0924\u093e",LLLL:"dddd, D MMMM YYYY, A h:mm \u0935\u093e\u091c\u0924\u093e"},calendar:{sameDay:"[\u0906\u091c] LT",nextDay:"[\u0909\u0926\u094d\u092f\u093e] LT",nextWeek:"dddd, LT",lastDay:"[\u0915\u093e\u0932] LT",lastWeek:"[\u092e\u093e\u0917\u0940\u0932] dddd, LT",sameElse:"L"},relativeTime:{future:"%s\u092e\u0927\u094d\u092f\u0947",past:"%s\u092a\u0942\u0930\u094d\u0935\u0940",s:Ae,ss:Ae,m:Ae,mm:Ae,h:Ae,hh:Ae,d:Ae,dd:Ae,M:Ae,MM:Ae,y:Ae,yy:Ae},preparse:function(e){return e.replace(/[\u0967\u0968\u0969\u096a\u096b\u096c\u096d\u096e\u096f\u0966]/g,function(e){return We[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Pe[e]})},meridiemParse:/\u0930\u093e\u0924\u094d\u0930\u0940|\u0938\u0915\u093e\u0933\u0940|\u0926\u0941\u092a\u093e\u0930\u0940|\u0938\u093e\u092f\u0902\u0915\u093e\u0933\u0940/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0930\u093e\u0924\u094d\u0930\u0940"===a?e<4?e:e+12:"\u0938\u0915\u093e\u0933\u0940"===a?e:"\u0926\u0941\u092a\u093e\u0930\u0940"===a?10<=e?e:e+12:"\u0938\u093e\u092f\u0902\u0915\u093e\u0933\u0940"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0930\u093e\u0924\u094d\u0930\u0940":e<10?"\u0938\u0915\u093e\u0933\u0940":e<17?"\u0926\u0941\u092a\u093e\u0930\u0940":e<20?"\u0938\u093e\u092f\u0902\u0915\u093e\u0933\u0940":"\u0930\u093e\u0924\u094d\u0930\u0940"},week:{dow:0,doy:6}}),e.defineLocale("ms-my",{months:"Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),monthsShort:"Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),weekdays:"Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),weekdaysShort:"Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),weekdaysMin:"Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/pagi|tengahari|petang|malam/,meridiemHour:function(e,a){return 12===e&&(e=0),"pagi"===a?e:"tengahari"===a?11<=e?e:e+12:"petang"===a||"malam"===a?e+12:void 0},meridiem:function(e,a,_){return e<11?"pagi":e<15?"tengahari":e<19?"petang":"malam"},calendar:{sameDay:"[Hari ini pukul] LT",nextDay:"[Esok pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kelmarin pukul] LT",lastWeek:"dddd [lepas pukul] LT",sameElse:"L"},relativeTime:{future:"dalam %s",past:"%s yang lepas",s:"beberapa saat",ss:"%d saat",m:"seminit",mm:"%d minit",h:"sejam",hh:"%d jam",d:"sehari",dd:"%d hari",M:"sebulan",MM:"%d bulan",y:"setahun",yy:"%d tahun"},week:{dow:1,doy:7}}),e.defineLocale("ms",{months:"Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),monthsShort:"Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),weekdays:"Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),weekdaysShort:"Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),weekdaysMin:"Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/pagi|tengahari|petang|malam/,meridiemHour:function(e,a){return 12===e&&(e=0),"pagi"===a?e:"tengahari"===a?11<=e?e:e+12:"petang"===a||"malam"===a?e+12:void 0},meridiem:function(e,a,_){return e<11?"pagi":e<15?"tengahari":e<19?"petang":"malam"},calendar:{sameDay:"[Hari ini pukul] LT",nextDay:"[Esok pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kelmarin pukul] LT",lastWeek:"dddd [lepas pukul] LT",sameElse:"L"},relativeTime:{future:"dalam %s",past:"%s yang lepas",s:"beberapa saat",ss:"%d saat",m:"seminit",mm:"%d minit",h:"sejam",hh:"%d jam",d:"sehari",dd:"%d hari",M:"sebulan",MM:"%d bulan",y:"setahun",yy:"%d tahun"},week:{dow:1,doy:7}}),e.defineLocale("mt",{months:"Jannar_Frar_Marzu_April_Mejju_\u0120unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Di\u010bembru".split("_"),monthsShort:"Jan_Fra_Mar_Apr_Mej_\u0120un_Lul_Aww_Set_Ott_Nov_Di\u010b".split("_"),weekdays:"Il-\u0126add_It-Tnejn_It-Tlieta_L-Erbg\u0127a_Il-\u0126amis_Il-\u0120img\u0127a_Is-Sibt".split("_"),weekdaysShort:"\u0126ad_Tne_Tli_Erb_\u0126am_\u0120im_Sib".split("_"),weekdaysMin:"\u0126a_Tn_Tl_Er_\u0126a_\u0120i_Si".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Illum fil-]LT",nextDay:"[G\u0127ada fil-]LT",nextWeek:"dddd [fil-]LT",lastDay:"[Il-biera\u0127 fil-]LT",lastWeek:"dddd [li g\u0127adda] [fil-]LT",sameElse:"L"},relativeTime:{future:"f\u2019 %s",past:"%s ilu",s:"ftit sekondi",ss:"%d sekondi",m:"minuta",mm:"%d minuti",h:"sieg\u0127a",hh:"%d sieg\u0127at",d:"\u0121urnata",dd:"%d \u0121ranet",M:"xahar",MM:"%d xhur",y:"sena",yy:"%d sni"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}});var Oe={1:"\u1041",2:"\u1042",3:"\u1043",4:"\u1044",5:"\u1045",6:"\u1046",7:"\u1047",8:"\u1048",9:"\u1049",0:"\u1040"},Ee={"\u1041":"1","\u1042":"2","\u1043":"3","\u1044":"4","\u1045":"5","\u1046":"6","\u1047":"7","\u1048":"8","\u1049":"9","\u1040":"0"};e.defineLocale("my",{months:"\u1007\u1014\u103a\u1014\u101d\u102b\u101b\u102e_\u1016\u1031\u1016\u1031\u102c\u103a\u101d\u102b\u101b\u102e_\u1019\u1010\u103a_\u1027\u1015\u103c\u102e_\u1019\u1031_\u1007\u103d\u1014\u103a_\u1007\u1030\u101c\u102d\u102f\u1004\u103a_\u101e\u103c\u1002\u102f\u1010\u103a_\u1005\u1000\u103a\u1010\u1004\u103a\u1018\u102c_\u1021\u1031\u102c\u1000\u103a\u1010\u102d\u102f\u1018\u102c_\u1014\u102d\u102f\u101d\u1004\u103a\u1018\u102c_\u1012\u102e\u1007\u1004\u103a\u1018\u102c".split("_"),monthsShort:"\u1007\u1014\u103a_\u1016\u1031_\u1019\u1010\u103a_\u1015\u103c\u102e_\u1019\u1031_\u1007\u103d\u1014\u103a_\u101c\u102d\u102f\u1004\u103a_\u101e\u103c_\u1005\u1000\u103a_\u1021\u1031\u102c\u1000\u103a_\u1014\u102d\u102f_\u1012\u102e".split("_"),weekdays:"\u1010\u1014\u1004\u103a\u1039\u1002\u1014\u103d\u1031_\u1010\u1014\u1004\u103a\u1039\u101c\u102c_\u1021\u1004\u103a\u1039\u1002\u102b_\u1017\u102f\u1012\u1039\u1013\u101f\u1030\u1038_\u1000\u103c\u102c\u101e\u1015\u1010\u1031\u1038_\u101e\u1031\u102c\u1000\u103c\u102c_\u1005\u1014\u1031".split("_"),weekdaysShort:"\u1014\u103d\u1031_\u101c\u102c_\u1002\u102b_\u101f\u1030\u1038_\u1000\u103c\u102c_\u101e\u1031\u102c_\u1014\u1031".split("_"),weekdaysMin:"\u1014\u103d\u1031_\u101c\u102c_\u1002\u102b_\u101f\u1030\u1038_\u1000\u103c\u102c_\u101e\u1031\u102c_\u1014\u1031".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u101a\u1014\u1031.] LT [\u1019\u103e\u102c]",nextDay:"[\u1019\u1014\u1000\u103a\u1016\u103c\u1014\u103a] LT [\u1019\u103e\u102c]",nextWeek:"dddd LT [\u1019\u103e\u102c]",lastDay:"[\u1019\u1014\u1031.\u1000] LT [\u1019\u103e\u102c]",lastWeek:"[\u1015\u103c\u102e\u1038\u1001\u1032\u1037\u101e\u1031\u102c] dddd LT [\u1019\u103e\u102c]",sameElse:"L"},relativeTime:{future:"\u101c\u102c\u1019\u100a\u103a\u1037 %s \u1019\u103e\u102c",past:"\u101c\u103d\u1014\u103a\u1001\u1032\u1037\u101e\u1031\u102c %s \u1000",s:"\u1005\u1000\u1039\u1000\u1014\u103a.\u1021\u1014\u100a\u103a\u1038\u1004\u101a\u103a",ss:"%d \u1005\u1000\u1039\u1000\u1014\u1037\u103a",m:"\u1010\u1005\u103a\u1019\u102d\u1014\u1005\u103a",mm:"%d \u1019\u102d\u1014\u1005\u103a",h:"\u1010\u1005\u103a\u1014\u102c\u101b\u102e",hh:"%d \u1014\u102c\u101b\u102e",d:"\u1010\u1005\u103a\u101b\u1000\u103a",dd:"%d \u101b\u1000\u103a",M:"\u1010\u1005\u103a\u101c",MM:"%d \u101c",y:"\u1010\u1005\u103a\u1014\u103e\u1005\u103a",yy:"%d \u1014\u103e\u1005\u103a"},preparse:function(e){return e.replace(/[\u1041\u1042\u1043\u1044\u1045\u1046\u1047\u1048\u1049\u1040]/g,function(e){return Ee[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Oe[e]})},week:{dow:1,doy:4}}),e.defineLocale("nb",{months:"januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),monthsShort:"jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.".split("_"),monthsParseExact:!0,weekdays:"s\xf8ndag_mandag_tirsdag_onsdag_torsdag_fredag_l\xf8rdag".split("_"),weekdaysShort:"s\xf8._ma._ti._on._to._fr._l\xf8.".split("_"),weekdaysMin:"s\xf8_ma_ti_on_to_fr_l\xf8".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY [kl.] HH:mm",LLLL:"dddd D. MMMM YYYY [kl.] HH:mm"},calendar:{sameDay:"[i dag kl.] LT",nextDay:"[i morgen kl.] LT",nextWeek:"dddd [kl.] LT",lastDay:"[i g\xe5r kl.] LT",lastWeek:"[forrige] dddd [kl.] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"%s siden",s:"noen sekunder",ss:"%d sekunder",m:"ett minutt",mm:"%d minutter",h:"en time",hh:"%d timer",d:"en dag",dd:"%d dager",M:"en m\xe5ned",MM:"%d m\xe5neder",y:"ett \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var Fe={1:"\u0967",2:"\u0968",3:"\u0969",4:"\u096a",5:"\u096b",6:"\u096c",7:"\u096d",8:"\u096e",9:"\u096f",0:"\u0966"},ze={"\u0967":"1","\u0968":"2","\u0969":"3","\u096a":"4","\u096b":"5","\u096c":"6","\u096d":"7","\u096e":"8","\u096f":"9","\u0966":"0"};e.defineLocale("ne",{months:"\u091c\u0928\u0935\u0930\u0940_\u092b\u0947\u092c\u094d\u0930\u0941\u0935\u0930\u0940_\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u093f\u0932_\u092e\u0908_\u091c\u0941\u0928_\u091c\u0941\u0932\u093e\u0908_\u0905\u0917\u0937\u094d\u091f_\u0938\u0947\u092a\u094d\u091f\u0947\u092e\u094d\u092c\u0930_\u0905\u0915\u094d\u091f\u094b\u092c\u0930_\u0928\u094b\u092d\u0947\u092e\u094d\u092c\u0930_\u0921\u093f\u0938\u0947\u092e\u094d\u092c\u0930".split("_"),monthsShort:"\u091c\u0928._\u092b\u0947\u092c\u094d\u0930\u0941._\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u093f._\u092e\u0908_\u091c\u0941\u0928_\u091c\u0941\u0932\u093e\u0908._\u0905\u0917._\u0938\u0947\u092a\u094d\u091f._\u0905\u0915\u094d\u091f\u094b._\u0928\u094b\u092d\u0947._\u0921\u093f\u0938\u0947.".split("_"),monthsParseExact:!0,weekdays:"\u0906\u0907\u0924\u092c\u093e\u0930_\u0938\u094b\u092e\u092c\u093e\u0930_\u092e\u0919\u094d\u0917\u0932\u092c\u093e\u0930_\u092c\u0941\u0927\u092c\u093e\u0930_\u092c\u093f\u0939\u093f\u092c\u093e\u0930_\u0936\u0941\u0915\u094d\u0930\u092c\u093e\u0930_\u0936\u0928\u093f\u092c\u093e\u0930".split("_"),weekdaysShort:"\u0906\u0907\u0924._\u0938\u094b\u092e._\u092e\u0919\u094d\u0917\u0932._\u092c\u0941\u0927._\u092c\u093f\u0939\u093f._\u0936\u0941\u0915\u094d\u0930._\u0936\u0928\u093f.".split("_"),weekdaysMin:"\u0906._\u0938\u094b._\u092e\u0902._\u092c\u0941._\u092c\u093f._\u0936\u0941._\u0936.".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"A\u0915\u094b h:mm \u092c\u091c\u0947",LTS:"A\u0915\u094b h:mm:ss \u092c\u091c\u0947",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A\u0915\u094b h:mm \u092c\u091c\u0947",LLLL:"dddd, D MMMM YYYY, A\u0915\u094b h:mm \u092c\u091c\u0947"},preparse:function(e){return e.replace(/[\u0967\u0968\u0969\u096a\u096b\u096c\u096d\u096e\u096f\u0966]/g,function(e){return ze[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Fe[e]})},meridiemParse:/\u0930\u093e\u0924\u093f|\u092c\u093f\u0939\u093e\u0928|\u0926\u093f\u0909\u0901\u0938\u094b|\u0938\u093e\u0901\u091d/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0930\u093e\u0924\u093f"===a?e<4?e:e+12:"\u092c\u093f\u0939\u093e\u0928"===a?e:"\u0926\u093f\u0909\u0901\u0938\u094b"===a?10<=e?e:e+12:"\u0938\u093e\u0901\u091d"===a?e+12:void 0},meridiem:function(e,a,_){return e<3?"\u0930\u093e\u0924\u093f":e<12?"\u092c\u093f\u0939\u093e\u0928":e<16?"\u0926\u093f\u0909\u0901\u0938\u094b":e<20?"\u0938\u093e\u0901\u091d":"\u0930\u093e\u0924\u093f"},calendar:{sameDay:"[\u0906\u091c] LT",nextDay:"[\u092d\u094b\u0932\u093f] LT",nextWeek:"[\u0906\u0909\u0901\u0926\u094b] dddd[,] LT",lastDay:"[\u0939\u093f\u091c\u094b] LT",lastWeek:"[\u0917\u090f\u0915\u094b] dddd[,] LT",sameElse:"L"},relativeTime:{future:"%s\u092e\u093e",past:"%s \u0905\u0917\u093e\u0921\u093f",s:"\u0915\u0947\u0939\u0940 \u0915\u094d\u0937\u0923",ss:"%d \u0938\u0947\u0915\u0947\u0923\u094d\u0921",m:"\u090f\u0915 \u092e\u093f\u0928\u0947\u091f",mm:"%d \u092e\u093f\u0928\u0947\u091f",h:"\u090f\u0915 \u0918\u0923\u094d\u091f\u093e",hh:"%d \u0918\u0923\u094d\u091f\u093e",d:"\u090f\u0915 \u0926\u093f\u0928",dd:"%d \u0926\u093f\u0928",M:"\u090f\u0915 \u092e\u0939\u093f\u0928\u093e",MM:"%d \u092e\u0939\u093f\u0928\u093e",y:"\u090f\u0915 \u092c\u0930\u094d\u0937",yy:"%d \u092c\u0930\u094d\u0937"},week:{dow:0,doy:6}});var Je="jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"),Ie="jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),Ne=[/^jan/i,/^feb/i,/^maart|mrt.?$/i,/^apr/i,/^mei$/i,/^jun[i.]?$/i,/^jul[i.]?$/i,/^aug/i,/^sep/i,/^okt/i,/^nov/i,/^dec/i],Re=/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;e.defineLocale("nl-be",{months:"januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?Ie[e.month()]:Je[e.month()]:Je},monthsRegex:Re,monthsShortRegex:Re,monthsStrictRegex:/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,monthsShortStrictRegex:/^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,monthsParse:Ne,longMonthsParse:Ne,shortMonthsParse:Ne,weekdays:"zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),weekdaysShort:"zo._ma._di._wo._do._vr._za.".split("_"),weekdaysMin:"zo_ma_di_wo_do_vr_za".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[vandaag om] LT",nextDay:"[morgen om] LT",nextWeek:"dddd [om] LT",lastDay:"[gisteren om] LT",lastWeek:"[afgelopen] dddd [om] LT",sameElse:"L"},relativeTime:{future:"over %s",past:"%s geleden",s:"een paar seconden",ss:"%d seconden",m:"\xe9\xe9n minuut",mm:"%d minuten",h:"\xe9\xe9n uur",hh:"%d uur",d:"\xe9\xe9n dag",dd:"%d dagen",M:"\xe9\xe9n maand",MM:"%d maanden",y:"\xe9\xe9n jaar",yy:"%d jaar"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}});var Ke="jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"),Ce="jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),Ge=[/^jan/i,/^feb/i,/^maart|mrt.?$/i,/^apr/i,/^mei$/i,/^jun[i.]?$/i,/^jul[i.]?$/i,/^aug/i,/^sep/i,/^okt/i,/^nov/i,/^dec/i],Be=/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;e.defineLocale("nl",{months:"januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?Ce[e.month()]:Ke[e.month()]:Ke},monthsRegex:Be,monthsShortRegex:Be,monthsStrictRegex:/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,monthsShortStrictRegex:/^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,monthsParse:Ge,longMonthsParse:Ge,shortMonthsParse:Ge,weekdays:"zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),weekdaysShort:"zo._ma._di._wo._do._vr._za.".split("_"),weekdaysMin:"zo_ma_di_wo_do_vr_za".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[vandaag om] LT",nextDay:"[morgen om] LT",nextWeek:"dddd [om] LT",lastDay:"[gisteren om] LT",lastWeek:"[afgelopen] dddd [om] LT",sameElse:"L"},relativeTime:{future:"over %s",past:"%s geleden",s:"een paar seconden",ss:"%d seconden",m:"\xe9\xe9n minuut",mm:"%d minuten",h:"\xe9\xe9n uur",hh:"%d uur",d:"\xe9\xe9n dag",dd:"%d dagen",M:"\xe9\xe9n maand",MM:"%d maanden",y:"\xe9\xe9n jaar",yy:"%d jaar"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}}),e.defineLocale("nn",{months:"januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),monthsShort:"jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),weekdays:"sundag_m\xe5ndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),weekdaysShort:"sun_m\xe5n_tys_ons_tor_fre_lau".split("_"),weekdaysMin:"su_m\xe5_ty_on_to_fr_l\xf8".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY [kl.] H:mm",LLLL:"dddd D. MMMM YYYY [kl.] HH:mm"},calendar:{sameDay:"[I dag klokka] LT",nextDay:"[I morgon klokka] LT",nextWeek:"dddd [klokka] LT",lastDay:"[I g\xe5r klokka] LT",lastWeek:"[F\xf8reg\xe5ande] dddd [klokka] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"%s sidan",s:"nokre sekund",ss:"%d sekund",m:"eit minutt",mm:"%d minutt",h:"ein time",hh:"%d timar",d:"ein dag",dd:"%d dagar",M:"ein m\xe5nad",MM:"%d m\xe5nader",y:"eit \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var qe={1:"\u0a67",2:"\u0a68",3:"\u0a69",4:"\u0a6a",5:"\u0a6b",6:"\u0a6c",7:"\u0a6d",8:"\u0a6e",9:"\u0a6f",0:"\u0a66"},Ue={"\u0a67":"1","\u0a68":"2","\u0a69":"3","\u0a6a":"4","\u0a6b":"5","\u0a6c":"6","\u0a6d":"7","\u0a6e":"8","\u0a6f":"9","\u0a66":"0"};e.defineLocale("pa-in",{months:"\u0a1c\u0a28\u0a35\u0a30\u0a40_\u0a2b\u0a3c\u0a30\u0a35\u0a30\u0a40_\u0a2e\u0a3e\u0a30\u0a1a_\u0a05\u0a2a\u0a4d\u0a30\u0a48\u0a32_\u0a2e\u0a08_\u0a1c\u0a42\u0a28_\u0a1c\u0a41\u0a32\u0a3e\u0a08_\u0a05\u0a17\u0a38\u0a24_\u0a38\u0a24\u0a70\u0a2c\u0a30_\u0a05\u0a15\u0a24\u0a42\u0a2c\u0a30_\u0a28\u0a35\u0a70\u0a2c\u0a30_\u0a26\u0a38\u0a70\u0a2c\u0a30".split("_"),monthsShort:"\u0a1c\u0a28\u0a35\u0a30\u0a40_\u0a2b\u0a3c\u0a30\u0a35\u0a30\u0a40_\u0a2e\u0a3e\u0a30\u0a1a_\u0a05\u0a2a\u0a4d\u0a30\u0a48\u0a32_\u0a2e\u0a08_\u0a1c\u0a42\u0a28_\u0a1c\u0a41\u0a32\u0a3e\u0a08_\u0a05\u0a17\u0a38\u0a24_\u0a38\u0a24\u0a70\u0a2c\u0a30_\u0a05\u0a15\u0a24\u0a42\u0a2c\u0a30_\u0a28\u0a35\u0a70\u0a2c\u0a30_\u0a26\u0a38\u0a70\u0a2c\u0a30".split("_"),weekdays:"\u0a10\u0a24\u0a35\u0a3e\u0a30_\u0a38\u0a4b\u0a2e\u0a35\u0a3e\u0a30_\u0a2e\u0a70\u0a17\u0a32\u0a35\u0a3e\u0a30_\u0a2c\u0a41\u0a27\u0a35\u0a3e\u0a30_\u0a35\u0a40\u0a30\u0a35\u0a3e\u0a30_\u0a38\u0a3c\u0a41\u0a71\u0a15\u0a30\u0a35\u0a3e\u0a30_\u0a38\u0a3c\u0a28\u0a40\u0a1a\u0a30\u0a35\u0a3e\u0a30".split("_"),weekdaysShort:"\u0a10\u0a24_\u0a38\u0a4b\u0a2e_\u0a2e\u0a70\u0a17\u0a32_\u0a2c\u0a41\u0a27_\u0a35\u0a40\u0a30_\u0a38\u0a3c\u0a41\u0a15\u0a30_\u0a38\u0a3c\u0a28\u0a40".split("_"),weekdaysMin:"\u0a10\u0a24_\u0a38\u0a4b\u0a2e_\u0a2e\u0a70\u0a17\u0a32_\u0a2c\u0a41\u0a27_\u0a35\u0a40\u0a30_\u0a38\u0a3c\u0a41\u0a15\u0a30_\u0a38\u0a3c\u0a28\u0a40".split("_"),longDateFormat:{LT:"A h:mm \u0a35\u0a1c\u0a47",LTS:"A h:mm:ss \u0a35\u0a1c\u0a47",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u0a35\u0a1c\u0a47",LLLL:"dddd, D MMMM YYYY, A h:mm \u0a35\u0a1c\u0a47"},calendar:{sameDay:"[\u0a05\u0a1c] LT",nextDay:"[\u0a15\u0a32] LT",nextWeek:"[\u0a05\u0a17\u0a32\u0a3e] dddd, LT",lastDay:"[\u0a15\u0a32] LT",lastWeek:"[\u0a2a\u0a3f\u0a1b\u0a32\u0a47] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0a35\u0a3f\u0a71\u0a1a",past:"%s \u0a2a\u0a3f\u0a1b\u0a32\u0a47",s:"\u0a15\u0a41\u0a1d \u0a38\u0a15\u0a3f\u0a70\u0a1f",ss:"%d \u0a38\u0a15\u0a3f\u0a70\u0a1f",m:"\u0a07\u0a15 \u0a2e\u0a3f\u0a70\u0a1f",mm:"%d \u0a2e\u0a3f\u0a70\u0a1f",h:"\u0a07\u0a71\u0a15 \u0a18\u0a70\u0a1f\u0a3e",hh:"%d \u0a18\u0a70\u0a1f\u0a47",d:"\u0a07\u0a71\u0a15 \u0a26\u0a3f\u0a28",dd:"%d \u0a26\u0a3f\u0a28",M:"\u0a07\u0a71\u0a15 \u0a2e\u0a39\u0a40\u0a28\u0a3e",MM:"%d \u0a2e\u0a39\u0a40\u0a28\u0a47",y:"\u0a07\u0a71\u0a15 \u0a38\u0a3e\u0a32",yy:"%d \u0a38\u0a3e\u0a32"},preparse:function(e){return e.replace(/[\u0a67\u0a68\u0a69\u0a6a\u0a6b\u0a6c\u0a6d\u0a6e\u0a6f\u0a66]/g,function(e){return Ue[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return qe[e]})},meridiemParse:/\u0a30\u0a3e\u0a24|\u0a38\u0a35\u0a47\u0a30|\u0a26\u0a41\u0a2a\u0a39\u0a3f\u0a30|\u0a38\u0a3c\u0a3e\u0a2e/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0a30\u0a3e\u0a24"===a?e<4?e:e+12:"\u0a38\u0a35\u0a47\u0a30"===a?e:"\u0a26\u0a41\u0a2a\u0a39\u0a3f\u0a30"===a?10<=e?e:e+12:"\u0a38\u0a3c\u0a3e\u0a2e"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0a30\u0a3e\u0a24":e<10?"\u0a38\u0a35\u0a47\u0a30":e<17?"\u0a26\u0a41\u0a2a\u0a39\u0a3f\u0a30":e<20?"\u0a38\u0a3c\u0a3e\u0a2e":"\u0a30\u0a3e\u0a24"},week:{dow:0,doy:6}});var $e="stycze\u0144_luty_marzec_kwiecie\u0144_maj_czerwiec_lipiec_sierpie\u0144_wrzesie\u0144_pa\u017adziernik_listopad_grudzie\u0144".split("_"),Qe="stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrze\u015bnia_pa\u017adziernika_listopada_grudnia".split("_");function Ve(e){return e%10<5&&1<e%10&&~~(e/10)%10!=1}function Ze(e,a,_){var s=e+" ";switch(_){case"ss":return s+(Ve(e)?"sekundy":"sekund");case"m":return a?"minuta":"minut\u0119";case"mm":return s+(Ve(e)?"minuty":"minut");case"h":return a?"godzina":"godzin\u0119";case"hh":return s+(Ve(e)?"godziny":"godzin");case"MM":return s+(Ve(e)?"miesi\u0105ce":"miesi\u0119cy");case"yy":return s+(Ve(e)?"lata":"lat")}}function Xe(e,a,_){var s=" ";return(20<=e%100||100<=e&&e%100==0)&&(s=" de "),e+s+{ss:"secunde",mm:"minute",hh:"ore",dd:"zile",MM:"luni",yy:"ani"}[_]}function ea(e,a,_){var s,d;return"m"===_?a?"\u043c\u0438\u043d\u0443\u0442\u0430":"\u043c\u0438\u043d\u0443\u0442\u0443":e+" "+(s=+e,d={ss:a?"\u0441\u0435\u043a\u0443\u043d\u0434\u0430_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434":"\u0441\u0435\u043a\u0443\u043d\u0434\u0443_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434",mm:a?"\u043c\u0438\u043d\u0443\u0442\u0430_\u043c\u0438\u043d\u0443\u0442\u044b_\u043c\u0438\u043d\u0443\u0442":"\u043c\u0438\u043d\u0443\u0442\u0443_\u043c\u0438\u043d\u0443\u0442\u044b_\u043c\u0438\u043d\u0443\u0442",hh:"\u0447\u0430\u0441_\u0447\u0430\u0441\u0430_\u0447\u0430\u0441\u043e\u0432",dd:"\u0434\u0435\u043d\u044c_\u0434\u043d\u044f_\u0434\u043d\u0435\u0439",MM:"\u043c\u0435\u0441\u044f\u0446_\u043c\u0435\u0441\u044f\u0446\u0430_\u043c\u0435\u0441\u044f\u0446\u0435\u0432",yy:"\u0433\u043e\u0434_\u0433\u043e\u0434\u0430_\u043b\u0435\u0442"}[_].split("_"),s%10==1&&s%100!=11?d[0]:2<=s%10&&s%10<=4&&(s%100<10||20<=s%100)?d[1]:d[2])}e.defineLocale("pl",{months:function(e,a){return e?""===a?"("+Qe[e.month()]+"|"+$e[e.month()]+")":/D MMMM/.test(a)?Qe[e.month()]:$e[e.month()]:$e},monthsShort:"sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa\u017a_lis_gru".split("_"),weekdays:"niedziela_poniedzia\u0142ek_wtorek_\u015broda_czwartek_pi\u0105tek_sobota".split("_"),weekdaysShort:"ndz_pon_wt_\u015br_czw_pt_sob".split("_"),weekdaysMin:"Nd_Pn_Wt_\u015ar_Cz_Pt_So".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Dzi\u015b o] LT",nextDay:"[Jutro o] LT",nextWeek:function(){switch(this.day()){case 0:return"[W niedziel\u0119 o] LT";case 2:return"[We wtorek o] LT";case 3:return"[W \u015brod\u0119 o] LT";case 6:return"[W sobot\u0119 o] LT";default:return"[W] dddd [o] LT"}},lastDay:"[Wczoraj o] LT",lastWeek:function(){switch(this.day()){case 0:return"[W zesz\u0142\u0105 niedziel\u0119 o] LT";case 3:return"[W zesz\u0142\u0105 \u015brod\u0119 o] LT";case 6:return"[W zesz\u0142\u0105 sobot\u0119 o] LT";default:return"[W zesz\u0142y] dddd [o] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"%s temu",s:"kilka sekund",ss:Ze,m:Ze,mm:Ze,h:Ze,hh:Ze,d:"1 dzie\u0144",dd:"%d dni",M:"miesi\u0105c",MM:Ze,y:"rok",yy:Ze},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("pt-br",{months:"Janeiro_Fevereiro_Mar\xe7o_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),monthsShort:"Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),weekdays:"Domingo_Segunda-feira_Ter\xe7a-feira_Quarta-feira_Quinta-feira_Sexta-feira_S\xe1bado".split("_"),weekdaysShort:"Dom_Seg_Ter_Qua_Qui_Sex_S\xe1b".split("_"),weekdaysMin:"Do_2\xaa_3\xaa_4\xaa_5\xaa_6\xaa_S\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY [\xe0s] HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY [\xe0s] HH:mm"},calendar:{sameDay:"[Hoje \xe0s] LT",nextDay:"[Amanh\xe3 \xe0s] LT",nextWeek:"dddd [\xe0s] LT",lastDay:"[Ontem \xe0s] LT",lastWeek:function(){return 0===this.day()||6===this.day()?"[\xdaltimo] dddd [\xe0s] LT":"[\xdaltima] dddd [\xe0s] LT"},sameElse:"L"},relativeTime:{future:"em %s",past:"h\xe1 %s",s:"poucos segundos",ss:"%d segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um m\xeas",MM:"%d meses",y:"um ano",yy:"%d anos"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba"}),e.defineLocale("pt",{months:"Janeiro_Fevereiro_Mar\xe7o_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),monthsShort:"Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),weekdays:"Domingo_Segunda-feira_Ter\xe7a-feira_Quarta-feira_Quinta-feira_Sexta-feira_S\xe1bado".split("_"),weekdaysShort:"Dom_Seg_Ter_Qua_Qui_Sex_S\xe1b".split("_"),weekdaysMin:"Do_2\xaa_3\xaa_4\xaa_5\xaa_6\xaa_S\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY HH:mm"},calendar:{sameDay:"[Hoje \xe0s] LT",nextDay:"[Amanh\xe3 \xe0s] LT",nextWeek:"dddd [\xe0s] LT",lastDay:"[Ontem \xe0s] LT",lastWeek:function(){return 0===this.day()||6===this.day()?"[\xdaltimo] dddd [\xe0s] LT":"[\xdaltima] dddd [\xe0s] LT"},sameElse:"L"},relativeTime:{future:"em %s",past:"h\xe1 %s",s:"segundos",ss:"%d segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um m\xeas",MM:"%d meses",y:"um ano",yy:"%d anos"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),e.defineLocale("ro",{months:"ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),monthsShort:"ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"duminic\u0103_luni_mar\u021bi_miercuri_joi_vineri_s\xe2mb\u0103t\u0103".split("_"),weekdaysShort:"Dum_Lun_Mar_Mie_Joi_Vin_S\xe2m".split("_"),weekdaysMin:"Du_Lu_Ma_Mi_Jo_Vi_S\xe2".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY H:mm",LLLL:"dddd, D MMMM YYYY H:mm"},calendar:{sameDay:"[azi la] LT",nextDay:"[m\xe2ine la] LT",nextWeek:"dddd [la] LT",lastDay:"[ieri la] LT",lastWeek:"[fosta] dddd [la] LT",sameElse:"L"},relativeTime:{future:"peste %s",past:"%s \xeen urm\u0103",s:"c\xe2teva secunde",ss:Xe,m:"un minut",mm:Xe,h:"o or\u0103",hh:Xe,d:"o zi",dd:Xe,M:"o lun\u0103",MM:Xe,y:"un an",yy:Xe},week:{dow:1,doy:7}});var aa=[/^\u044f\u043d\u0432/i,/^\u0444\u0435\u0432/i,/^\u043c\u0430\u0440/i,/^\u0430\u043f\u0440/i,/^\u043c\u0430[\u0439\u044f]/i,/^\u0438\u044e\u043d/i,/^\u0438\u044e\u043b/i,/^\u0430\u0432\u0433/i,/^\u0441\u0435\u043d/i,/^\u043e\u043a\u0442/i,/^\u043d\u043e\u044f/i,/^\u0434\u0435\u043a/i];e.defineLocale("ru",{months:{format:"\u044f\u043d\u0432\u0430\u0440\u044f_\u0444\u0435\u0432\u0440\u0430\u043b\u044f_\u043c\u0430\u0440\u0442\u0430_\u0430\u043f\u0440\u0435\u043b\u044f_\u043c\u0430\u044f_\u0438\u044e\u043d\u044f_\u0438\u044e\u043b\u044f_\u0430\u0432\u0433\u0443\u0441\u0442\u0430_\u0441\u0435\u043d\u0442\u044f\u0431\u0440\u044f_\u043e\u043a\u0442\u044f\u0431\u0440\u044f_\u043d\u043e\u044f\u0431\u0440\u044f_\u0434\u0435\u043a\u0430\u0431\u0440\u044f".split("_"),standalone:"\u044f\u043d\u0432\u0430\u0440\u044c_\u0444\u0435\u0432\u0440\u0430\u043b\u044c_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b\u044c_\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440\u044c_\u043e\u043a\u0442\u044f\u0431\u0440\u044c_\u043d\u043e\u044f\u0431\u0440\u044c_\u0434\u0435\u043a\u0430\u0431\u0440\u044c".split("_")},monthsShort:{format:"\u044f\u043d\u0432._\u0444\u0435\u0432\u0440._\u043c\u0430\u0440._\u0430\u043f\u0440._\u043c\u0430\u044f_\u0438\u044e\u043d\u044f_\u0438\u044e\u043b\u044f_\u0430\u0432\u0433._\u0441\u0435\u043d\u0442._\u043e\u043a\u0442._\u043d\u043e\u044f\u0431._\u0434\u0435\u043a.".split("_"),standalone:"\u044f\u043d\u0432._\u0444\u0435\u0432\u0440._\u043c\u0430\u0440\u0442_\u0430\u043f\u0440._\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433._\u0441\u0435\u043d\u0442._\u043e\u043a\u0442._\u043d\u043e\u044f\u0431._\u0434\u0435\u043a.".split("_")},weekdays:{standalone:"\u0432\u043e\u0441\u043a\u0440\u0435\u0441\u0435\u043d\u044c\u0435_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0435\u0440\u0433_\u043f\u044f\u0442\u043d\u0438\u0446\u0430_\u0441\u0443\u0431\u0431\u043e\u0442\u0430".split("_"),format:"\u0432\u043e\u0441\u043a\u0440\u0435\u0441\u0435\u043d\u044c\u0435_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u0435\u0434\u0443_\u0447\u0435\u0442\u0432\u0435\u0440\u0433_\u043f\u044f\u0442\u043d\u0438\u0446\u0443_\u0441\u0443\u0431\u0431\u043e\u0442\u0443".split("_"),isFormat:/\[ ?[\u0412\u0432] ?(?:\u043f\u0440\u043e\u0448\u043b\u0443\u044e|\u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0443\u044e|\u044d\u0442\u0443)? ?\] ?dddd/},weekdaysShort:"\u0432\u0441_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),weekdaysMin:"\u0432\u0441_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),monthsParse:aa,longMonthsParse:aa,shortMonthsParse:aa,monthsRegex:/^(\u044f\u043d\u0432\u0430\u0440[\u044c\u044f]|\u044f\u043d\u0432\.?|\u0444\u0435\u0432\u0440\u0430\u043b[\u044c\u044f]|\u0444\u0435\u0432\u0440?\.?|\u043c\u0430\u0440\u0442\u0430?|\u043c\u0430\u0440\.?|\u0430\u043f\u0440\u0435\u043b[\u044c\u044f]|\u0430\u043f\u0440\.?|\u043c\u0430[\u0439\u044f]|\u0438\u044e\u043d[\u044c\u044f]|\u0438\u044e\u043d\.?|\u0438\u044e\u043b[\u044c\u044f]|\u0438\u044e\u043b\.?|\u0430\u0432\u0433\u0443\u0441\u0442\u0430?|\u0430\u0432\u0433\.?|\u0441\u0435\u043d\u0442\u044f\u0431\u0440[\u044c\u044f]|\u0441\u0435\u043d\u0442?\.?|\u043e\u043a\u0442\u044f\u0431\u0440[\u044c\u044f]|\u043e\u043a\u0442\.?|\u043d\u043e\u044f\u0431\u0440[\u044c\u044f]|\u043d\u043e\u044f\u0431?\.?|\u0434\u0435\u043a\u0430\u0431\u0440[\u044c\u044f]|\u0434\u0435\u043a\.?)/i,monthsShortRegex:/^(\u044f\u043d\u0432\u0430\u0440[\u044c\u044f]|\u044f\u043d\u0432\.?|\u0444\u0435\u0432\u0440\u0430\u043b[\u044c\u044f]|\u0444\u0435\u0432\u0440?\.?|\u043c\u0430\u0440\u0442\u0430?|\u043c\u0430\u0440\.?|\u0430\u043f\u0440\u0435\u043b[\u044c\u044f]|\u0430\u043f\u0440\.?|\u043c\u0430[\u0439\u044f]|\u0438\u044e\u043d[\u044c\u044f]|\u0438\u044e\u043d\.?|\u0438\u044e\u043b[\u044c\u044f]|\u0438\u044e\u043b\.?|\u0430\u0432\u0433\u0443\u0441\u0442\u0430?|\u0430\u0432\u0433\.?|\u0441\u0435\u043d\u0442\u044f\u0431\u0440[\u044c\u044f]|\u0441\u0435\u043d\u0442?\.?|\u043e\u043a\u0442\u044f\u0431\u0440[\u044c\u044f]|\u043e\u043a\u0442\.?|\u043d\u043e\u044f\u0431\u0440[\u044c\u044f]|\u043d\u043e\u044f\u0431?\.?|\u0434\u0435\u043a\u0430\u0431\u0440[\u044c\u044f]|\u0434\u0435\u043a\.?)/i,monthsStrictRegex:/^(\u044f\u043d\u0432\u0430\u0440[\u044f\u044c]|\u0444\u0435\u0432\u0440\u0430\u043b[\u044f\u044c]|\u043c\u0430\u0440\u0442\u0430?|\u0430\u043f\u0440\u0435\u043b[\u044f\u044c]|\u043c\u0430[\u044f\u0439]|\u0438\u044e\u043d[\u044f\u044c]|\u0438\u044e\u043b[\u044f\u044c]|\u0430\u0432\u0433\u0443\u0441\u0442\u0430?|\u0441\u0435\u043d\u0442\u044f\u0431\u0440[\u044f\u044c]|\u043e\u043a\u0442\u044f\u0431\u0440[\u044f\u044c]|\u043d\u043e\u044f\u0431\u0440[\u044f\u044c]|\u0434\u0435\u043a\u0430\u0431\u0440[\u044f\u044c])/i,monthsShortStrictRegex:/^(\u044f\u043d\u0432\.|\u0444\u0435\u0432\u0440?\.|\u043c\u0430\u0440[\u0442.]|\u0430\u043f\u0440\.|\u043c\u0430[\u044f\u0439]|\u0438\u044e\u043d[\u044c\u044f.]|\u0438\u044e\u043b[\u044c\u044f.]|\u0430\u0432\u0433\.|\u0441\u0435\u043d\u0442?\.|\u043e\u043a\u0442\.|\u043d\u043e\u044f\u0431?\.|\u0434\u0435\u043a\.)/i,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0433.",LLL:"D MMMM YYYY \u0433., H:mm",LLLL:"dddd, D MMMM YYYY \u0433., H:mm"},calendar:{sameDay:"[\u0421\u0435\u0433\u043e\u0434\u043d\u044f, \u0432] LT",nextDay:"[\u0417\u0430\u0432\u0442\u0440\u0430, \u0432] LT",lastDay:"[\u0412\u0447\u0435\u0440\u0430, \u0432] LT",nextWeek:function(e){if(e.week()===this.week())return 2===this.day()?"[\u0412\u043e] dddd, [\u0432] LT":"[\u0412] dddd, [\u0432] LT";switch(this.day()){case 0:return"[\u0412 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0435] dddd, [\u0432] LT";case 1:case 2:case 4:return"[\u0412 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439] dddd, [\u0432] LT";case 3:case 5:case 6:return"[\u0412 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0443\u044e] dddd, [\u0432] LT"}},lastWeek:function(e){if(e.week()===this.week())return 2===this.day()?"[\u0412\u043e] dddd, [\u0432] LT":"[\u0412] dddd, [\u0432] LT";switch(this.day()){case 0:return"[\u0412 \u043f\u0440\u043e\u0448\u043b\u043e\u0435] dddd, [\u0432] LT";case 1:case 2:case 4:return"[\u0412 \u043f\u0440\u043e\u0448\u043b\u044b\u0439] dddd, [\u0432] LT";case 3:case 5:case 6:return"[\u0412 \u043f\u0440\u043e\u0448\u043b\u0443\u044e] dddd, [\u0432] LT"}},sameElse:"L"},relativeTime:{future:"\u0447\u0435\u0440\u0435\u0437 %s",past:"%s \u043d\u0430\u0437\u0430\u0434",s:"\u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u043a\u0443\u043d\u0434",ss:ea,m:ea,mm:ea,h:"\u0447\u0430\u0441",hh:ea,d:"\u0434\u0435\u043d\u044c",dd:ea,M:"\u043c\u0435\u0441\u044f\u0446",MM:ea,y:"\u0433\u043e\u0434",yy:ea},meridiemParse:/\u043d\u043e\u0447\u0438|\u0443\u0442\u0440\u0430|\u0434\u043d\u044f|\u0432\u0435\u0447\u0435\u0440\u0430/i,isPM:function(e){return/^(\u0434\u043d\u044f|\u0432\u0435\u0447\u0435\u0440\u0430)$/.test(e)},meridiem:function(e,a,_){return e<4?"\u043d\u043e\u0447\u0438":e<12?"\u0443\u0442\u0440\u0430":e<17?"\u0434\u043d\u044f":"\u0432\u0435\u0447\u0435\u0440\u0430"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0439|\u0433\u043e|\u044f)/,ordinal:function(e,a){switch(a){case"M":case"d":case"DDD":return e+"-\u0439";case"D":return e+"-\u0433\u043e";case"w":case"W":return e+"-\u044f";default:return e}},week:{dow:1,doy:4}});var _a=["\u062c\u0646\u0648\u0631\u064a","\u0641\u064a\u0628\u0631\u0648\u0631\u064a","\u0645\u0627\u0631\u0686","\u0627\u067e\u0631\u064a\u0644","\u0645\u0626\u064a","\u062c\u0648\u0646","\u062c\u0648\u0644\u0627\u0621\u0650","\u0622\u06af\u0633\u067d","\u0633\u064a\u067e\u067d\u0645\u0628\u0631","\u0622\u06aa\u067d\u0648\u0628\u0631","\u0646\u0648\u0645\u0628\u0631","\u068a\u0633\u0645\u0628\u0631"],sa=["\u0622\u0686\u0631","\u0633\u0648\u0645\u0631","\u0627\u06b1\u0627\u0631\u0648","\u0627\u0631\u0628\u0639","\u062e\u0645\u064a\u0633","\u062c\u0645\u0639","\u0687\u0646\u0687\u0631"];e.defineLocale("sd",{months:_a,monthsShort:_a,weekdays:sa,weekdaysShort:sa,weekdaysMin:sa,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd\u060c D MMMM YYYY HH:mm"},meridiemParse:/\u0635\u0628\u062d|\u0634\u0627\u0645/,isPM:function(e){return"\u0634\u0627\u0645"===e},meridiem:function(e,a,_){return e<12?"\u0635\u0628\u062d":"\u0634\u0627\u0645"},calendar:{sameDay:"[\u0627\u0684] LT",nextDay:"[\u0633\u0680\u0627\u06bb\u064a] LT",nextWeek:"dddd [\u0627\u06b3\u064a\u0646 \u0647\u0641\u062a\u064a \u062a\u064a] LT",lastDay:"[\u06aa\u0627\u0644\u0647\u0647] LT",lastWeek:"[\u06af\u0632\u0631\u064a\u0644 \u0647\u0641\u062a\u064a] dddd [\u062a\u064a] LT",sameElse:"L"},relativeTime:{future:"%s \u067e\u0648\u0621",past:"%s \u0627\u06b3",s:"\u0686\u0646\u062f \u0633\u064a\u06aa\u0646\u068a",ss:"%d \u0633\u064a\u06aa\u0646\u068a",m:"\u0647\u06aa \u0645\u0646\u067d",mm:"%d \u0645\u0646\u067d",h:"\u0647\u06aa \u06aa\u0644\u0627\u06aa",hh:"%d \u06aa\u0644\u0627\u06aa",d:"\u0647\u06aa \u068f\u064a\u0646\u0647\u0646",dd:"%d \u068f\u064a\u0646\u0647\u0646",M:"\u0647\u06aa \u0645\u0647\u064a\u0646\u0648",MM:"%d \u0645\u0647\u064a\u0646\u0627",y:"\u0647\u06aa \u0633\u0627\u0644",yy:"%d \u0633\u0627\u0644"},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:1,doy:4}}),e.defineLocale("se",{months:"o\u0111\u0111ajagem\xe1nnu_guovvam\xe1nnu_njuk\u010dam\xe1nnu_cuo\u014bom\xe1nnu_miessem\xe1nnu_geassem\xe1nnu_suoidnem\xe1nnu_borgem\xe1nnu_\u010dak\u010dam\xe1nnu_golggotm\xe1nnu_sk\xe1bmam\xe1nnu_juovlam\xe1nnu".split("_"),monthsShort:"o\u0111\u0111j_guov_njuk_cuo_mies_geas_suoi_borg_\u010dak\u010d_golg_sk\xe1b_juov".split("_"),weekdays:"sotnabeaivi_vuoss\xe1rga_ma\u014b\u014beb\xe1rga_gaskavahkku_duorastat_bearjadat_l\xe1vvardat".split("_"),weekdaysShort:"sotn_vuos_ma\u014b_gask_duor_bear_l\xe1v".split("_"),weekdaysMin:"s_v_m_g_d_b_L".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"MMMM D. [b.] YYYY",LLL:"MMMM D. [b.] YYYY [ti.] HH:mm",LLLL:"dddd, MMMM D. [b.] YYYY [ti.] HH:mm"},calendar:{sameDay:"[otne ti] LT",nextDay:"[ihttin ti] LT",nextWeek:"dddd [ti] LT",lastDay:"[ikte ti] LT",lastWeek:"[ovddit] dddd [ti] LT",sameElse:"L"},relativeTime:{future:"%s gea\u017ees",past:"ma\u014bit %s",s:"moadde sekunddat",ss:"%d sekunddat",m:"okta minuhta",mm:"%d minuhtat",h:"okta diimmu",hh:"%d diimmut",d:"okta beaivi",dd:"%d beaivvit",M:"okta m\xe1nnu",MM:"%d m\xe1nut",y:"okta jahki",yy:"%d jagit"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("si",{months:"\u0da2\u0db1\u0dc0\u0dcf\u0dbb\u0dd2_\u0db4\u0dd9\u0db6\u0dbb\u0dc0\u0dcf\u0dbb\u0dd2_\u0db8\u0dcf\u0dbb\u0dca\u0dad\u0dd4_\u0d85\u0db4\u0dca\u200d\u0dbb\u0dda\u0dbd\u0dca_\u0db8\u0dd0\u0dba\u0dd2_\u0da2\u0dd6\u0db1\u0dd2_\u0da2\u0dd6\u0dbd\u0dd2_\u0d85\u0d9c\u0ddd\u0dc3\u0dca\u0dad\u0dd4_\u0dc3\u0dd0\u0db4\u0dca\u0dad\u0dd0\u0db8\u0dca\u0db6\u0dbb\u0dca_\u0d94\u0d9a\u0dca\u0dad\u0ddd\u0db6\u0dbb\u0dca_\u0db1\u0ddc\u0dc0\u0dd0\u0db8\u0dca\u0db6\u0dbb\u0dca_\u0daf\u0dd9\u0dc3\u0dd0\u0db8\u0dca\u0db6\u0dbb\u0dca".split("_"),monthsShort:"\u0da2\u0db1_\u0db4\u0dd9\u0db6_\u0db8\u0dcf\u0dbb\u0dca_\u0d85\u0db4\u0dca_\u0db8\u0dd0\u0dba\u0dd2_\u0da2\u0dd6\u0db1\u0dd2_\u0da2\u0dd6\u0dbd\u0dd2_\u0d85\u0d9c\u0ddd_\u0dc3\u0dd0\u0db4\u0dca_\u0d94\u0d9a\u0dca_\u0db1\u0ddc\u0dc0\u0dd0_\u0daf\u0dd9\u0dc3\u0dd0".split("_"),weekdays:"\u0d89\u0dbb\u0dd2\u0daf\u0dcf_\u0dc3\u0db3\u0dd4\u0daf\u0dcf_\u0d85\u0d9f\u0dc4\u0dbb\u0dd4\u0dc0\u0dcf\u0daf\u0dcf_\u0db6\u0daf\u0dcf\u0daf\u0dcf_\u0db6\u0dca\u200d\u0dbb\u0dc4\u0dc3\u0dca\u0db4\u0dad\u0dd2\u0db1\u0dca\u0daf\u0dcf_\u0dc3\u0dd2\u0d9a\u0dd4\u0dbb\u0dcf\u0daf\u0dcf_\u0dc3\u0dd9\u0db1\u0dc3\u0dd4\u0dbb\u0dcf\u0daf\u0dcf".split("_"),weekdaysShort:"\u0d89\u0dbb\u0dd2_\u0dc3\u0db3\u0dd4_\u0d85\u0d9f_\u0db6\u0daf\u0dcf_\u0db6\u0dca\u200d\u0dbb\u0dc4_\u0dc3\u0dd2\u0d9a\u0dd4_\u0dc3\u0dd9\u0db1".split("_"),weekdaysMin:"\u0d89_\u0dc3_\u0d85_\u0db6_\u0db6\u0dca\u200d\u0dbb_\u0dc3\u0dd2_\u0dc3\u0dd9".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"a h:mm",LTS:"a h:mm:ss",L:"YYYY/MM/DD",LL:"YYYY MMMM D",LLL:"YYYY MMMM D, a h:mm",LLLL:"YYYY MMMM D [\u0dc0\u0dd0\u0db1\u0dd2] dddd, a h:mm:ss"},calendar:{sameDay:"[\u0d85\u0daf] LT[\u0da7]",nextDay:"[\u0dc4\u0dd9\u0da7] LT[\u0da7]",nextWeek:"dddd LT[\u0da7]",lastDay:"[\u0d8a\u0dba\u0dda] LT[\u0da7]",lastWeek:"[\u0db4\u0dc3\u0dd4\u0d9c\u0dd2\u0dba] dddd LT[\u0da7]",sameElse:"L"},relativeTime:{future:"%s\u0d9a\u0dd2\u0db1\u0dca",past:"%s\u0d9a\u0da7 \u0db4\u0dd9\u0dbb",s:"\u0dad\u0dad\u0dca\u0db4\u0dbb \u0d9a\u0dd2\u0dc4\u0dd2\u0db4\u0dba",ss:"\u0dad\u0dad\u0dca\u0db4\u0dbb %d",m:"\u0db8\u0dd2\u0db1\u0dd2\u0dad\u0dca\u0dad\u0dd4\u0dc0",mm:"\u0db8\u0dd2\u0db1\u0dd2\u0dad\u0dca\u0dad\u0dd4 %d",h:"\u0db4\u0dd0\u0dba",hh:"\u0db4\u0dd0\u0dba %d",d:"\u0daf\u0dd2\u0db1\u0dba",dd:"\u0daf\u0dd2\u0db1 %d",M:"\u0db8\u0dcf\u0dc3\u0dba",MM:"\u0db8\u0dcf\u0dc3 %d",y:"\u0dc0\u0dc3\u0dbb",yy:"\u0dc0\u0dc3\u0dbb %d"},dayOfMonthOrdinalParse:/\d{1,2} \u0dc0\u0dd0\u0db1\u0dd2/,ordinal:function(e){return e+" \u0dc0\u0dd0\u0db1\u0dd2"},meridiemParse:/\u0db4\u0dd9\u0dbb \u0dc0\u0dbb\u0dd4|\u0db4\u0dc3\u0dca \u0dc0\u0dbb\u0dd4|\u0db4\u0dd9.\u0dc0|\u0db4.\u0dc0./,isPM:function(e){return"\u0db4.\u0dc0."===e||"\u0db4\u0dc3\u0dca \u0dc0\u0dbb\u0dd4"===e},meridiem:function(e,a,_){return 11<e?_?"\u0db4.\u0dc0.":"\u0db4\u0dc3\u0dca \u0dc0\u0dbb\u0dd4":_?"\u0db4\u0dd9.\u0dc0.":"\u0db4\u0dd9\u0dbb \u0dc0\u0dbb\u0dd4"}});var da="janu\xe1r_febru\xe1r_marec_apr\xedl_m\xe1j_j\xfan_j\xfal_august_september_okt\xf3ber_november_december".split("_"),ta="jan_feb_mar_apr_m\xe1j_j\xfan_j\xfal_aug_sep_okt_nov_dec".split("_");function na(e){return 1<e&&e<5}function ra(e,a,_,s){var d=e+" ";switch(_){case"s":return a||s?"p\xe1r sek\xfand":"p\xe1r sekundami";case"ss":return a||s?d+(na(e)?"sekundy":"sek\xfand"):d+"sekundami";break;case"m":return a?"min\xfata":s?"min\xfatu":"min\xfatou";case"mm":return a||s?d+(na(e)?"min\xfaty":"min\xfat"):d+"min\xfatami";break;case"h":return a?"hodina":s?"hodinu":"hodinou";case"hh":return a||s?d+(na(e)?"hodiny":"hod\xedn"):d+"hodinami";break;case"d":return a||s?"de\u0148":"d\u0148om";case"dd":return a||s?d+(na(e)?"dni":"dn\xed"):d+"d\u0148ami";break;case"M":return a||s?"mesiac":"mesiacom";case"MM":return a||s?d+(na(e)?"mesiace":"mesiacov"):d+"mesiacmi";break;case"y":return a||s?"rok":"rokom";case"yy":return a||s?d+(na(e)?"roky":"rokov"):d+"rokmi";break}}function ia(e,a,_,s){var d=e+" ";switch(_){case"s":return a||s?"nekaj sekund":"nekaj sekundami";case"ss":return d+=1===e?a?"sekundo":"sekundi":2===e?a||s?"sekundi":"sekundah":e<5?a||s?"sekunde":"sekundah":"sekund";case"m":return a?"ena minuta":"eno minuto";case"mm":return d+=1===e?a?"minuta":"minuto":2===e?a||s?"minuti":"minutama":e<5?a||s?"minute":"minutami":a||s?"minut":"minutami";case"h":return a?"ena ura":"eno uro";case"hh":return d+=1===e?a?"ura":"uro":2===e?a||s?"uri":"urama":e<5?a||s?"ure":"urami":a||s?"ur":"urami";case"d":return a||s?"en dan":"enim dnem";case"dd":return d+=1===e?a||s?"dan":"dnem":2===e?a||s?"dni":"dnevoma":a||s?"dni":"dnevi";case"M":return a||s?"en mesec":"enim mesecem";case"MM":return d+=1===e?a||s?"mesec":"mesecem":2===e?a||s?"meseca":"mesecema":e<5?a||s?"mesece":"meseci":a||s?"mesecev":"meseci";case"y":return a||s?"eno leto":"enim letom";case"yy":return d+=1===e?a||s?"leto":"letom":2===e?a||s?"leti":"letoma":e<5?a||s?"leta":"leti":a||s?"let":"leti"}}e.defineLocale("sk",{months:da,monthsShort:ta,weekdays:"nede\u013ea_pondelok_utorok_streda_\u0161tvrtok_piatok_sobota".split("_"),weekdaysShort:"ne_po_ut_st_\u0161t_pi_so".split("_"),weekdaysMin:"ne_po_ut_st_\u0161t_pi_so".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd D. MMMM YYYY H:mm"},calendar:{sameDay:"[dnes o] LT",nextDay:"[zajtra o] LT",nextWeek:function(){switch(this.day()){case 0:return"[v nede\u013eu o] LT";case 1:case 2:return"[v] dddd [o] LT";case 3:return"[v stredu o] LT";case 4:return"[vo \u0161tvrtok o] LT";case 5:return"[v piatok o] LT";case 6:return"[v sobotu o] LT"}},lastDay:"[v\u010dera o] LT",lastWeek:function(){switch(this.day()){case 0:return"[minul\xfa nede\u013eu o] LT";case 1:case 2:return"[minul\xfd] dddd [o] LT";case 3:return"[minul\xfa stredu o] LT";case 4:case 5:return"[minul\xfd] dddd [o] LT";case 6:return"[minul\xfa sobotu o] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"pred %s",s:ra,ss:ra,m:ra,mm:ra,h:ra,hh:ra,d:ra,dd:ra,M:ra,MM:ra,y:ra,yy:ra},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("sl",{months:"januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),monthsShort:"jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedelja_ponedeljek_torek_sreda_\u010detrtek_petek_sobota".split("_"),weekdaysShort:"ned._pon._tor._sre._\u010det._pet._sob.".split("_"),weekdaysMin:"ne_po_to_sr_\u010de_pe_so".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danes ob] LT",nextDay:"[jutri ob] LT",nextWeek:function(){switch(this.day()){case 0:return"[v] [nedeljo] [ob] LT";case 3:return"[v] [sredo] [ob] LT";case 6:return"[v] [soboto] [ob] LT";case 1:case 2:case 4:case 5:return"[v] dddd [ob] LT"}},lastDay:"[v\u010deraj ob] LT",lastWeek:function(){switch(this.day()){case 0:return"[prej\u0161njo] [nedeljo] [ob] LT";case 3:return"[prej\u0161njo] [sredo] [ob] LT";case 6:return"[prej\u0161njo] [soboto] [ob] LT";case 1:case 2:case 4:case 5:return"[prej\u0161nji] dddd [ob] LT"}},sameElse:"L"},relativeTime:{future:"\u010dez %s",past:"pred %s",s:ia,ss:ia,m:ia,mm:ia,h:ia,hh:ia,d:ia,dd:ia,M:ia,MM:ia,y:ia,yy:ia},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),e.defineLocale("sq",{months:"Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_N\xebntor_Dhjetor".split("_"),monthsShort:"Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_N\xebn_Dhj".split("_"),weekdays:"E Diel_E H\xebn\xeb_E Mart\xeb_E M\xebrkur\xeb_E Enjte_E Premte_E Shtun\xeb".split("_"),weekdaysShort:"Die_H\xebn_Mar_M\xebr_Enj_Pre_Sht".split("_"),weekdaysMin:"D_H_Ma_M\xeb_E_P_Sh".split("_"),weekdaysParseExact:!0,meridiemParse:/PD|MD/,isPM:function(e){return"M"===e.charAt(0)},meridiem:function(e,a,_){return e<12?"PD":"MD"},longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Sot n\xeb] LT",nextDay:"[Nes\xebr n\xeb] LT",nextWeek:"dddd [n\xeb] LT",lastDay:"[Dje n\xeb] LT",lastWeek:"dddd [e kaluar n\xeb] LT",sameElse:"L"},relativeTime:{future:"n\xeb %s",past:"%s m\xeb par\xeb",s:"disa sekonda",ss:"%d sekonda",m:"nj\xeb minut\xeb",mm:"%d minuta",h:"nj\xeb or\xeb",hh:"%d or\xeb",d:"nj\xeb dit\xeb",dd:"%d dit\xeb",M:"nj\xeb muaj",MM:"%d muaj",y:"nj\xeb vit",yy:"%d vite"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var ma={words:{ss:["\u0441\u0435\u043a\u0443\u043d\u0434\u0430","\u0441\u0435\u043a\u0443\u043d\u0434\u0435","\u0441\u0435\u043a\u0443\u043d\u0434\u0438"],m:["\u0458\u0435\u0434\u0430\u043d \u043c\u0438\u043d\u0443\u0442","\u0458\u0435\u0434\u043d\u0435 \u043c\u0438\u043d\u0443\u0442\u0435"],mm:["\u043c\u0438\u043d\u0443\u0442","\u043c\u0438\u043d\u0443\u0442\u0435","\u043c\u0438\u043d\u0443\u0442\u0430"],h:["\u0458\u0435\u0434\u0430\u043d \u0441\u0430\u0442","\u0458\u0435\u0434\u043d\u043e\u0433 \u0441\u0430\u0442\u0430"],hh:["\u0441\u0430\u0442","\u0441\u0430\u0442\u0430","\u0441\u0430\u0442\u0438"],dd:["\u0434\u0430\u043d","\u0434\u0430\u043d\u0430","\u0434\u0430\u043d\u0430"],MM:["\u043c\u0435\u0441\u0435\u0446","\u043c\u0435\u0441\u0435\u0446\u0430","\u043c\u0435\u0441\u0435\u0446\u0438"],yy:["\u0433\u043e\u0434\u0438\u043d\u0430","\u0433\u043e\u0434\u0438\u043d\u0435","\u0433\u043e\u0434\u0438\u043d\u0430"]},correctGrammaticalCase:function(e,a){return 1===e?a[0]:2<=e&&e<=4?a[1]:a[2]},translate:function(e,a,_){var s=ma.words[_];return 1===_.length?a?s[0]:s[1]:e+" "+ma.correctGrammaticalCase(e,s)}};e.defineLocale("sr-cyrl",{months:"\u0458\u0430\u043d\u0443\u0430\u0440_\u0444\u0435\u0431\u0440\u0443\u0430\u0440_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0438\u043b_\u043c\u0430\u0458_\u0458\u0443\u043d_\u0458\u0443\u043b_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043f\u0442\u0435\u043c\u0431\u0430\u0440_\u043e\u043a\u0442\u043e\u0431\u0430\u0440_\u043d\u043e\u0432\u0435\u043c\u0431\u0430\u0440_\u0434\u0435\u0446\u0435\u043c\u0431\u0430\u0440".split("_"),monthsShort:"\u0458\u0430\u043d._\u0444\u0435\u0431._\u043c\u0430\u0440._\u0430\u043f\u0440._\u043c\u0430\u0458_\u0458\u0443\u043d_\u0458\u0443\u043b_\u0430\u0432\u0433._\u0441\u0435\u043f._\u043e\u043a\u0442._\u043d\u043e\u0432._\u0434\u0435\u0446.".split("_"),monthsParseExact:!0,weekdays:"\u043d\u0435\u0434\u0435\u0459\u0430_\u043f\u043e\u043d\u0435\u0434\u0435\u0459\u0430\u043a_\u0443\u0442\u043e\u0440\u0430\u043a_\u0441\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0440\u0442\u0430\u043a_\u043f\u0435\u0442\u0430\u043a_\u0441\u0443\u0431\u043e\u0442\u0430".split("_"),weekdaysShort:"\u043d\u0435\u0434._\u043f\u043e\u043d._\u0443\u0442\u043e._\u0441\u0440\u0435._\u0447\u0435\u0442._\u043f\u0435\u0442._\u0441\u0443\u0431.".split("_"),weekdaysMin:"\u043d\u0435_\u043f\u043e_\u0443\u0442_\u0441\u0440_\u0447\u0435_\u043f\u0435_\u0441\u0443".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[\u0434\u0430\u043d\u0430\u0441 \u0443] LT",nextDay:"[\u0441\u0443\u0442\u0440\u0430 \u0443] LT",nextWeek:function(){switch(this.day()){case 0:return"[\u0443] [\u043d\u0435\u0434\u0435\u0459\u0443] [\u0443] LT";case 3:return"[\u0443] [\u0441\u0440\u0435\u0434\u0443] [\u0443] LT";case 6:return"[\u0443] [\u0441\u0443\u0431\u043e\u0442\u0443] [\u0443] LT";case 1:case 2:case 4:case 5:return"[\u0443] dddd [\u0443] LT"}},lastDay:"[\u0458\u0443\u0447\u0435 \u0443] LT",lastWeek:function(){return["[\u043f\u0440\u043e\u0448\u043b\u0435] [\u043d\u0435\u0434\u0435\u0459\u0435] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u043f\u043e\u043d\u0435\u0434\u0435\u0459\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u0443\u0442\u043e\u0440\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u0435] [\u0441\u0440\u0435\u0434\u0435] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u0447\u0435\u0442\u0432\u0440\u0442\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u043f\u0435\u0442\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u0435] [\u0441\u0443\u0431\u043e\u0442\u0435] [\u0443] LT"][this.day()]},sameElse:"L"},relativeTime:{future:"\u0437\u0430 %s",past:"\u043f\u0440\u0435 %s",s:"\u043d\u0435\u043a\u043e\u043b\u0438\u043a\u043e \u0441\u0435\u043a\u0443\u043d\u0434\u0438",ss:ma.translate,m:ma.translate,mm:ma.translate,h:ma.translate,hh:ma.translate,d:"\u0434\u0430\u043d",dd:ma.translate,M:"\u043c\u0435\u0441\u0435\u0446",MM:ma.translate,y:"\u0433\u043e\u0434\u0438\u043d\u0443",yy:ma.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}});var oa={words:{ss:["sekunda","sekunde","sekundi"],m:["jedan minut","jedne minute"],mm:["minut","minute","minuta"],h:["jedan sat","jednog sata"],hh:["sat","sata","sati"],dd:["dan","dana","dana"],MM:["mesec","meseca","meseci"],yy:["godina","godine","godina"]},correctGrammaticalCase:function(e,a){return 1===e?a[0]:2<=e&&e<=4?a[1]:a[2]},translate:function(e,a,_){var s=oa.words[_];return 1===_.length?a?s[0]:s[1]:e+" "+oa.correctGrammaticalCase(e,s)}};e.defineLocale("sr",{months:"januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),monthsShort:"jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedelja_ponedeljak_utorak_sreda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sre._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sutra u] LT",nextWeek:function(){switch(this.day()){case 0:return"[u] [nedelju] [u] LT";case 3:return"[u] [sredu] [u] LT";case 6:return"[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return"[u] dddd [u] LT"}},lastDay:"[ju\u010de u] LT",lastWeek:function(){return["[pro\u0161le] [nedelje] [u] LT","[pro\u0161log] [ponedeljka] [u] LT","[pro\u0161log] [utorka] [u] LT","[pro\u0161le] [srede] [u] LT","[pro\u0161log] [\u010detvrtka] [u] LT","[pro\u0161log] [petka] [u] LT","[pro\u0161le] [subote] [u] LT"][this.day()]},sameElse:"L"},relativeTime:{future:"za %s",past:"pre %s",s:"nekoliko sekundi",ss:oa.translate,m:oa.translate,mm:oa.translate,h:oa.translate,hh:oa.translate,d:"dan",dd:oa.translate,M:"mesec",MM:oa.translate,y:"godinu",yy:oa.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),e.defineLocale("ss",{months:"Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"),monthsShort:"Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),weekdays:"Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"),weekdaysShort:"Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),weekdaysMin:"Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[Namuhla nga] LT",nextDay:"[Kusasa nga] LT",nextWeek:"dddd [nga] LT",lastDay:"[Itolo nga] LT",lastWeek:"dddd [leliphelile] [nga] LT",sameElse:"L"},relativeTime:{future:"nga %s",past:"wenteka nga %s",s:"emizuzwana lomcane",ss:"%d mzuzwana",m:"umzuzu",mm:"%d emizuzu",h:"lihora",hh:"%d emahora",d:"lilanga",dd:"%d emalanga",M:"inyanga",MM:"%d tinyanga",y:"umnyaka",yy:"%d iminyaka"},meridiemParse:/ekuseni|emini|entsambama|ebusuku/,meridiem:function(e,a,_){return e<11?"ekuseni":e<15?"emini":e<19?"entsambama":"ebusuku"},meridiemHour:function(e,a){return 12===e&&(e=0),"ekuseni"===a?e:"emini"===a?11<=e?e:e+12:"entsambama"===a||"ebusuku"===a?0===e?0:e+12:void 0},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:"%d",week:{dow:1,doy:4}}),e.defineLocale("sv",{months:"januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),monthsShort:"jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),weekdays:"s\xf6ndag_m\xe5ndag_tisdag_onsdag_torsdag_fredag_l\xf6rdag".split("_"),weekdaysShort:"s\xf6n_m\xe5n_tis_ons_tor_fre_l\xf6r".split("_"),weekdaysMin:"s\xf6_m\xe5_ti_on_to_fr_l\xf6".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [kl.] HH:mm",LLLL:"dddd D MMMM YYYY [kl.] HH:mm",lll:"D MMM YYYY HH:mm",llll:"ddd D MMM YYYY HH:mm"},calendar:{sameDay:"[Idag] LT",nextDay:"[Imorgon] LT",lastDay:"[Ig\xe5r] LT",nextWeek:"[P\xe5] dddd LT",lastWeek:"[I] dddd[s] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"f\xf6r %s sedan",s:"n\xe5gra sekunder",ss:"%d sekunder",m:"en minut",mm:"%d minuter",h:"en timme",hh:"%d timmar",d:"en dag",dd:"%d dagar",M:"en m\xe5nad",MM:"%d m\xe5nader",y:"ett \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}(e|a)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"e":1===a?"a":2===a?"a":"e")},week:{dow:1,doy:4}}),e.defineLocale("sw",{months:"Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"),monthsShort:"Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),weekdays:"Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"),weekdaysShort:"Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),weekdaysMin:"J2_J3_J4_J5_Al_Ij_J1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[leo saa] LT",nextDay:"[kesho saa] LT",nextWeek:"[wiki ijayo] dddd [saat] LT",lastDay:"[jana] LT",lastWeek:"[wiki iliyopita] dddd [saat] LT",sameElse:"L"},relativeTime:{future:"%s baadaye",past:"tokea %s",s:"hivi punde",ss:"sekunde %d",m:"dakika moja",mm:"dakika %d",h:"saa limoja",hh:"masaa %d",d:"siku moja",dd:"masiku %d",M:"mwezi mmoja",MM:"miezi %d",y:"mwaka mmoja",yy:"miaka %d"},week:{dow:1,doy:7}});var ua={1:"\u0be7",2:"\u0be8",3:"\u0be9",4:"\u0bea",5:"\u0beb",6:"\u0bec",7:"\u0bed",8:"\u0bee",9:"\u0bef",0:"\u0be6"},la={"\u0be7":"1","\u0be8":"2","\u0be9":"3","\u0bea":"4","\u0beb":"5","\u0bec":"6","\u0bed":"7","\u0bee":"8","\u0bef":"9","\u0be6":"0"};e.defineLocale("ta",{months:"\u0b9c\u0ba9\u0bb5\u0bb0\u0bbf_\u0baa\u0bbf\u0baa\u0bcd\u0bb0\u0bb5\u0bb0\u0bbf_\u0bae\u0bbe\u0bb0\u0bcd\u0b9a\u0bcd_\u0b8f\u0baa\u0bcd\u0bb0\u0bb2\u0bcd_\u0bae\u0bc7_\u0b9c\u0bc2\u0ba9\u0bcd_\u0b9c\u0bc2\u0bb2\u0bc8_\u0b86\u0b95\u0bb8\u0bcd\u0b9f\u0bcd_\u0b9a\u0bc6\u0baa\u0bcd\u0b9f\u0bc6\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b85\u0b95\u0bcd\u0b9f\u0bc7\u0bbe\u0baa\u0bb0\u0bcd_\u0ba8\u0bb5\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b9f\u0bbf\u0b9a\u0bae\u0bcd\u0baa\u0bb0\u0bcd".split("_"),monthsShort:"\u0b9c\u0ba9\u0bb5\u0bb0\u0bbf_\u0baa\u0bbf\u0baa\u0bcd\u0bb0\u0bb5\u0bb0\u0bbf_\u0bae\u0bbe\u0bb0\u0bcd\u0b9a\u0bcd_\u0b8f\u0baa\u0bcd\u0bb0\u0bb2\u0bcd_\u0bae\u0bc7_\u0b9c\u0bc2\u0ba9\u0bcd_\u0b9c\u0bc2\u0bb2\u0bc8_\u0b86\u0b95\u0bb8\u0bcd\u0b9f\u0bcd_\u0b9a\u0bc6\u0baa\u0bcd\u0b9f\u0bc6\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b85\u0b95\u0bcd\u0b9f\u0bc7\u0bbe\u0baa\u0bb0\u0bcd_\u0ba8\u0bb5\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b9f\u0bbf\u0b9a\u0bae\u0bcd\u0baa\u0bb0\u0bcd".split("_"),weekdays:"\u0b9e\u0bbe\u0baf\u0bbf\u0bb1\u0bcd\u0bb1\u0bc1\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0ba4\u0bbf\u0b99\u0bcd\u0b95\u0b9f\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0b9a\u0bc6\u0bb5\u0bcd\u0bb5\u0bbe\u0baf\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0baa\u0bc1\u0ba4\u0ba9\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0bb5\u0bbf\u0baf\u0bbe\u0bb4\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0bb5\u0bc6\u0bb3\u0bcd\u0bb3\u0bbf\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0b9a\u0ba9\u0bbf\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8".split("_"),weekdaysShort:"\u0b9e\u0bbe\u0baf\u0bbf\u0bb1\u0bc1_\u0ba4\u0bbf\u0b99\u0bcd\u0b95\u0bb3\u0bcd_\u0b9a\u0bc6\u0bb5\u0bcd\u0bb5\u0bbe\u0baf\u0bcd_\u0baa\u0bc1\u0ba4\u0ba9\u0bcd_\u0bb5\u0bbf\u0baf\u0bbe\u0bb4\u0ba9\u0bcd_\u0bb5\u0bc6\u0bb3\u0bcd\u0bb3\u0bbf_\u0b9a\u0ba9\u0bbf".split("_"),weekdaysMin:"\u0b9e\u0bbe_\u0ba4\u0bbf_\u0b9a\u0bc6_\u0baa\u0bc1_\u0bb5\u0bbf_\u0bb5\u0bc6_\u0b9a".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, HH:mm",LLLL:"dddd, D MMMM YYYY, HH:mm"},calendar:{sameDay:"[\u0b87\u0ba9\u0bcd\u0bb1\u0bc1] LT",nextDay:"[\u0ba8\u0bbe\u0bb3\u0bc8] LT",nextWeek:"dddd, LT",lastDay:"[\u0ba8\u0bc7\u0bb1\u0bcd\u0bb1\u0bc1] LT",lastWeek:"[\u0b95\u0b9f\u0ba8\u0bcd\u0ba4 \u0bb5\u0bbe\u0bb0\u0bae\u0bcd] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0b87\u0bb2\u0bcd",past:"%s \u0bae\u0bc1\u0ba9\u0bcd",s:"\u0b92\u0bb0\u0bc1 \u0b9a\u0bbf\u0bb2 \u0bb5\u0bbf\u0ba8\u0bbe\u0b9f\u0bbf\u0b95\u0bb3\u0bcd",ss:"%d \u0bb5\u0bbf\u0ba8\u0bbe\u0b9f\u0bbf\u0b95\u0bb3\u0bcd",m:"\u0b92\u0bb0\u0bc1 \u0ba8\u0bbf\u0bae\u0bbf\u0b9f\u0bae\u0bcd",mm:"%d \u0ba8\u0bbf\u0bae\u0bbf\u0b9f\u0b99\u0bcd\u0b95\u0bb3\u0bcd",h:"\u0b92\u0bb0\u0bc1 \u0bae\u0ba3\u0bbf \u0ba8\u0bc7\u0bb0\u0bae\u0bcd",hh:"%d \u0bae\u0ba3\u0bbf \u0ba8\u0bc7\u0bb0\u0bae\u0bcd",d:"\u0b92\u0bb0\u0bc1 \u0ba8\u0bbe\u0bb3\u0bcd",dd:"%d \u0ba8\u0bbe\u0b9f\u0bcd\u0b95\u0bb3\u0bcd",M:"\u0b92\u0bb0\u0bc1 \u0bae\u0bbe\u0ba4\u0bae\u0bcd",MM:"%d \u0bae\u0bbe\u0ba4\u0b99\u0bcd\u0b95\u0bb3\u0bcd",y:"\u0b92\u0bb0\u0bc1 \u0bb5\u0bb0\u0bc1\u0b9f\u0bae\u0bcd",yy:"%d \u0b86\u0ba3\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd"},dayOfMonthOrdinalParse:/\d{1,2}\u0bb5\u0ba4\u0bc1/,ordinal:function(e){return e+"\u0bb5\u0ba4\u0bc1"},preparse:function(e){return e.replace(/[\u0be7\u0be8\u0be9\u0bea\u0beb\u0bec\u0bed\u0bee\u0bef\u0be6]/g,function(e){return la[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return ua[e]})},meridiemParse:/\u0baf\u0bbe\u0bae\u0bae\u0bcd|\u0bb5\u0bc8\u0b95\u0bb1\u0bc8|\u0b95\u0bbe\u0bb2\u0bc8|\u0ba8\u0ba3\u0bcd\u0baa\u0b95\u0bb2\u0bcd|\u0b8e\u0bb1\u0bcd\u0baa\u0bbe\u0b9f\u0bc1|\u0bae\u0bbe\u0bb2\u0bc8/,meridiem:function(e,a,_){return e<2?" \u0baf\u0bbe\u0bae\u0bae\u0bcd":e<6?" \u0bb5\u0bc8\u0b95\u0bb1\u0bc8":e<10?" \u0b95\u0bbe\u0bb2\u0bc8":e<14?" \u0ba8\u0ba3\u0bcd\u0baa\u0b95\u0bb2\u0bcd":e<18?" \u0b8e\u0bb1\u0bcd\u0baa\u0bbe\u0b9f\u0bc1":e<22?" \u0bae\u0bbe\u0bb2\u0bc8":" \u0baf\u0bbe\u0bae\u0bae\u0bcd"},meridiemHour:function(e,a){return 12===e&&(e=0),"\u0baf\u0bbe\u0bae\u0bae\u0bcd"===a?e<2?e:e+12:"\u0bb5\u0bc8\u0b95\u0bb1\u0bc8"===a||"\u0b95\u0bbe\u0bb2\u0bc8"===a?e:"\u0ba8\u0ba3\u0bcd\u0baa\u0b95\u0bb2\u0bcd"===a&&10<=e?e:e+12},week:{dow:0,doy:6}}),e.defineLocale("te",{months:"\u0c1c\u0c28\u0c35\u0c30\u0c3f_\u0c2b\u0c3f\u0c2c\u0c4d\u0c30\u0c35\u0c30\u0c3f_\u0c2e\u0c3e\u0c30\u0c4d\u0c1a\u0c3f_\u0c0f\u0c2a\u0c4d\u0c30\u0c3f\u0c32\u0c4d_\u0c2e\u0c47_\u0c1c\u0c42\u0c28\u0c4d_\u0c1c\u0c41\u0c32\u0c48_\u0c06\u0c17\u0c38\u0c4d\u0c1f\u0c41_\u0c38\u0c46\u0c2a\u0c4d\u0c1f\u0c46\u0c02\u0c2c\u0c30\u0c4d_\u0c05\u0c15\u0c4d\u0c1f\u0c4b\u0c2c\u0c30\u0c4d_\u0c28\u0c35\u0c02\u0c2c\u0c30\u0c4d_\u0c21\u0c3f\u0c38\u0c46\u0c02\u0c2c\u0c30\u0c4d".split("_"),monthsShort:"\u0c1c\u0c28._\u0c2b\u0c3f\u0c2c\u0c4d\u0c30._\u0c2e\u0c3e\u0c30\u0c4d\u0c1a\u0c3f_\u0c0f\u0c2a\u0c4d\u0c30\u0c3f._\u0c2e\u0c47_\u0c1c\u0c42\u0c28\u0c4d_\u0c1c\u0c41\u0c32\u0c48_\u0c06\u0c17._\u0c38\u0c46\u0c2a\u0c4d._\u0c05\u0c15\u0c4d\u0c1f\u0c4b._\u0c28\u0c35._\u0c21\u0c3f\u0c38\u0c46.".split("_"),monthsParseExact:!0,weekdays:"\u0c06\u0c26\u0c3f\u0c35\u0c3e\u0c30\u0c02_\u0c38\u0c4b\u0c2e\u0c35\u0c3e\u0c30\u0c02_\u0c2e\u0c02\u0c17\u0c33\u0c35\u0c3e\u0c30\u0c02_\u0c2c\u0c41\u0c27\u0c35\u0c3e\u0c30\u0c02_\u0c17\u0c41\u0c30\u0c41\u0c35\u0c3e\u0c30\u0c02_\u0c36\u0c41\u0c15\u0c4d\u0c30\u0c35\u0c3e\u0c30\u0c02_\u0c36\u0c28\u0c3f\u0c35\u0c3e\u0c30\u0c02".split("_"),weekdaysShort:"\u0c06\u0c26\u0c3f_\u0c38\u0c4b\u0c2e_\u0c2e\u0c02\u0c17\u0c33_\u0c2c\u0c41\u0c27_\u0c17\u0c41\u0c30\u0c41_\u0c36\u0c41\u0c15\u0c4d\u0c30_\u0c36\u0c28\u0c3f".split("_"),weekdaysMin:"\u0c06_\u0c38\u0c4b_\u0c2e\u0c02_\u0c2c\u0c41_\u0c17\u0c41_\u0c36\u0c41_\u0c36".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm",LLLL:"dddd, D MMMM YYYY, A h:mm"},calendar:{sameDay:"[\u0c28\u0c47\u0c21\u0c41] LT",nextDay:"[\u0c30\u0c47\u0c2a\u0c41] LT",nextWeek:"dddd, LT",lastDay:"[\u0c28\u0c3f\u0c28\u0c4d\u0c28] LT",lastWeek:"[\u0c17\u0c24] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0c32\u0c4b",past:"%s \u0c15\u0c4d\u0c30\u0c3f\u0c24\u0c02",s:"\u0c15\u0c4a\u0c28\u0c4d\u0c28\u0c3f \u0c15\u0c4d\u0c37\u0c23\u0c3e\u0c32\u0c41",ss:"%d \u0c38\u0c46\u0c15\u0c28\u0c4d\u0c32\u0c41",m:"\u0c12\u0c15 \u0c28\u0c3f\u0c2e\u0c3f\u0c37\u0c02",mm:"%d \u0c28\u0c3f\u0c2e\u0c3f\u0c37\u0c3e\u0c32\u0c41",h:"\u0c12\u0c15 \u0c17\u0c02\u0c1f",hh:"%d \u0c17\u0c02\u0c1f\u0c32\u0c41",d:"\u0c12\u0c15 \u0c30\u0c4b\u0c1c\u0c41",dd:"%d \u0c30\u0c4b\u0c1c\u0c41\u0c32\u0c41",M:"\u0c12\u0c15 \u0c28\u0c46\u0c32",MM:"%d \u0c28\u0c46\u0c32\u0c32\u0c41",y:"\u0c12\u0c15 \u0c38\u0c02\u0c35\u0c24\u0c4d\u0c38\u0c30\u0c02",yy:"%d \u0c38\u0c02\u0c35\u0c24\u0c4d\u0c38\u0c30\u0c3e\u0c32\u0c41"},dayOfMonthOrdinalParse:/\d{1,2}\u0c35/,ordinal:"%d\u0c35",meridiemParse:/\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f|\u0c09\u0c26\u0c2f\u0c02|\u0c2e\u0c27\u0c4d\u0c2f\u0c3e\u0c39\u0c4d\u0c28\u0c02|\u0c38\u0c3e\u0c2f\u0c02\u0c24\u0c4d\u0c30\u0c02/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f"===a?e<4?e:e+12:"\u0c09\u0c26\u0c2f\u0c02"===a?e:"\u0c2e\u0c27\u0c4d\u0c2f\u0c3e\u0c39\u0c4d\u0c28\u0c02"===a?10<=e?e:e+12:"\u0c38\u0c3e\u0c2f\u0c02\u0c24\u0c4d\u0c30\u0c02"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f":e<10?"\u0c09\u0c26\u0c2f\u0c02":e<17?"\u0c2e\u0c27\u0c4d\u0c2f\u0c3e\u0c39\u0c4d\u0c28\u0c02":e<20?"\u0c38\u0c3e\u0c2f\u0c02\u0c24\u0c4d\u0c30\u0c02":"\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f"},week:{dow:0,doy:6}}),e.defineLocale("tet",{months:"Janeiru_Fevereiru_Marsu_Abril_Maiu_Ju\xf1u_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"),monthsShort:"Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),weekdays:"Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"),weekdaysShort:"Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"),weekdaysMin:"Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Ohin iha] LT",nextDay:"[Aban iha] LT",nextWeek:"dddd [iha] LT",lastDay:"[Horiseik iha] LT",lastWeek:"dddd [semana kotuk] [iha] LT",sameElse:"L"},relativeTime:{future:"iha %s",past:"%s liuba",s:"minutu balun",ss:"minutu %d",m:"minutu ida",mm:"minutu %d",h:"oras ida",hh:"oras %d",d:"loron ida",dd:"loron %d",M:"fulan ida",MM:"fulan %d",y:"tinan ida",yy:"tinan %d"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}});var Ma={0:"-\u0443\u043c",1:"-\u0443\u043c",2:"-\u044e\u043c",3:"-\u044e\u043c",4:"-\u0443\u043c",5:"-\u0443\u043c",6:"-\u0443\u043c",7:"-\u0443\u043c",8:"-\u0443\u043c",9:"-\u0443\u043c",10:"-\u0443\u043c",12:"-\u0443\u043c",13:"-\u0443\u043c",20:"-\u0443\u043c",30:"-\u044e\u043c",40:"-\u0443\u043c",50:"-\u0443\u043c",60:"-\u0443\u043c",70:"-\u0443\u043c",80:"-\u0443\u043c",90:"-\u0443\u043c",100:"-\u0443\u043c"};e.defineLocale("tg",{months:"\u044f\u043d\u0432\u0430\u0440_\u0444\u0435\u0432\u0440\u0430\u043b_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440_\u043e\u043a\u0442\u044f\u0431\u0440_\u043d\u043e\u044f\u0431\u0440_\u0434\u0435\u043a\u0430\u0431\u0440".split("_"),monthsShort:"\u044f\u043d\u0432_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433_\u0441\u0435\u043d_\u043e\u043a\u0442_\u043d\u043e\u044f_\u0434\u0435\u043a".split("_"),weekdays:"\u044f\u043a\u0448\u0430\u043d\u0431\u0435_\u0434\u0443\u0448\u0430\u043d\u0431\u0435_\u0441\u0435\u0448\u0430\u043d\u0431\u0435_\u0447\u043e\u0440\u0448\u0430\u043d\u0431\u0435_\u043f\u0430\u043d\u04b7\u0448\u0430\u043d\u0431\u0435_\u04b7\u0443\u043c\u044a\u0430_\u0448\u0430\u043d\u0431\u0435".split("_"),weekdaysShort:"\u044f\u0448\u0431_\u0434\u0448\u0431_\u0441\u0448\u0431_\u0447\u0448\u0431_\u043f\u0448\u0431_\u04b7\u0443\u043c_\u0448\u043d\u0431".split("_"),weekdaysMin:"\u044f\u0448_\u0434\u0448_\u0441\u0448_\u0447\u0448_\u043f\u0448_\u04b7\u043c_\u0448\u0431".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0418\u043c\u0440\u04ef\u0437 \u0441\u043e\u0430\u0442\u0438] LT",nextDay:"[\u041f\u0430\u0433\u043e\u04b3 \u0441\u043e\u0430\u0442\u0438] LT",lastDay:"[\u0414\u0438\u0440\u04ef\u0437 \u0441\u043e\u0430\u0442\u0438] LT",nextWeek:"dddd[\u0438] [\u04b3\u0430\u0444\u0442\u0430\u0438 \u043e\u044f\u043d\u0434\u0430 \u0441\u043e\u0430\u0442\u0438] LT",lastWeek:"dddd[\u0438] [\u04b3\u0430\u0444\u0442\u0430\u0438 \u0433\u0443\u0437\u0430\u0448\u0442\u0430 \u0441\u043e\u0430\u0442\u0438] LT",sameElse:"L"},relativeTime:{future:"\u0431\u0430\u044a\u0434\u0438 %s",past:"%s \u043f\u0435\u0448",s:"\u044f\u043a\u0447\u0430\u043d\u0434 \u0441\u043e\u043d\u0438\u044f",m:"\u044f\u043a \u0434\u0430\u049b\u0438\u049b\u0430",mm:"%d \u0434\u0430\u049b\u0438\u049b\u0430",h:"\u044f\u043a \u0441\u043e\u0430\u0442",hh:"%d \u0441\u043e\u0430\u0442",d:"\u044f\u043a \u0440\u04ef\u0437",dd:"%d \u0440\u04ef\u0437",M:"\u044f\u043a \u043c\u043e\u04b3",MM:"%d \u043c\u043e\u04b3",y:"\u044f\u043a \u0441\u043e\u043b",yy:"%d \u0441\u043e\u043b"},meridiemParse:/\u0448\u0430\u0431|\u0441\u0443\u0431\u04b3|\u0440\u04ef\u0437|\u0431\u0435\u0433\u043e\u04b3/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0448\u0430\u0431"===a?e<4?e:e+12:"\u0441\u0443\u0431\u04b3"===a?e:"\u0440\u04ef\u0437"===a?11<=e?e:e+12:"\u0431\u0435\u0433\u043e\u04b3"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0448\u0430\u0431":e<11?"\u0441\u0443\u0431\u04b3":e<16?"\u0440\u04ef\u0437":e<19?"\u0431\u0435\u0433\u043e\u04b3":"\u0448\u0430\u0431"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0443\u043c|\u044e\u043c)/,ordinal:function(e){return e+(Ma[e]||Ma[e%10]||Ma[100<=e?100:null])},week:{dow:1,doy:7}}),e.defineLocale("th",{months:"\u0e21\u0e01\u0e23\u0e32\u0e04\u0e21_\u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c_\u0e21\u0e35\u0e19\u0e32\u0e04\u0e21_\u0e40\u0e21\u0e29\u0e32\u0e22\u0e19_\u0e1e\u0e24\u0e29\u0e20\u0e32\u0e04\u0e21_\u0e21\u0e34\u0e16\u0e38\u0e19\u0e32\u0e22\u0e19_\u0e01\u0e23\u0e01\u0e0e\u0e32\u0e04\u0e21_\u0e2a\u0e34\u0e07\u0e2b\u0e32\u0e04\u0e21_\u0e01\u0e31\u0e19\u0e22\u0e32\u0e22\u0e19_\u0e15\u0e38\u0e25\u0e32\u0e04\u0e21_\u0e1e\u0e24\u0e28\u0e08\u0e34\u0e01\u0e32\u0e22\u0e19_\u0e18\u0e31\u0e19\u0e27\u0e32\u0e04\u0e21".split("_"),monthsShort:"\u0e21.\u0e04._\u0e01.\u0e1e._\u0e21\u0e35.\u0e04._\u0e40\u0e21.\u0e22._\u0e1e.\u0e04._\u0e21\u0e34.\u0e22._\u0e01.\u0e04._\u0e2a.\u0e04._\u0e01.\u0e22._\u0e15.\u0e04._\u0e1e.\u0e22._\u0e18.\u0e04.".split("_"),monthsParseExact:!0,weekdays:"\u0e2d\u0e32\u0e17\u0e34\u0e15\u0e22\u0e4c_\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c_\u0e2d\u0e31\u0e07\u0e04\u0e32\u0e23_\u0e1e\u0e38\u0e18_\u0e1e\u0e24\u0e2b\u0e31\u0e2a\u0e1a\u0e14\u0e35_\u0e28\u0e38\u0e01\u0e23\u0e4c_\u0e40\u0e2a\u0e32\u0e23\u0e4c".split("_"),weekdaysShort:"\u0e2d\u0e32\u0e17\u0e34\u0e15\u0e22\u0e4c_\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c_\u0e2d\u0e31\u0e07\u0e04\u0e32\u0e23_\u0e1e\u0e38\u0e18_\u0e1e\u0e24\u0e2b\u0e31\u0e2a_\u0e28\u0e38\u0e01\u0e23\u0e4c_\u0e40\u0e2a\u0e32\u0e23\u0e4c".split("_"),weekdaysMin:"\u0e2d\u0e32._\u0e08._\u0e2d._\u0e1e._\u0e1e\u0e24._\u0e28._\u0e2a.".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY \u0e40\u0e27\u0e25\u0e32 H:mm",LLLL:"\u0e27\u0e31\u0e19dddd\u0e17\u0e35\u0e48 D MMMM YYYY \u0e40\u0e27\u0e25\u0e32 H:mm"},meridiemParse:/\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07|\u0e2b\u0e25\u0e31\u0e07\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07/,isPM:function(e){return"\u0e2b\u0e25\u0e31\u0e07\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07"===e},meridiem:function(e,a,_){return e<12?"\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07":"\u0e2b\u0e25\u0e31\u0e07\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07"},calendar:{sameDay:"[\u0e27\u0e31\u0e19\u0e19\u0e35\u0e49 \u0e40\u0e27\u0e25\u0e32] LT",nextDay:"[\u0e1e\u0e23\u0e38\u0e48\u0e07\u0e19\u0e35\u0e49 \u0e40\u0e27\u0e25\u0e32] LT",nextWeek:"dddd[\u0e2b\u0e19\u0e49\u0e32 \u0e40\u0e27\u0e25\u0e32] LT",lastDay:"[\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e27\u0e32\u0e19\u0e19\u0e35\u0e49 \u0e40\u0e27\u0e25\u0e32] LT",lastWeek:"[\u0e27\u0e31\u0e19]dddd[\u0e17\u0e35\u0e48\u0e41\u0e25\u0e49\u0e27 \u0e40\u0e27\u0e25\u0e32] LT",sameElse:"L"},relativeTime:{future:"\u0e2d\u0e35\u0e01 %s",past:"%s\u0e17\u0e35\u0e48\u0e41\u0e25\u0e49\u0e27",s:"\u0e44\u0e21\u0e48\u0e01\u0e35\u0e48\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35",ss:"%d \u0e27\u0e34\u0e19\u0e32\u0e17\u0e35",m:"1 \u0e19\u0e32\u0e17\u0e35",mm:"%d \u0e19\u0e32\u0e17\u0e35",h:"1 \u0e0a\u0e31\u0e48\u0e27\u0e42\u0e21\u0e07",hh:"%d \u0e0a\u0e31\u0e48\u0e27\u0e42\u0e21\u0e07",d:"1 \u0e27\u0e31\u0e19",dd:"%d \u0e27\u0e31\u0e19",M:"1 \u0e40\u0e14\u0e37\u0e2d\u0e19",MM:"%d \u0e40\u0e14\u0e37\u0e2d\u0e19",y:"1 \u0e1b\u0e35",yy:"%d \u0e1b\u0e35"}}),e.defineLocale("tl-ph",{months:"Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),monthsShort:"Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),weekdays:"Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),weekdaysShort:"Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),weekdaysMin:"Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"MM/D/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY HH:mm",LLLL:"dddd, MMMM DD, YYYY HH:mm"},calendar:{sameDay:"LT [ngayong araw]",nextDay:"[Bukas ng] LT",nextWeek:"LT [sa susunod na] dddd",lastDay:"LT [kahapon]",lastWeek:"LT [noong nakaraang] dddd",sameElse:"L"},relativeTime:{future:"sa loob ng %s",past:"%s ang nakalipas",s:"ilang segundo",ss:"%d segundo",m:"isang minuto",mm:"%d minuto",h:"isang oras",hh:"%d oras",d:"isang araw",dd:"%d araw",M:"isang buwan",MM:"%d buwan",y:"isang taon",yy:"%d taon"},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:function(e){return e},week:{dow:1,doy:4}});var La="pagh_wa\u2019_cha\u2019_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");function Ya(e,a,_,s){var d=function(e){var a=Math.floor(e%1e3/100),_=Math.floor(e%100/10),s=e%10,d="";0<a&&(d+=La[a]+"vatlh");0<_&&(d+=(""!==d?" ":"")+La[_]+"maH");0<s&&(d+=(""!==d?" ":"")+La[s]);return""===d?"pagh":d}(e);switch(_){case"ss":return d+" lup";case"mm":return d+" tup";case"hh":return d+" rep";case"dd":return d+" jaj";case"MM":return d+" jar";case"yy":return d+" DIS"}}e.defineLocale("tlh",{months:"tera\u2019 jar wa\u2019_tera\u2019 jar cha\u2019_tera\u2019 jar wej_tera\u2019 jar loS_tera\u2019 jar vagh_tera\u2019 jar jav_tera\u2019 jar Soch_tera\u2019 jar chorgh_tera\u2019 jar Hut_tera\u2019 jar wa\u2019maH_tera\u2019 jar wa\u2019maH wa\u2019_tera\u2019 jar wa\u2019maH cha\u2019".split("_"),monthsShort:"jar wa\u2019_jar cha\u2019_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa\u2019maH_jar wa\u2019maH wa\u2019_jar wa\u2019maH cha\u2019".split("_"),monthsParseExact:!0,weekdays:"lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),weekdaysShort:"lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),weekdaysMin:"lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[DaHjaj] LT",nextDay:"[wa\u2019leS] LT",nextWeek:"LLL",lastDay:"[wa\u2019Hu\u2019] LT",lastWeek:"LLL",sameElse:"L"},relativeTime:{future:function(e){var a=e;return a=-1!==e.indexOf("jaj")?a.slice(0,-3)+"leS":-1!==e.indexOf("jar")?a.slice(0,-3)+"waQ":-1!==e.indexOf("DIS")?a.slice(0,-3)+"nem":a+" pIq"},past:function(e){var a=e;return a=-1!==e.indexOf("jaj")?a.slice(0,-3)+"Hu\u2019":-1!==e.indexOf("jar")?a.slice(0,-3)+"wen":-1!==e.indexOf("DIS")?a.slice(0,-3)+"ben":a+" ret"},s:"puS lup",ss:Ya,m:"wa\u2019 tup",mm:Ya,h:"wa\u2019 rep",hh:Ya,d:"wa\u2019 jaj",dd:Ya,M:"wa\u2019 jar",MM:Ya,y:"wa\u2019 DIS",yy:Ya},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var ha={1:"'inci",5:"'inci",8:"'inci",70:"'inci",80:"'inci",2:"'nci",7:"'nci",20:"'nci",50:"'nci",3:"'\xfcnc\xfc",4:"'\xfcnc\xfc",100:"'\xfcnc\xfc",6:"'nc\u0131",9:"'uncu",10:"'uncu",30:"'uncu",60:"'\u0131nc\u0131",90:"'\u0131nc\u0131"};function ya(e,a,_,s){var d={s:["viensas secunds","'iensas secunds"],ss:[e+" secunds",e+" secunds"],m:["'n m\xedut","'iens m\xedut"],mm:[e+" m\xeduts",e+" m\xeduts"],h:["'n \xfeora","'iensa \xfeora"],hh:[e+" \xfeoras",e+" \xfeoras"],d:["'n ziua","'iensa ziua"],dd:[e+" ziuas",e+" ziuas"],M:["'n mes","'iens mes"],MM:[e+" mesen",e+" mesen"],y:["'n ar","'iens ar"],yy:[e+" ars",e+" ars"]};return s?d[_][0]:a?d[_][0]:d[_][1]}function ca(e,a,_){var s,d;return"m"===_?a?"\u0445\u0432\u0438\u043b\u0438\u043d\u0430":"\u0445\u0432\u0438\u043b\u0438\u043d\u0443":"h"===_?a?"\u0433\u043e\u0434\u0438\u043d\u0430":"\u0433\u043e\u0434\u0438\u043d\u0443":e+" "+(s=+e,d={ss:a?"\u0441\u0435\u043a\u0443\u043d\u0434\u0430_\u0441\u0435\u043a\u0443\u043d\u0434\u0438_\u0441\u0435\u043a\u0443\u043d\u0434":"\u0441\u0435\u043a\u0443\u043d\u0434\u0443_\u0441\u0435\u043a\u0443\u043d\u0434\u0438_\u0441\u0435\u043a\u0443\u043d\u0434",mm:a?"\u0445\u0432\u0438\u043b\u0438\u043d\u0430_\u0445\u0432\u0438\u043b\u0438\u043d\u0438_\u0445\u0432\u0438\u043b\u0438\u043d":"\u0445\u0432\u0438\u043b\u0438\u043d\u0443_\u0445\u0432\u0438\u043b\u0438\u043d\u0438_\u0445\u0432\u0438\u043b\u0438\u043d",hh:a?"\u0433\u043e\u0434\u0438\u043d\u0430_\u0433\u043e\u0434\u0438\u043d\u0438_\u0433\u043e\u0434\u0438\u043d":"\u0433\u043e\u0434\u0438\u043d\u0443_\u0433\u043e\u0434\u0438\u043d\u0438_\u0433\u043e\u0434\u0438\u043d",dd:"\u0434\u0435\u043d\u044c_\u0434\u043d\u0456_\u0434\u043d\u0456\u0432",MM:"\u043c\u0456\u0441\u044f\u0446\u044c_\u043c\u0456\u0441\u044f\u0446\u0456_\u043c\u0456\u0441\u044f\u0446\u0456\u0432",yy:"\u0440\u0456\u043a_\u0440\u043e\u043a\u0438_\u0440\u043e\u043a\u0456\u0432"}[_].split("_"),s%10==1&&s%100!=11?d[0]:2<=s%10&&s%10<=4&&(s%100<10||20<=s%100)?d[1]:d[2])}function ka(e){return function(){return e+"\u043e"+(11===this.hours()?"\u0431":"")+"] LT"}}e.defineLocale("tr",{months:"Ocak_\u015eubat_Mart_Nisan_May\u0131s_Haziran_Temmuz_A\u011fustos_Eyl\xfcl_Ekim_Kas\u0131m_Aral\u0131k".split("_"),monthsShort:"Oca_\u015eub_Mar_Nis_May_Haz_Tem_A\u011fu_Eyl_Eki_Kas_Ara".split("_"),weekdays:"Pazar_Pazartesi_Sal\u0131_\xc7ar\u015famba_Per\u015fembe_Cuma_Cumartesi".split("_"),weekdaysShort:"Paz_Pts_Sal_\xc7ar_Per_Cum_Cts".split("_"),weekdaysMin:"Pz_Pt_Sa_\xc7a_Pe_Cu_Ct".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[bug\xfcn saat] LT",nextDay:"[yar\u0131n saat] LT",nextWeek:"[gelecek] dddd [saat] LT",lastDay:"[d\xfcn] LT",lastWeek:"[ge\xe7en] dddd [saat] LT",sameElse:"L"},relativeTime:{future:"%s sonra",past:"%s \xf6nce",s:"birka\xe7 saniye",ss:"%d saniye",m:"bir dakika",mm:"%d dakika",h:"bir saat",hh:"%d saat",d:"bir g\xfcn",dd:"%d g\xfcn",M:"bir ay",MM:"%d ay",y:"bir y\u0131l",yy:"%d y\u0131l"},ordinal:function(e,a){switch(a){case"d":case"D":case"Do":case"DD":return e;default:if(0===e)return e+"'\u0131nc\u0131";var _=e%10;return e+(ha[_]||ha[e%100-_]||ha[100<=e?100:null])}},week:{dow:1,doy:7}}),e.defineLocale("tzl",{months:"Januar_Fevraglh_Mar\xe7_Avr\xefu_Mai_G\xfcn_Julia_Guscht_Setemvar_Listop\xe4ts_Noemvar_Zecemvar".split("_"),monthsShort:"Jan_Fev_Mar_Avr_Mai_G\xfcn_Jul_Gus_Set_Lis_Noe_Zec".split("_"),weekdays:"S\xfaladi_L\xfane\xe7i_Maitzi_M\xe1rcuri_Xh\xfaadi_Vi\xe9ner\xe7i_S\xe1turi".split("_"),weekdaysShort:"S\xfal_L\xfan_Mai_M\xe1r_Xh\xfa_Vi\xe9_S\xe1t".split("_"),weekdaysMin:"S\xfa_L\xfa_Ma_M\xe1_Xh_Vi_S\xe1".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD.MM.YYYY",LL:"D. MMMM [dallas] YYYY",LLL:"D. MMMM [dallas] YYYY HH.mm",LLLL:"dddd, [li] D. MMMM [dallas] YYYY HH.mm"},meridiemParse:/d\'o|d\'a/i,isPM:function(e){return"d'o"===e.toLowerCase()},meridiem:function(e,a,_){return 11<e?_?"d'o":"D'O":_?"d'a":"D'A"},calendar:{sameDay:"[oxhi \xe0] LT",nextDay:"[dem\xe0 \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[ieiri \xe0] LT",lastWeek:"[s\xfcr el] dddd [lasteu \xe0] LT",sameElse:"L"},relativeTime:{future:"osprei %s",past:"ja%s",s:ya,ss:ya,m:ya,mm:ya,h:ya,hh:ya,d:ya,dd:ya,M:ya,MM:ya,y:ya,yy:ya},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("tzm-latn",{months:"innayr_br\u02e4ayr\u02e4_mar\u02e4s\u02e4_ibrir_mayyw_ywnyw_ywlywz_\u0263w\u0161t_\u0161wtanbir_kt\u02e4wbr\u02e4_nwwanbir_dwjnbir".split("_"),monthsShort:"innayr_br\u02e4ayr\u02e4_mar\u02e4s\u02e4_ibrir_mayyw_ywnyw_ywlywz_\u0263w\u0161t_\u0161wtanbir_kt\u02e4wbr\u02e4_nwwanbir_dwjnbir".split("_"),weekdays:"asamas_aynas_asinas_akras_akwas_asimwas_asi\u1e0dyas".split("_"),weekdaysShort:"asamas_aynas_asinas_akras_akwas_asimwas_asi\u1e0dyas".split("_"),weekdaysMin:"asamas_aynas_asinas_akras_akwas_asimwas_asi\u1e0dyas".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[asdkh g] LT",nextDay:"[aska g] LT",nextWeek:"dddd [g] LT",lastDay:"[assant g] LT",lastWeek:"dddd [g] LT",sameElse:"L"},relativeTime:{future:"dadkh s yan %s",past:"yan %s",s:"imik",ss:"%d imik",m:"minu\u1e0d",mm:"%d minu\u1e0d",h:"sa\u025ba",hh:"%d tassa\u025bin",d:"ass",dd:"%d ossan",M:"ayowr",MM:"%d iyyirn",y:"asgas",yy:"%d isgasn"},week:{dow:6,doy:12}}),e.defineLocale("tzm",{months:"\u2d49\u2d4f\u2d4f\u2d30\u2d62\u2d54_\u2d31\u2d55\u2d30\u2d62\u2d55_\u2d4e\u2d30\u2d55\u2d5a_\u2d49\u2d31\u2d54\u2d49\u2d54_\u2d4e\u2d30\u2d62\u2d62\u2d53_\u2d62\u2d53\u2d4f\u2d62\u2d53_\u2d62\u2d53\u2d4d\u2d62\u2d53\u2d63_\u2d56\u2d53\u2d5b\u2d5c_\u2d5b\u2d53\u2d5c\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d3d\u2d5f\u2d53\u2d31\u2d55_\u2d4f\u2d53\u2d61\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d37\u2d53\u2d4a\u2d4f\u2d31\u2d49\u2d54".split("_"),monthsShort:"\u2d49\u2d4f\u2d4f\u2d30\u2d62\u2d54_\u2d31\u2d55\u2d30\u2d62\u2d55_\u2d4e\u2d30\u2d55\u2d5a_\u2d49\u2d31\u2d54\u2d49\u2d54_\u2d4e\u2d30\u2d62\u2d62\u2d53_\u2d62\u2d53\u2d4f\u2d62\u2d53_\u2d62\u2d53\u2d4d\u2d62\u2d53\u2d63_\u2d56\u2d53\u2d5b\u2d5c_\u2d5b\u2d53\u2d5c\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d3d\u2d5f\u2d53\u2d31\u2d55_\u2d4f\u2d53\u2d61\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d37\u2d53\u2d4a\u2d4f\u2d31\u2d49\u2d54".split("_"),weekdays:"\u2d30\u2d59\u2d30\u2d4e\u2d30\u2d59_\u2d30\u2d62\u2d4f\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4f\u2d30\u2d59_\u2d30\u2d3d\u2d54\u2d30\u2d59_\u2d30\u2d3d\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4e\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d39\u2d62\u2d30\u2d59".split("_"),weekdaysShort:"\u2d30\u2d59\u2d30\u2d4e\u2d30\u2d59_\u2d30\u2d62\u2d4f\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4f\u2d30\u2d59_\u2d30\u2d3d\u2d54\u2d30\u2d59_\u2d30\u2d3d\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4e\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d39\u2d62\u2d30\u2d59".split("_"),weekdaysMin:"\u2d30\u2d59\u2d30\u2d4e\u2d30\u2d59_\u2d30\u2d62\u2d4f\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4f\u2d30\u2d59_\u2d30\u2d3d\u2d54\u2d30\u2d59_\u2d30\u2d3d\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4e\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d39\u2d62\u2d30\u2d59".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u2d30\u2d59\u2d37\u2d45 \u2d34] LT",nextDay:"[\u2d30\u2d59\u2d3d\u2d30 \u2d34] LT",nextWeek:"dddd [\u2d34] LT",lastDay:"[\u2d30\u2d5a\u2d30\u2d4f\u2d5c \u2d34] LT",lastWeek:"dddd [\u2d34] LT",sameElse:"L"},relativeTime:{future:"\u2d37\u2d30\u2d37\u2d45 \u2d59 \u2d62\u2d30\u2d4f %s",past:"\u2d62\u2d30\u2d4f %s",s:"\u2d49\u2d4e\u2d49\u2d3d",ss:"%d \u2d49\u2d4e\u2d49\u2d3d",m:"\u2d4e\u2d49\u2d4f\u2d53\u2d3a",mm:"%d \u2d4e\u2d49\u2d4f\u2d53\u2d3a",h:"\u2d59\u2d30\u2d44\u2d30",hh:"%d \u2d5c\u2d30\u2d59\u2d59\u2d30\u2d44\u2d49\u2d4f",d:"\u2d30\u2d59\u2d59",dd:"%d o\u2d59\u2d59\u2d30\u2d4f",M:"\u2d30\u2d62o\u2d53\u2d54",MM:"%d \u2d49\u2d62\u2d62\u2d49\u2d54\u2d4f",y:"\u2d30\u2d59\u2d33\u2d30\u2d59",yy:"%d \u2d49\u2d59\u2d33\u2d30\u2d59\u2d4f"},week:{dow:6,doy:12}}),e.defineLocale("ug-cn",{months:"\u064a\u0627\u0646\u06cb\u0627\u0631_\u0641\u06d0\u06cb\u0631\u0627\u0644_\u0645\u0627\u0631\u062a_\u0626\u0627\u067e\u0631\u06d0\u0644_\u0645\u0627\u064a_\u0626\u0649\u064a\u06c7\u0646_\u0626\u0649\u064a\u06c7\u0644_\u0626\u0627\u06cb\u063a\u06c7\u0633\u062a_\u0633\u06d0\u0646\u062a\u06d5\u0628\u0649\u0631_\u0626\u06c6\u0643\u062a\u06d5\u0628\u0649\u0631_\u0646\u0648\u064a\u0627\u0628\u0649\u0631_\u062f\u06d0\u0643\u0627\u0628\u0649\u0631".split("_"),monthsShort:"\u064a\u0627\u0646\u06cb\u0627\u0631_\u0641\u06d0\u06cb\u0631\u0627\u0644_\u0645\u0627\u0631\u062a_\u0626\u0627\u067e\u0631\u06d0\u0644_\u0645\u0627\u064a_\u0626\u0649\u064a\u06c7\u0646_\u0626\u0649\u064a\u06c7\u0644_\u0626\u0627\u06cb\u063a\u06c7\u0633\u062a_\u0633\u06d0\u0646\u062a\u06d5\u0628\u0649\u0631_\u0626\u06c6\u0643\u062a\u06d5\u0628\u0649\u0631_\u0646\u0648\u064a\u0627\u0628\u0649\u0631_\u062f\u06d0\u0643\u0627\u0628\u0649\u0631".split("_"),weekdays:"\u064a\u06d5\u0643\u0634\u06d5\u0646\u0628\u06d5_\u062f\u06c8\u0634\u06d5\u0646\u0628\u06d5_\u0633\u06d5\u064a\u0634\u06d5\u0646\u0628\u06d5_\u0686\u0627\u0631\u0634\u06d5\u0646\u0628\u06d5_\u067e\u06d5\u064a\u0634\u06d5\u0646\u0628\u06d5_\u062c\u06c8\u0645\u06d5_\u0634\u06d5\u0646\u0628\u06d5".split("_"),weekdaysShort:"\u064a\u06d5_\u062f\u06c8_\u0633\u06d5_\u0686\u0627_\u067e\u06d5_\u062c\u06c8_\u0634\u06d5".split("_"),weekdaysMin:"\u064a\u06d5_\u062f\u06c8_\u0633\u06d5_\u0686\u0627_\u067e\u06d5_\u062c\u06c8_\u0634\u06d5".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY-\u064a\u0649\u0644\u0649M-\u0626\u0627\u064a\u0646\u0649\u06adD-\u0643\u06c8\u0646\u0649",LLL:"YYYY-\u064a\u0649\u0644\u0649M-\u0626\u0627\u064a\u0646\u0649\u06adD-\u0643\u06c8\u0646\u0649\u060c HH:mm",LLLL:"dddd\u060c YYYY-\u064a\u0649\u0644\u0649M-\u0626\u0627\u064a\u0646\u0649\u06adD-\u0643\u06c8\u0646\u0649\u060c HH:mm"},meridiemParse:/\u064a\u06d0\u0631\u0649\u0645 \u0643\u06d0\u0686\u06d5|\u0633\u06d5\u06be\u06d5\u0631|\u0686\u06c8\u0634\u062a\u0649\u0646 \u0628\u06c7\u0631\u06c7\u0646|\u0686\u06c8\u0634|\u0686\u06c8\u0634\u062a\u0649\u0646 \u0643\u06d0\u064a\u0649\u0646|\u0643\u06d5\u0686/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u064a\u06d0\u0631\u0649\u0645 \u0643\u06d0\u0686\u06d5"===a||"\u0633\u06d5\u06be\u06d5\u0631"===a||"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0628\u06c7\u0631\u06c7\u0646"===a?e:"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0643\u06d0\u064a\u0649\u0646"===a||"\u0643\u06d5\u0686"===a?e+12:11<=e?e:e+12},meridiem:function(e,a,_){var s=100*e+a;return s<600?"\u064a\u06d0\u0631\u0649\u0645 \u0643\u06d0\u0686\u06d5":s<900?"\u0633\u06d5\u06be\u06d5\u0631":s<1130?"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0628\u06c7\u0631\u06c7\u0646":s<1230?"\u0686\u06c8\u0634":s<1800?"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0643\u06d0\u064a\u0649\u0646":"\u0643\u06d5\u0686"},calendar:{sameDay:"[\u0628\u06c8\u06af\u06c8\u0646 \u0633\u0627\u0626\u06d5\u062a] LT",nextDay:"[\u0626\u06d5\u062a\u06d5 \u0633\u0627\u0626\u06d5\u062a] LT",nextWeek:"[\u0643\u06d0\u0644\u06d5\u0631\u0643\u0649] dddd [\u0633\u0627\u0626\u06d5\u062a] LT",lastDay:"[\u062a\u06c6\u0646\u06c8\u06af\u06c8\u0646] LT",lastWeek:"[\u0626\u0627\u0644\u062f\u0649\u0646\u0642\u0649] dddd [\u0633\u0627\u0626\u06d5\u062a] LT",sameElse:"L"},relativeTime:{future:"%s \u0643\u06d0\u064a\u0649\u0646",past:"%s \u0628\u06c7\u0631\u06c7\u0646",s:"\u0646\u06d5\u0686\u0686\u06d5 \u0633\u06d0\u0643\u0648\u0646\u062a",ss:"%d \u0633\u06d0\u0643\u0648\u0646\u062a",m:"\u0628\u0649\u0631 \u0645\u0649\u0646\u06c7\u062a",mm:"%d \u0645\u0649\u0646\u06c7\u062a",h:"\u0628\u0649\u0631 \u0633\u0627\u0626\u06d5\u062a",hh:"%d \u0633\u0627\u0626\u06d5\u062a",d:"\u0628\u0649\u0631 \u0643\u06c8\u0646",dd:"%d \u0643\u06c8\u0646",M:"\u0628\u0649\u0631 \u0626\u0627\u064a",MM:"%d \u0626\u0627\u064a",y:"\u0628\u0649\u0631 \u064a\u0649\u0644",yy:"%d \u064a\u0649\u0644"},dayOfMonthOrdinalParse:/\d{1,2}(-\u0643\u06c8\u0646\u0649|-\u0626\u0627\u064a|-\u06be\u06d5\u067e\u062a\u06d5)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"-\u0643\u06c8\u0646\u0649";case"w":case"W":return e+"-\u06be\u06d5\u067e\u062a\u06d5";default:return e}},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:1,doy:7}}),e.defineLocale("uk",{months:{format:"\u0441\u0456\u0447\u043d\u044f_\u043b\u044e\u0442\u043e\u0433\u043e_\u0431\u0435\u0440\u0435\u0437\u043d\u044f_\u043a\u0432\u0456\u0442\u043d\u044f_\u0442\u0440\u0430\u0432\u043d\u044f_\u0447\u0435\u0440\u0432\u043d\u044f_\u043b\u0438\u043f\u043d\u044f_\u0441\u0435\u0440\u043f\u043d\u044f_\u0432\u0435\u0440\u0435\u0441\u043d\u044f_\u0436\u043e\u0432\u0442\u043d\u044f_\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434\u0430_\u0433\u0440\u0443\u0434\u043d\u044f".split("_"),standalone:"\u0441\u0456\u0447\u0435\u043d\u044c_\u043b\u044e\u0442\u0438\u0439_\u0431\u0435\u0440\u0435\u0437\u0435\u043d\u044c_\u043a\u0432\u0456\u0442\u0435\u043d\u044c_\u0442\u0440\u0430\u0432\u0435\u043d\u044c_\u0447\u0435\u0440\u0432\u0435\u043d\u044c_\u043b\u0438\u043f\u0435\u043d\u044c_\u0441\u0435\u0440\u043f\u0435\u043d\u044c_\u0432\u0435\u0440\u0435\u0441\u0435\u043d\u044c_\u0436\u043e\u0432\u0442\u0435\u043d\u044c_\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434_\u0433\u0440\u0443\u0434\u0435\u043d\u044c".split("_")},monthsShort:"\u0441\u0456\u0447_\u043b\u044e\u0442_\u0431\u0435\u0440_\u043a\u0432\u0456\u0442_\u0442\u0440\u0430\u0432_\u0447\u0435\u0440\u0432_\u043b\u0438\u043f_\u0441\u0435\u0440\u043f_\u0432\u0435\u0440_\u0436\u043e\u0432\u0442_\u043b\u0438\u0441\u0442_\u0433\u0440\u0443\u0434".split("_"),weekdays:function(e,a){var _={nominative:"\u043d\u0435\u0434\u0456\u043b\u044f_\u043f\u043e\u043d\u0435\u0434\u0456\u043b\u043e\u043a_\u0432\u0456\u0432\u0442\u043e\u0440\u043e\u043a_\u0441\u0435\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0435\u0440_\u043f\u2019\u044f\u0442\u043d\u0438\u0446\u044f_\u0441\u0443\u0431\u043e\u0442\u0430".split("_"),accusative:"\u043d\u0435\u0434\u0456\u043b\u044e_\u043f\u043e\u043d\u0435\u0434\u0456\u043b\u043e\u043a_\u0432\u0456\u0432\u0442\u043e\u0440\u043e\u043a_\u0441\u0435\u0440\u0435\u0434\u0443_\u0447\u0435\u0442\u0432\u0435\u0440_\u043f\u2019\u044f\u0442\u043d\u0438\u0446\u044e_\u0441\u0443\u0431\u043e\u0442\u0443".split("_"),genitive:"\u043d\u0435\u0434\u0456\u043b\u0456_\u043f\u043e\u043d\u0435\u0434\u0456\u043b\u043a\u0430_\u0432\u0456\u0432\u0442\u043e\u0440\u043a\u0430_\u0441\u0435\u0440\u0435\u0434\u0438_\u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0430_\u043f\u2019\u044f\u0442\u043d\u0438\u0446\u0456_\u0441\u0443\u0431\u043e\u0442\u0438".split("_")};return!0===e?_.nominative.slice(1,7).concat(_.nominative.slice(0,1)):e?_[/(\[[\u0412\u0432\u0423\u0443]\]) ?dddd/.test(a)?"accusative":/\[?(?:\u043c\u0438\u043d\u0443\u043b\u043e\u0457|\u043d\u0430\u0441\u0442\u0443\u043f\u043d\u043e\u0457)? ?\] ?dddd/.test(a)?"genitive":"nominative"][e.day()]:_.nominative},weekdaysShort:"\u043d\u0434_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),weekdaysMin:"\u043d\u0434_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0440.",LLL:"D MMMM YYYY \u0440., HH:mm",LLLL:"dddd, D MMMM YYYY \u0440., HH:mm"},calendar:{sameDay:ka("[\u0421\u044c\u043e\u0433\u043e\u0434\u043d\u0456 "),nextDay:ka("[\u0417\u0430\u0432\u0442\u0440\u0430 "),lastDay:ka("[\u0412\u0447\u043e\u0440\u0430 "),nextWeek:ka("[\u0423] dddd ["),lastWeek:function(){switch(this.day()){case 0:case 3:case 5:case 6:return ka("[\u041c\u0438\u043d\u0443\u043b\u043e\u0457] dddd [").call(this);case 1:case 2:case 4:return ka("[\u041c\u0438\u043d\u0443\u043b\u043e\u0433\u043e] dddd [").call(this)}},sameElse:"L"},relativeTime:{future:"\u0437\u0430 %s",past:"%s \u0442\u043e\u043c\u0443",s:"\u0434\u0435\u043a\u0456\u043b\u044c\u043a\u0430 \u0441\u0435\u043a\u0443\u043d\u0434",ss:ca,m:ca,mm:ca,h:"\u0433\u043e\u0434\u0438\u043d\u0443",hh:ca,d:"\u0434\u0435\u043d\u044c",dd:ca,M:"\u043c\u0456\u0441\u044f\u0446\u044c",MM:ca,y:"\u0440\u0456\u043a",yy:ca},meridiemParse:/\u043d\u043e\u0447\u0456|\u0440\u0430\u043d\u043a\u0443|\u0434\u043d\u044f|\u0432\u0435\u0447\u043e\u0440\u0430/,isPM:function(e){return/^(\u0434\u043d\u044f|\u0432\u0435\u0447\u043e\u0440\u0430)$/.test(e)},meridiem:function(e,a,_){return e<4?"\u043d\u043e\u0447\u0456":e<12?"\u0440\u0430\u043d\u043a\u0443":e<17?"\u0434\u043d\u044f":"\u0432\u0435\u0447\u043e\u0440\u0430"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0439|\u0433\u043e)/,ordinal:function(e,a){switch(a){case"M":case"d":case"DDD":case"w":case"W":return e+"-\u0439";case"D":return e+"-\u0433\u043e";default:return e}},week:{dow:1,doy:7}});var pa=["\u062c\u0646\u0648\u0631\u06cc","\u0641\u0631\u0648\u0631\u06cc","\u0645\u0627\u0631\u0686","\u0627\u067e\u0631\u06cc\u0644","\u0645\u0626\u06cc","\u062c\u0648\u0646","\u062c\u0648\u0644\u0627\u0626\u06cc","\u0627\u06af\u0633\u062a","\u0633\u062a\u0645\u0628\u0631","\u0627\u06a9\u062a\u0648\u0628\u0631","\u0646\u0648\u0645\u0628\u0631","\u062f\u0633\u0645\u0628\u0631"],Da=["\u0627\u062a\u0648\u0627\u0631","\u067e\u06cc\u0631","\u0645\u0646\u06af\u0644","\u0628\u062f\u06be","\u062c\u0645\u0639\u0631\u0627\u062a","\u062c\u0645\u0639\u06c1","\u06c1\u0641\u062a\u06c1"];return e.defineLocale("ur",{months:pa,monthsShort:pa,weekdays:Da,weekdaysShort:Da,weekdaysMin:Da,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd\u060c D MMMM YYYY HH:mm"},meridiemParse:/\u0635\u0628\u062d|\u0634\u0627\u0645/,isPM:function(e){return"\u0634\u0627\u0645"===e},meridiem:function(e,a,_){return e<12?"\u0635\u0628\u062d":"\u0634\u0627\u0645"},calendar:{sameDay:"[\u0622\u062c \u0628\u0648\u0642\u062a] LT",nextDay:"[\u06a9\u0644 \u0628\u0648\u0642\u062a] LT",nextWeek:"dddd [\u0628\u0648\u0642\u062a] LT",lastDay:"[\u06af\u0630\u0634\u062a\u06c1 \u0631\u0648\u0632 \u0628\u0648\u0642\u062a] LT",lastWeek:"[\u06af\u0630\u0634\u062a\u06c1] dddd [\u0628\u0648\u0642\u062a] LT",sameElse:"L"},relativeTime:{future:"%s \u0628\u0639\u062f",past:"%s \u0642\u0628\u0644",s:"\u0686\u0646\u062f \u0633\u06cc\u06a9\u0646\u0688",ss:"%d \u0633\u06cc\u06a9\u0646\u0688",m:"\u0627\u06cc\u06a9 \u0645\u0646\u0679",mm:"%d \u0645\u0646\u0679",h:"\u0627\u06cc\u06a9 \u06af\u06be\u0646\u0679\u06c1",hh:"%d \u06af\u06be\u0646\u0679\u06d2",d:"\u0627\u06cc\u06a9 \u062f\u0646",dd:"%d \u062f\u0646",M:"\u0627\u06cc\u06a9 \u0645\u0627\u06c1",MM:"%d \u0645\u0627\u06c1",y:"\u0627\u06cc\u06a9 \u0633\u0627\u0644",yy:"%d \u0633\u0627\u0644"},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:1,doy:4}}),e.defineLocale("uz-latn",{months:"Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"),monthsShort:"Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),weekdays:"Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"),weekdaysShort:"Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),weekdaysMin:"Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"D MMMM YYYY, dddd HH:mm"},calendar:{sameDay:"[Bugun soat] LT [da]",nextDay:"[Ertaga] LT [da]",nextWeek:"dddd [kuni soat] LT [da]",lastDay:"[Kecha soat] LT [da]",lastWeek:"[O'tgan] dddd [kuni soat] LT [da]",sameElse:"L"},relativeTime:{future:"Yaqin %s ichida",past:"Bir necha %s oldin",s:"soniya",ss:"%d soniya",m:"bir daqiqa",mm:"%d daqiqa",h:"bir soat",hh:"%d soat",d:"bir kun",dd:"%d kun",M:"bir oy",MM:"%d oy",y:"bir yil",yy:"%d yil"},week:{dow:1,doy:7}}),e.defineLocale("uz",{months:"\u044f\u043d\u0432\u0430\u0440_\u0444\u0435\u0432\u0440\u0430\u043b_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440_\u043e\u043a\u0442\u044f\u0431\u0440_\u043d\u043e\u044f\u0431\u0440_\u0434\u0435\u043a\u0430\u0431\u0440".split("_"),monthsShort:"\u044f\u043d\u0432_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433_\u0441\u0435\u043d_\u043e\u043a\u0442_\u043d\u043e\u044f_\u0434\u0435\u043a".split("_"),weekdays:"\u042f\u043a\u0448\u0430\u043d\u0431\u0430_\u0414\u0443\u0448\u0430\u043d\u0431\u0430_\u0421\u0435\u0448\u0430\u043d\u0431\u0430_\u0427\u043e\u0440\u0448\u0430\u043d\u0431\u0430_\u041f\u0430\u0439\u0448\u0430\u043d\u0431\u0430_\u0416\u0443\u043c\u0430_\u0428\u0430\u043d\u0431\u0430".split("_"),weekdaysShort:"\u042f\u043a\u0448_\u0414\u0443\u0448_\u0421\u0435\u0448_\u0427\u043e\u0440_\u041f\u0430\u0439_\u0416\u0443\u043c_\u0428\u0430\u043d".split("_"),weekdaysMin:"\u042f\u043a_\u0414\u0443_\u0421\u0435_\u0427\u043e_\u041f\u0430_\u0416\u0443_\u0428\u0430".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"D MMMM YYYY, dddd HH:mm"},calendar:{sameDay:"[\u0411\u0443\u0433\u0443\u043d \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",nextDay:"[\u042d\u0440\u0442\u0430\u0433\u0430] LT [\u0434\u0430]",nextWeek:"dddd [\u043a\u0443\u043d\u0438 \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",lastDay:"[\u041a\u0435\u0447\u0430 \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",lastWeek:"[\u0423\u0442\u0433\u0430\u043d] dddd [\u043a\u0443\u043d\u0438 \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",sameElse:"L"},relativeTime:{future:"\u042f\u043a\u0438\u043d %s \u0438\u0447\u0438\u0434\u0430",past:"\u0411\u0438\u0440 \u043d\u0435\u0447\u0430 %s \u043e\u043b\u0434\u0438\u043d",s:"\u0444\u0443\u0440\u0441\u0430\u0442",ss:"%d \u0444\u0443\u0440\u0441\u0430\u0442",m:"\u0431\u0438\u0440 \u0434\u0430\u043a\u0438\u043a\u0430",mm:"%d \u0434\u0430\u043a\u0438\u043a\u0430",h:"\u0431\u0438\u0440 \u0441\u043e\u0430\u0442",hh:"%d \u0441\u043e\u0430\u0442",d:"\u0431\u0438\u0440 \u043a\u0443\u043d",dd:"%d \u043a\u0443\u043d",M:"\u0431\u0438\u0440 \u043e\u0439",MM:"%d \u043e\u0439",y:"\u0431\u0438\u0440 \u0439\u0438\u043b",yy:"%d \u0439\u0438\u043b"},week:{dow:1,doy:7}}),e.defineLocale("vi",{months:"th\xe1ng 1_th\xe1ng 2_th\xe1ng 3_th\xe1ng 4_th\xe1ng 5_th\xe1ng 6_th\xe1ng 7_th\xe1ng 8_th\xe1ng 9_th\xe1ng 10_th\xe1ng 11_th\xe1ng 12".split("_"),monthsShort:"Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12".split("_"),monthsParseExact:!0,weekdays:"ch\u1ee7 nh\u1eadt_th\u1ee9 hai_th\u1ee9 ba_th\u1ee9 t\u01b0_th\u1ee9 n\u0103m_th\u1ee9 s\xe1u_th\u1ee9 b\u1ea3y".split("_"),weekdaysShort:"CN_T2_T3_T4_T5_T6_T7".split("_"),weekdaysMin:"CN_T2_T3_T4_T5_T6_T7".split("_"),weekdaysParseExact:!0,meridiemParse:/sa|ch/i,isPM:function(e){return/^ch$/i.test(e)},meridiem:function(e,a,_){return e<12?_?"sa":"SA":_?"ch":"CH"},longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM [n\u0103m] YYYY",LLL:"D MMMM [n\u0103m] YYYY HH:mm",LLLL:"dddd, D MMMM [n\u0103m] YYYY HH:mm",l:"DD/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"},calendar:{sameDay:"[H\xf4m nay l\xfac] LT",nextDay:"[Ng\xe0y mai l\xfac] LT",nextWeek:"dddd [tu\u1ea7n t\u1edbi l\xfac] LT",lastDay:"[H\xf4m qua l\xfac] LT",lastWeek:"dddd [tu\u1ea7n r\u1ed3i l\xfac] LT",sameElse:"L"},relativeTime:{future:"%s t\u1edbi",past:"%s tr\u01b0\u1edbc",s:"v\xe0i gi\xe2y",ss:"%d gi\xe2y",m:"m\u1ed9t ph\xfat",mm:"%d ph\xfat",h:"m\u1ed9t gi\u1edd",hh:"%d gi\u1edd",d:"m\u1ed9t ng\xe0y",dd:"%d ng\xe0y",M:"m\u1ed9t th\xe1ng",MM:"%d th\xe1ng",y:"m\u1ed9t n\u0103m",yy:"%d n\u0103m"},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:function(e){return e},week:{dow:1,doy:4}}),e.defineLocale("x-pseudo",{months:"J~\xe1\xf1\xfa\xe1~r\xfd_F~\xe9br\xfa~\xe1r\xfd_~M\xe1rc~h_\xc1p~r\xedl_~M\xe1\xfd_~J\xfa\xf1\xe9~_J\xfal~\xfd_\xc1\xfa~g\xfast~_S\xe9p~t\xe9mb~\xe9r_\xd3~ct\xf3b~\xe9r_\xd1~\xf3v\xe9m~b\xe9r_~D\xe9c\xe9~mb\xe9r".split("_"),monthsShort:"J~\xe1\xf1_~F\xe9b_~M\xe1r_~\xc1pr_~M\xe1\xfd_~J\xfa\xf1_~J\xfal_~\xc1\xfag_~S\xe9p_~\xd3ct_~\xd1\xf3v_~D\xe9c".split("_"),monthsParseExact:!0,weekdays:"S~\xfa\xf1d\xe1~\xfd_M\xf3~\xf1d\xe1\xfd~_T\xfa\xe9~sd\xe1\xfd~_W\xe9d~\xf1\xe9sd~\xe1\xfd_T~h\xfars~d\xe1\xfd_~Fr\xedd~\xe1\xfd_S~\xe1t\xfar~d\xe1\xfd".split("_"),weekdaysShort:"S~\xfa\xf1_~M\xf3\xf1_~T\xfa\xe9_~W\xe9d_~Th\xfa_~Fr\xed_~S\xe1t".split("_"),weekdaysMin:"S~\xfa_M\xf3~_T\xfa_~W\xe9_T~h_Fr~_S\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[T~\xf3d\xe1~\xfd \xe1t] LT",nextDay:"[T~\xf3m\xf3~rr\xf3~w \xe1t] LT",nextWeek:"dddd [\xe1t] LT",lastDay:"[\xdd~\xe9st~\xe9rd\xe1~\xfd \xe1t] LT",lastWeek:"[L~\xe1st] dddd [\xe1t] LT",sameElse:"L"},relativeTime:{future:"\xed~\xf1 %s",past:"%s \xe1~g\xf3",s:"\xe1 ~f\xe9w ~s\xe9c\xf3~\xf1ds",ss:"%d s~\xe9c\xf3\xf1~ds",m:"\xe1 ~m\xed\xf1~\xfat\xe9",mm:"%d m~\xed\xf1\xfa~t\xe9s",h:"\xe1~\xf1 h\xf3~\xfar",hh:"%d h~\xf3\xfars",d:"\xe1 ~d\xe1\xfd",dd:"%d d~\xe1\xfds",M:"\xe1 ~m\xf3\xf1~th",MM:"%d m~\xf3\xf1t~hs",y:"\xe1 ~\xfd\xe9\xe1r",yy:"%d \xfd~\xe9\xe1rs"},dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}}),e.defineLocale("yo",{months:"S\u1eb9\u0301r\u1eb9\u0301_E\u0300re\u0300le\u0300_\u1eb8r\u1eb9\u0300na\u0300_I\u0300gbe\u0301_E\u0300bibi_O\u0300ku\u0300du_Ag\u1eb9mo_O\u0300gu\u0301n_Owewe_\u1ecc\u0300wa\u0300ra\u0300_Be\u0301lu\u0301_\u1ecc\u0300p\u1eb9\u0300\u0300".split("_"),monthsShort:"S\u1eb9\u0301r_E\u0300rl_\u1eb8rn_I\u0300gb_E\u0300bi_O\u0300ku\u0300_Ag\u1eb9_O\u0300gu\u0301_Owe_\u1ecc\u0300wa\u0300_Be\u0301l_\u1ecc\u0300p\u1eb9\u0300\u0300".split("_"),weekdays:"A\u0300i\u0300ku\u0301_Aje\u0301_I\u0300s\u1eb9\u0301gun_\u1eccj\u1ecd\u0301ru\u0301_\u1eccj\u1ecd\u0301b\u1ecd_\u1eb8ti\u0300_A\u0300ba\u0301m\u1eb9\u0301ta".split("_"),weekdaysShort:"A\u0300i\u0300k_Aje\u0301_I\u0300s\u1eb9\u0301_\u1eccjr_\u1eccjb_\u1eb8ti\u0300_A\u0300ba\u0301".split("_"),weekdaysMin:"A\u0300i\u0300_Aj_I\u0300s_\u1eccr_\u1eccb_\u1eb8t_A\u0300b".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[O\u0300ni\u0300 ni] LT",nextDay:"[\u1ecc\u0300la ni] LT",nextWeek:"dddd [\u1eccs\u1eb9\u0300 to\u0301n'b\u1ecd] [ni] LT",lastDay:"[A\u0300na ni] LT",lastWeek:"dddd [\u1eccs\u1eb9\u0300 to\u0301l\u1ecd\u0301] [ni] LT",sameElse:"L"},relativeTime:{future:"ni\u0301 %s",past:"%s k\u1ecdja\u0301",s:"i\u0300s\u1eb9ju\u0301 aaya\u0301 die",ss:"aaya\u0301 %d",m:"i\u0300s\u1eb9ju\u0301 kan",mm:"i\u0300s\u1eb9ju\u0301 %d",h:"wa\u0301kati kan",hh:"wa\u0301kati %d",d:"\u1ecdj\u1ecd\u0301 kan",dd:"\u1ecdj\u1ecd\u0301 %d",M:"osu\u0300 kan",MM:"osu\u0300 %d",y:"\u1ecddu\u0301n kan",yy:"\u1ecddu\u0301n %d"},dayOfMonthOrdinalParse:/\u1ecdj\u1ecd\u0301\s\d{1,2}/,ordinal:"\u1ecdj\u1ecd\u0301 %d",week:{dow:1,doy:4}}),e.defineLocale("zh-cn",{months:"\u4e00\u6708_\u4e8c\u6708_\u4e09\u6708_\u56db\u6708_\u4e94\u6708_\u516d\u6708_\u4e03\u6708_\u516b\u6708_\u4e5d\u6708_\u5341\u6708_\u5341\u4e00\u6708_\u5341\u4e8c\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u661f\u671f\u65e5_\u661f\u671f\u4e00_\u661f\u671f\u4e8c_\u661f\u671f\u4e09_\u661f\u671f\u56db_\u661f\u671f\u4e94_\u661f\u671f\u516d".split("_"),weekdaysShort:"\u5468\u65e5_\u5468\u4e00_\u5468\u4e8c_\u5468\u4e09_\u5468\u56db_\u5468\u4e94_\u5468\u516d".split("_"),weekdaysMin:"\u65e5_\u4e00_\u4e8c_\u4e09_\u56db_\u4e94_\u516d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5Ah\u70b9mm\u5206",LLLL:"YYYY\u5e74M\u6708D\u65e5ddddAh\u70b9mm\u5206",l:"YYYY/M/D",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm"},meridiemParse:/\u51cc\u6668|\u65e9\u4e0a|\u4e0a\u5348|\u4e2d\u5348|\u4e0b\u5348|\u665a\u4e0a/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u51cc\u6668"===a||"\u65e9\u4e0a"===a||"\u4e0a\u5348"===a?e:"\u4e0b\u5348"===a||"\u665a\u4e0a"===a?e+12:11<=e?e:e+12},meridiem:function(e,a,_){var s=100*e+a;return s<600?"\u51cc\u6668":s<900?"\u65e9\u4e0a":s<1130?"\u4e0a\u5348":s<1230?"\u4e2d\u5348":s<1800?"\u4e0b\u5348":"\u665a\u4e0a"},calendar:{sameDay:"[\u4eca\u5929]LT",nextDay:"[\u660e\u5929]LT",nextWeek:"[\u4e0b]ddddLT",lastDay:"[\u6628\u5929]LT",lastWeek:"[\u4e0a]ddddLT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(\u65e5|\u6708|\u5468)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";case"M":return e+"\u6708";case"w":case"W":return e+"\u5468";default:return e}},relativeTime:{future:"%s\u5185",past:"%s\u524d",s:"\u51e0\u79d2",ss:"%d \u79d2",m:"1 \u5206\u949f",mm:"%d \u5206\u949f",h:"1 \u5c0f\u65f6",hh:"%d \u5c0f\u65f6",d:"1 \u5929",dd:"%d \u5929",M:"1 \u4e2a\u6708",MM:"%d \u4e2a\u6708",y:"1 \u5e74",yy:"%d \u5e74"},week:{dow:1,doy:4}}),e.defineLocale("zh-hk",{months:"\u4e00\u6708_\u4e8c\u6708_\u4e09\u6708_\u56db\u6708_\u4e94\u6708_\u516d\u6708_\u4e03\u6708_\u516b\u6708_\u4e5d\u6708_\u5341\u6708_\u5341\u4e00\u6708_\u5341\u4e8c\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u661f\u671f\u65e5_\u661f\u671f\u4e00_\u661f\u671f\u4e8c_\u661f\u671f\u4e09_\u661f\u671f\u56db_\u661f\u671f\u4e94_\u661f\u671f\u516d".split("_"),weekdaysShort:"\u9031\u65e5_\u9031\u4e00_\u9031\u4e8c_\u9031\u4e09_\u9031\u56db_\u9031\u4e94_\u9031\u516d".split("_"),weekdaysMin:"\u65e5_\u4e00_\u4e8c_\u4e09_\u56db_\u4e94_\u516d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5 HH:mm",LLLL:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm",l:"YYYY/M/D",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm"},meridiemParse:/\u51cc\u6668|\u65e9\u4e0a|\u4e0a\u5348|\u4e2d\u5348|\u4e0b\u5348|\u665a\u4e0a/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u51cc\u6668"===a||"\u65e9\u4e0a"===a||"\u4e0a\u5348"===a?e:"\u4e2d\u5348"===a?11<=e?e:e+12:"\u4e0b\u5348"===a||"\u665a\u4e0a"===a?e+12:void 0},meridiem:function(e,a,_){var s=100*e+a;return s<600?"\u51cc\u6668":s<900?"\u65e9\u4e0a":s<1130?"\u4e0a\u5348":s<1230?"\u4e2d\u5348":s<1800?"\u4e0b\u5348":"\u665a\u4e0a"},calendar:{sameDay:"[\u4eca\u5929]LT",nextDay:"[\u660e\u5929]LT",nextWeek:"[\u4e0b]ddddLT",lastDay:"[\u6628\u5929]LT",lastWeek:"[\u4e0a]ddddLT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(\u65e5|\u6708|\u9031)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";case"M":return e+"\u6708";case"w":case"W":return e+"\u9031";default:return e}},relativeTime:{future:"%s\u5167",past:"%s\u524d",s:"\u5e7e\u79d2",ss:"%d \u79d2",m:"1 \u5206\u9418",mm:"%d \u5206\u9418",h:"1 \u5c0f\u6642",hh:"%d \u5c0f\u6642",d:"1 \u5929",dd:"%d \u5929",M:"1 \u500b\u6708",MM:"%d \u500b\u6708",y:"1 \u5e74",yy:"%d \u5e74"}}),e.defineLocale("zh-tw",{months:"\u4e00\u6708_\u4e8c\u6708_\u4e09\u6708_\u56db\u6708_\u4e94\u6708_\u516d\u6708_\u4e03\u6708_\u516b\u6708_\u4e5d\u6708_\u5341\u6708_\u5341\u4e00\u6708_\u5341\u4e8c\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u661f\u671f\u65e5_\u661f\u671f\u4e00_\u661f\u671f\u4e8c_\u661f\u671f\u4e09_\u661f\u671f\u56db_\u661f\u671f\u4e94_\u661f\u671f\u516d".split("_"),weekdaysShort:"\u9031\u65e5_\u9031\u4e00_\u9031\u4e8c_\u9031\u4e09_\u9031\u56db_\u9031\u4e94_\u9031\u516d".split("_"),weekdaysMin:"\u65e5_\u4e00_\u4e8c_\u4e09_\u56db_\u4e94_\u516d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5 HH:mm",LLLL:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm",l:"YYYY/M/D",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm"},meridiemParse:/\u51cc\u6668|\u65e9\u4e0a|\u4e0a\u5348|\u4e2d\u5348|\u4e0b\u5348|\u665a\u4e0a/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u51cc\u6668"===a||"\u65e9\u4e0a"===a||"\u4e0a\u5348"===a?e:"\u4e2d\u5348"===a?11<=e?e:e+12:"\u4e0b\u5348"===a||"\u665a\u4e0a"===a?e+12:void 0},meridiem:function(e,a,_){var s=100*e+a;return s<600?"\u51cc\u6668":s<900?"\u65e9\u4e0a":s<1130?"\u4e0a\u5348":s<1230?"\u4e2d\u5348":s<1800?"\u4e0b\u5348":"\u665a\u4e0a"},calendar:{sameDay:"[\u4eca\u5929] LT",nextDay:"[\u660e\u5929] LT",nextWeek:"[\u4e0b]dddd LT",lastDay:"[\u6628\u5929] LT",lastWeek:"[\u4e0a]dddd LT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(\u65e5|\u6708|\u9031)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";case"M":return e+"\u6708";case"w":case"W":return e+"\u9031";default:return e}},relativeTime:{future:"%s\u5167",past:"%s\u524d",s:"\u5e7e\u79d2",ss:"%d \u79d2",m:"1 \u5206\u9418",mm:"%d \u5206\u9418",h:"1 \u5c0f\u6642",hh:"%d \u5c0f\u6642",d:"1 \u5929",dd:"%d \u5929",M:"1 \u500b\u6708",MM:"%d \u500b\u6708",y:"1 \u5e74",yy:"%d \u5e74"}}),e.locale("en"),e});
/*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.2.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=Array.isArray(d)))?(e?(e=!1,f=c&&Array.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ca=function(a,b){return b?"\0"===a?"\ufffd":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext;function B(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()}var C=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,D=/^.[^:#\[\.,]*$/;function E(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):D.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(E(this,a||[],!1))},not:function(a){return this.pushStack(E(this,a||[],!0))},is:function(a){return!!E(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var F,G=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,H=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||F,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:G.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),C.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};H.prototype=r.fn,F=r(d);var I=/^(?:parents|prev(?:Until|All))/,J={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function K(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return K(a,"nextSibling")},prev:function(a){return K(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return B(a,"iframe")?a.contentDocument:(B(a,"template")&&(a=a.content||a),r.merge([],a.childNodes))}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(J[a]||r.uniqueSort(e),I.test(a)&&e.reverse()),this.pushStack(e)}});var L=/[^\x20\t\r\n\f]+/g;function M(a){var b={};return r.each(a.match(L)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?M(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=e||a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function N(a){return a}function O(a){throw a}function P(a,b,c,d){var e;try{a&&r.isFunction(e=a.promise)?e.call(a).done(b).fail(c):a&&r.isFunction(e=a.then)?e.call(a,b,c):b.apply(void 0,[a].slice(d))}catch(a){c.apply(void 0,[a])}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,N,e),g(f,c,O,e)):(f++,j.call(a,g(f,c,N,e),g(f,c,O,e),g(f,c,N,c.notifyWith))):(d!==N&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==O&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:N,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:N)),c[2][3].add(g(0,a,r.isFunction(d)?d:O))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(P(a,g.done(h(c)).resolve,g.reject,!b),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)P(e[c],h(c),g.reject);return g.promise()}});var Q=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&Q.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var R=r.Deferred();r.fn.ready=function(a){return R.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||R.resolveWith(d,[r]))}}),r.ready.then=R.then;function S(){d.removeEventListener("DOMContentLoaded",S),
a.removeEventListener("load",S),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",S),a.addEventListener("load",S));var T=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)T(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},U=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function V(){this.expando=r.expando+V.uid++}V.uid=1,V.prototype={cache:function(a){var b=a[this.expando];return b||(b={},U(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){Array.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(L)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var W=new V,X=new V,Y=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function $(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:Y.test(a)?JSON.parse(a):a)}function _(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Z,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=$(c)}catch(e){}X.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return X.hasData(a)||W.hasData(a)},data:function(a,b,c){return X.access(a,b,c)},removeData:function(a,b){X.remove(a,b)},_data:function(a,b,c){return W.access(a,b,c)},_removeData:function(a,b){W.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=X.get(f),1===f.nodeType&&!W.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),_(f,d,e[d])));W.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){X.set(this,a)}):T(this,function(b){var c;if(f&&void 0===b){if(c=X.get(f,a),void 0!==c)return c;if(c=_(f,a),void 0!==c)return c}else this.each(function(){X.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){X.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=W.get(a,b),c&&(!d||Array.isArray(c)?d=W.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return W.get(a,c)||W.access(a,c,{empty:r.Callbacks("once memory").add(function(){W.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=W.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var aa=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ba=new RegExp("^(?:([+-])=|)("+aa+")([a-z%]*)$","i"),ca=["Top","Right","Bottom","Left"],da=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},ea=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function fa(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&ba.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var ga={};function ha(a){var b,c=a.ownerDocument,d=a.nodeName,e=ga[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),ga[d]=e,e)}function ia(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=W.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&da(d)&&(e[f]=ha(d))):"none"!==c&&(e[f]="none",W.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ia(this,!0)},hide:function(){return ia(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){da(this)?r(this).show():r(this).hide()})}});var ja=/^(?:checkbox|radio)$/i,ka=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,la=/^$|\/(?:java|ecma)script/i,ma={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ma.optgroup=ma.option,ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead,ma.th=ma.td;function na(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&B(a,b)?r.merge([a],c):c}function oa(a,b){for(var c=0,d=a.length;c<d;c++)W.set(a[c],"globalEval",!b||W.get(b[c],"globalEval"))}var pa=/<|&#?\w+;/;function qa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(pa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ka.exec(f)||["",""])[1].toLowerCase(),i=ma[h]||ma._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=na(l.appendChild(f),"script"),j&&oa(g),c){k=0;while(f=g[k++])la.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var ra=d.documentElement,sa=/^key/,ta=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ua=/^([^.]*)(?:\.(.+)|)/;function va(){return!0}function wa(){return!1}function xa(){try{return d.activeElement}catch(a){}}function ya(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)ya(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=wa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(ra,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(L)||[""],j=b.length;while(j--)h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.hasData(a)&&W.get(a);if(q&&(i=q.events)){b=(b||"").match(L)||[""],j=b.length;while(j--)if(h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+o.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&W.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(W.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==xa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===xa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&B(this,"input"))return this.click(),!1},_default:function(a){return B(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?va:wa,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:wa,isPropagationStopped:wa,isImmediatePropagationStopped:wa,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=va,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=va,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=va,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&sa.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&ta.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return ya(this,a,b,c,d)},one:function(a,b,c,d){return ya(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=wa),this.each(function(){r.event.remove(this,a,c,b)})}});var za=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,Aa=/<script|<style|<link/i,Ba=/checked\s*(?:[^=]|=\s*.checked.)/i,Ca=/^true\/(.*)/,Da=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Ea(a,b){return B(a,"table")&&B(11!==b.nodeType?b:b.firstChild,"tr")?r(">tbody",a)[0]||a:a}function Fa(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Ga(a){var b=Ca.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ha(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(W.hasData(a)&&(f=W.access(a),g=W.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}X.hasData(a)&&(h=X.access(a),i=r.extend({},h),X.set(b,i))}}function Ia(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ja.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ja(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Ba.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ja(f,b,c,d)});if(m&&(e=qa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(na(e,"script"),Fa),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,na(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Ga),l=0;l<i;l++)j=h[l],la.test(j.type||"")&&!W.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Da,""),k))}return a}function Ka(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(na(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&oa(na(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(za,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=na(h),f=na(a),d=0,e=f.length;d<e;d++)Ia(f[d],g[d]);if(b)if(c)for(f=f||na(a),g=g||na(h),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);else Ha(a,h);return g=na(h,"script"),g.length>0&&oa(g,!i&&na(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(U(c)){if(b=c[W.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[W.expando]=void 0}c[X.expando]&&(c[X.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ka(this,a,!0)},remove:function(a){return Ka(this,a)},text:function(a){return T(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.appendChild(a)}})},prepend:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(na(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return T(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!Aa.test(a)&&!ma[(ka.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(na(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ja(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(na(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var La=/^margin/,Ma=new RegExp("^("+aa+")(?!px)[a-z%]+$","i"),Na=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",ra.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,ra.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Oa(a,b,c){var d,e,f,g,h=a.style;return c=c||Na(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&Ma.test(g)&&La.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Pa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Qa=/^(none|table(?!-c[ea]).+)/,Ra=/^--/,Sa={position:"absolute",visibility:"hidden",display:"block"},Ta={letterSpacing:"0",fontWeight:"400"},Ua=["Webkit","Moz","ms"],Va=d.createElement("div").style;function Wa(a){if(a in Va)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ua.length;while(c--)if(a=Ua[c]+b,a in Va)return a}function Xa(a){var b=r.cssProps[a];return b||(b=r.cssProps[a]=Wa(a)||a),b}function Ya(a,b,c){var d=ba.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Za(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ca[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ca[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ca[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ca[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ca[f]+"Width",!0,e)));return g}function $a(a,b,c){var d,e=Na(a),f=Oa(a,b,e),g="border-box"===r.css(a,"boxSizing",!1,e);return Ma.test(f)?f:(d=g&&(o.boxSizingReliable()||f===a.style[b]),"auto"===f&&(f=a["offset"+b[0].toUpperCase()+b.slice(1)]),f=parseFloat(f)||0,f+Za(a,b,c||(g?"border":"content"),d,e)+"px")}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Oa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=Ra.test(b),j=a.style;return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:j[b]:(f=typeof c,"string"===f&&(e=ba.exec(c))&&e[1]&&(c=fa(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(j[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i?j.setProperty(b,c):j[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b),i=Ra.test(b);return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Oa(a,b,d)),"normal"===e&&b in Ta&&(e=Ta[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Qa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?$a(a,b,d):ea(a,Sa,function(){return $a(a,b,d)})},set:function(a,c,d){var e,f=d&&Na(a),g=d&&Za(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=ba.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Ya(a,c,g)}}}),r.cssHooks.marginLeft=Pa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Oa(a,"marginLeft"))||a.getBoundingClientRect().left-ea(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ca[d]+b]=f[d]||f[d-2]||f[0];return e}},La.test(a)||(r.cssHooks[a+b].set=Ya)}),r.fn.extend({css:function(a,b){return T(this,function(a,b,c){var d,e,f={},g=0;if(Array.isArray(b)){for(d=Na(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function _a(a,b,c,d,e){return new _a.prototype.init(a,b,c,d,e)}r.Tween=_a,_a.prototype={constructor:_a,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=_a.propHooks[this.prop];return a&&a.get?a.get(this):_a.propHooks._default.get(this)},run:function(a){var b,c=_a.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):_a.propHooks._default.set(this),this}},_a.prototype.init.prototype=_a.prototype,_a.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},_a.propHooks.scrollTop=_a.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=_a.prototype.init,r.fx.step={};var ab,bb,cb=/^(?:toggle|show|hide)$/,db=/queueHooks$/;function eb(){bb&&(d.hidden===!1&&a.requestAnimationFrame?a.requestAnimationFrame(eb):a.setTimeout(eb,r.fx.interval),r.fx.tick())}function fb(){return a.setTimeout(function(){ab=void 0}),ab=r.now()}function gb(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ca[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function hb(a,b,c){for(var d,e=(kb.tweeners[b]||[]).concat(kb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&da(a),q=W.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],cb.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=W.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ia([a],!0),j=a.style.display||j,k=r.css(a,"display"),ia([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=W.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ia([a],!0),m.done(function(){p||ia([a]),W.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=hb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],Array.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=kb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=ab||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(i||h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:ab||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);f<g;f++)if(d=kb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,hb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j}r.Animation=r.extend(kb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return fa(c.elem,a,ba.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(L);for(var c,d=0,e=a.length;d<e;d++)c=a[d],kb.tweeners[c]=kb.tweeners[c]||[],kb.tweeners[c].unshift(b)},prefilters:[ib],prefilter:function(a,b){b?kb.prefilters.unshift(a):kb.prefilters.push(a)}}),r.speed=function(a,b,c){var d=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off?d.duration=0:"number"!=typeof d.duration&&(d.duration in r.fx.speeds?d.duration=r.fx.speeds[d.duration]:d.duration=r.fx.speeds._default),null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){r.isFunction(d.old)&&d.old.call(this),d.queue&&r.dequeue(this,d.queue)},d},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(da).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=kb(this,r.extend({},a),f);(e||W.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=W.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&db.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=W.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),r.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(ab=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),ab=void 0},r.fx.timer=function(a){r.timers.push(a),r.fx.start()},r.fx.interval=13,r.fx.start=function(){bb||(bb=!0,eb())},r.fx.stop=function(){bb=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var lb,mb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return T(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?lb:void 0)),void 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),
null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&B(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(L);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),lb={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\w+/g),function(a,b){var c=mb[b]||r.find.attr;mb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=mb[g],mb[g]=e,e=null!=c(a,b,d)?g:null,mb[g]=f),e}});var nb=/^(?:input|select|textarea|button)$/i,ob=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return T(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):nb.test(a.nodeName)||ob.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function pb(a){var b=a.match(L)||[];return b.join(" ")}function qb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,qb(this)))});if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,qb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,qb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(L)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=qb(this),b&&W.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":W.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+pb(qb(c))+" ").indexOf(b)>-1)return!0;return!1}});var rb=/\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":Array.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(rb,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:pb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!B(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(Array.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var sb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!sb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,sb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(W.get(h,"events")||{})[b.type]&&W.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&U(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!U(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=W.access(d,b);e||d.addEventListener(a,c,!0),W.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=W.access(d,b)-1;e?W.access(d,b,e):(d.removeEventListener(a,c,!0),W.remove(d,b))}}});var tb=a.location,ub=r.now(),vb=/\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(Array.isArray(b))r.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(Array.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!ja.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:Array.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}});var Bb=/%20/g,Cb=/#.*$/,Db=/([?&])_=[^&]*/,Eb=/^(.*?):[ \t]*([^\r\n]*)$/gm,Fb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Gb=/^(?:GET|HEAD)$/,Hb=/^\/\//,Ib={},Jb={},Kb="*/".concat("*"),Lb=d.createElement("a");Lb.href=tb.href;function Mb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(L)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nb(a,b,c,d){var e={},f=a===Jb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Ob(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Pb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Qb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:tb.href,type:"GET",isLocal:Fb.test(tb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Kb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Ob(Ob(a,r.ajaxSettings),b):Ob(r.ajaxSettings,a)},ajaxPrefilter:Mb(Ib),ajaxTransport:Mb(Jb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Eb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||tb.href)+"").replace(Hb,tb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(L)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Lb.protocol+"//"+Lb.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Nb(Ib,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Gb.test(o.type),f=o.url.replace(Cb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(Bb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(vb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Db,"$1"),n=(vb.test(f)?"&":"?")+"_="+ub++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Kb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Nb(Jb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Pb(o,y,d)),v=Qb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Rb={0:200,1223:204},Sb=r.ajaxSettings.xhr();o.cors=!!Sb&&"withCredentials"in Sb,o.ajax=Sb=!!Sb,r.ajaxTransport(function(b){var c,d;if(o.cors||Sb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Rb[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Tb=[],Ub=/(=)\?(?=&|$)|\?\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Tb.pop()||r.expando+"_"+ub++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Ub.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ub.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Ub,"$1"+e):b.jsonp!==!1&&(b.url+=(vb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Tb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=C.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=qa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=pb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length},r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),b=f.ownerDocument,c=b.documentElement,e=b.defaultView,{top:d.top+e.pageYOffset-c.clientTop,left:d.left+e.pageXOffset-c.clientLeft}):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),B(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||ra})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return T(this,function(a,d,e){var f;return r.isWindow(a)?f=a:9===a.nodeType&&(f=a.defaultView),void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Pa(o.pixelPosition,function(a,c){if(c)return c=Oa(a,b),Ma.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return T(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.holdReady=function(a){a?r.readyWait++:r.ready(!0)},r.isArray=Array.isArray,r.parseJSON=JSON.parse,r.nodeName=B,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Vb=a.jQuery,Wb=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Wb),b&&a.jQuery===r&&(a.jQuery=Vb),r},b||(a.jQuery=a.$=r),r});

$("html").addClass('bonfire-html-onload');

$(document.body).on("touchmove", function(e) {
    e.preventDefault();
});

var scrollPosition = [
    self.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft,
    self.pageYOffset || document.documentElement.scrollTop  || document.body.scrollTop
];

var html = $("html");
html.data('scroll-position', scrollPosition);
html.data('previous-overflow', html.css('overflow'));
html.css('overflow', 'hidden');

window.scrollTo(scrollPosition[0], scrollPosition[1]);

$(window).on('load', function() {

    setTimeout(function(){

        $(".bonfire-pageloader-icon").addClass('bonfire-pageloader-icon-hide');
    },500);

    setTimeout(function(){

        $(document.body).unbind('touchmove');

        var html = $('html');
        var scrollPosition = html.data('scroll-position');
        html.css('overflow', html.data('previous-overflow'));
        window.scrollTo(scrollPosition[0], scrollPosition[1]);

        $("#bonfire-pageloader").addClass('bonfire-pageloader-fade');

        $("html").removeClass('bonfire-html-onload');

    },750);

    setTimeout(function(){

        $("#bonfire-pageloader").addClass('bonfire-pageloader-hide');

    },1500);

});
/*!
 * FullCalendar v3.4.0
 * Docs & License: https://fullcalendar.io/
 * (c) 2017 Adam Shaw
 */

(function(factory) {
    if (typeof define === 'function' && define.amd) {
        define([ 'jquery', 'moment' ], factory);
    }
    else if (typeof exports === 'object') { // Node/CommonJS
        module.exports = factory(require('jquery'), require('moment'));
    }
    else {
        factory(jQuery, moment);
    }
})(function($, moment) {

    ;;

    var FC = $.fullCalendar = {
        version: "3.4.0",
        // When introducing internal API incompatibilities (where fullcalendar plugins would break),
        // the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)
        // and the below integer should be incremented.
        internalApiVersion: 9
    };
    var fcViews = FC.views = {};


    $.fn.fullCalendar = function(options) {
        var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
        var res = this; // what this function will return (this jQuery object by default)

        this.each(function(i, _element) { // loop each DOM element involved
            var element = $(_element);
            var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
            var singleRes; // the returned value of this single method call

            // a method call
            if (typeof options === 'string') {
                if (calendar && $.isFunction(calendar[options])) {
                    singleRes = calendar[options].apply(calendar, args);
                    if (!i) {
                        res = singleRes; // record the first method call result
                    }
                    if (options === 'destroy') { // for the destroy method, must remove Calendar object data
                        element.removeData('fullCalendar');
                    }
                }
            }
            // a new calendar initialization
            else if (!calendar) { // don't initialize twice
                calendar = new Calendar(element, options);
                element.data('fullCalendar', calendar);
                calendar.render();
            }
        });

        return res;
    };


    var complexOptions = [ // names of options that are objects whose properties should be combined
        'header',
        'footer',
        'buttonText',
        'buttonIcons',
        'themeButtonIcons'
    ];


// Merges an array of option objects into a single object
    function mergeOptions(optionObjs) {
        return mergeProps(optionObjs, complexOptions);
    }

    ;;

// exports
    FC.intersectRanges = intersectRanges;
    FC.applyAll = applyAll;
    FC.debounce = debounce;
    FC.isInt = isInt;
    FC.htmlEscape = htmlEscape;
    FC.cssToStr = cssToStr;
    FC.proxy = proxy;
    FC.capitaliseFirstLetter = capitaliseFirstLetter;


    /* FullCalendar-specific DOM Utilities
     ----------------------------------------------------------------------------------------------------------------------*/


// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
    function compensateScroll(rowEls, scrollbarWidths) {
        if (scrollbarWidths.left) {
            rowEls.css({
                'border-left-width': 1,
                'margin-left': scrollbarWidths.left - 1
            });
        }
        if (scrollbarWidths.right) {
            rowEls.css({
                'border-right-width': 1,
                'margin-right': scrollbarWidths.right - 1
            });
        }
    }


// Undoes compensateScroll and restores all borders/margins
    function uncompensateScroll(rowEls) {
        rowEls.css({
            'margin-left': '',
            'margin-right': '',
            'border-left-width': '',
            'border-right-width': ''
        });
    }


// Make the mouse cursor express that an event is not allowed in the current area
    function disableCursor() {
        $('body').addClass('fc-not-allowed');
    }


// Returns the mouse cursor to its original look
    function enableCursor() {
        $('body').removeClass('fc-not-allowed');
    }


// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and
// reduces the available height.
    function distributeHeight(els, availableHeight, shouldRedistribute) {

        // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
        // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.

        var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
        var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
        var flexEls = []; // elements that are allowed to expand. array of DOM nodes
        var flexOffsets = []; // amount of vertical space it takes up
        var flexHeights = []; // actual css height
        var usedHeight = 0;

        undistributeHeight(els); // give all elements their natural height

        // find elements that are below the recommended height (expandable).
        // important to query for heights in a single first pass (to avoid reflow oscillation).
        els.each(function(i, el) {
            var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
            var naturalOffset = $(el).outerHeight(true);

            if (naturalOffset < minOffset) {
                flexEls.push(el);
                flexOffsets.push(naturalOffset);
                flexHeights.push($(el).height());
            }
            else {
                // this element stretches past recommended height (non-expandable). mark the space as occupied.
                usedHeight += naturalOffset;
            }
        });

        // readjust the recommended height to only consider the height available to non-maxed-out rows.
        if (shouldRedistribute) {
            availableHeight -= usedHeight;
            minOffset1 = Math.floor(availableHeight / flexEls.length);
            minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
        }

        // assign heights to all expandable elements
        $(flexEls).each(function(i, el) {
            var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
            var naturalOffset = flexOffsets[i];
            var naturalHeight = flexHeights[i];
            var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding

            if (naturalOffset < minOffset) { // we check this again because redistribution might have changed things
                $(el).height(newHeight);
            }
        });
    }


// Undoes distrubuteHeight, restoring all els to their natural height
    function undistributeHeight(els) {
        els.height('');
    }


// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
    function matchCellWidths(els) {
        var maxInnerWidth = 0;

        els.find('> *').each(function(i, innerEl) {
            var innerWidth = $(innerEl).outerWidth();
            if (innerWidth > maxInnerWidth) {
                maxInnerWidth = innerWidth;
            }
        });

        maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance

        els.width(maxInnerWidth);

        return maxInnerWidth;
    }


// Given one element that resides inside another,
// Subtracts the height of the inner element from the outer element.
    function subtractInnerElHeight(outerEl, innerEl) {
        var both = outerEl.add(innerEl);
        var diff;

        // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
        both.css({
            position: 'relative', // cause a reflow, which will force fresh dimension recalculation
            left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
        });
        diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions
        both.css({ position: '', left: '' }); // undo hack

        return diff;
    }


    /* Element Geom Utilities
     ----------------------------------------------------------------------------------------------------------------------*/

    FC.getOuterRect = getOuterRect;
    FC.getClientRect = getClientRect;
    FC.getContentRect = getContentRect;
    FC.getScrollbarWidths = getScrollbarWidths;


// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
    function getScrollParent(el) {
        var position = el.css('position'),
            scrollParent = el.parents().filter(function() {
                var parent = $(this);
                return (/(auto|scroll)/).test(
                    parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')
                );
            }).eq(0);

        return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
    }


// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
    function getOuterRect(el, origin) {
        var offset = el.offset();
        var left = offset.left - (origin ? origin.left : 0);
        var top = offset.top - (origin ? origin.top : 0);

        return {
            left: left,
            right: left + el.outerWidth(),
            top: top,
            bottom: top + el.outerHeight()
        };
    }


// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
// WARNING: given element can't have borders
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
    function getClientRect(el, origin) {
        var offset = el.offset();
        var scrollbarWidths = getScrollbarWidths(el);
        var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);
        var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);

        return {
            left: left,
            right: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars
            top: top,
            bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
        };
    }


// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
    function getContentRect(el, origin) {
        var offset = el.offset(); // just outside of border, margin not included
        var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -
            (origin ? origin.left : 0);
        var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -
            (origin ? origin.top : 0);

        return {
            left: left,
            right: left + el.width(),
            top: top,
            bottom: top + el.height()
        };
    }


// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
    function getScrollbarWidths(el) {
        var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;
        var bottomWidth = el[0].offsetHeight - el[0].clientHeight;
        var widths;

        leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);
        bottomWidth = sanitizeScrollbarWidth(bottomWidth);

        widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };

        if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') { // is the scrollbar on the left side?
            widths.left = leftRightWidth;
        }
        else {
            widths.right = leftRightWidth;
        }

        return widths;
    }


// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to
// retina displays, rounding, and IE11. Massage them into a usable value.
    function sanitizeScrollbarWidth(width) {
        width = Math.max(0, width); // no negatives
        width = Math.round(width);
        return width;
    }


// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side

    var _isLeftRtlScrollbars = null;

    function getIsLeftRtlScrollbars() { // responsible for caching the computation
        if (_isLeftRtlScrollbars === null) {
            _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
        }
        return _isLeftRtlScrollbars;
    }

    function computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it
        var el = $('<div><div/></div>')
            .css({
                position: 'absolute',
                top: -1000,
                left: 0,
                border: 0,
                padding: 0,
                overflow: 'scroll',
                direction: 'rtl'
            })
            .appendTo('body');
        var innerEl = el.children();
        var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
        el.remove();
        return res;
    }


// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
    function getCssFloat(el, prop) {
        return parseFloat(el.css(prop)) || 0;
    }


    /* Mouse / Touch Utilities
     ----------------------------------------------------------------------------------------------------------------------*/

    FC.preventDefault = preventDefault;


// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
    function isPrimaryMouseButton(ev) {
        return ev.which == 1 && !ev.ctrlKey;
    }


    function getEvX(ev) {
        var touches = ev.originalEvent.touches;

        // on mobile FF, pageX for touch events is present, but incorrect,
        // so, look at touch coordinates first.
        if (touches && touches.length) {
            return touches[0].pageX;
        }

        return ev.pageX;
    }


    function getEvY(ev) {
        var touches = ev.originalEvent.touches;

        // on mobile FF, pageX for touch events is present, but incorrect,
        // so, look at touch coordinates first.
        if (touches && touches.length) {
            return touches[0].pageY;
        }

        return ev.pageY;
    }


    function getEvIsTouch(ev) {
        return /^touch/.test(ev.type);
    }


    function preventSelection(el) {
        el.addClass('fc-unselectable')
            .on('selectstart', preventDefault);
    }


    function allowSelection(el) {
        el.removeClass('fc-unselectable')
            .off('selectstart', preventDefault);
    }


// Stops a mouse/touch event from doing it's native browser action
    function preventDefault(ev) {
        ev.preventDefault();
    }


    /* General Geometry Utils
     ----------------------------------------------------------------------------------------------------------------------*/

    FC.intersectRects = intersectRects;

// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
    function intersectRects(rect1, rect2) {
        var res = {
            left: Math.max(rect1.left, rect2.left),
            right: Math.min(rect1.right, rect2.right),
            top: Math.max(rect1.top, rect2.top),
            bottom: Math.min(rect1.bottom, rect2.bottom)
        };

        if (res.left < res.right && res.top < res.bottom) {
            return res;
        }
        return false;
    }


// Returns a new point that will have been moved to reside within the given rectangle
    function constrainPoint(point, rect) {
        return {
            left: Math.min(Math.max(point.left, rect.left), rect.right),
            top: Math.min(Math.max(point.top, rect.top), rect.bottom)
        };
    }


// Returns a point that is the center of the given rectangle
    function getRectCenter(rect) {
        return {
            left: (rect.left + rect.right) / 2,
            top: (rect.top + rect.bottom) / 2
        };
    }


// Subtracts point2's coordinates from point1's coordinates, returning a delta
    function diffPoints(point1, point2) {
        return {
            left: point1.left - point2.left,
            top: point1.top - point2.top
        };
    }


    /* Object Ordering by Field
     ----------------------------------------------------------------------------------------------------------------------*/

    FC.parseFieldSpecs = parseFieldSpecs;
    FC.compareByFieldSpecs = compareByFieldSpecs;
    FC.compareByFieldSpec = compareByFieldSpec;
    FC.flexibleCompare = flexibleCompare;


    function parseFieldSpecs(input) {
        var specs = [];
        var tokens = [];
        var i, token;

        if (typeof input === 'string') {
            tokens = input.split(/\s*,\s*/);
        }
        else if (typeof input === 'function') {
            tokens = [ input ];
        }
        else if ($.isArray(input)) {
            tokens = input;
        }

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];

            if (typeof token === 'string') {
                specs.push(
                    token.charAt(0) == '-' ?
                        { field: token.substring(1), order: -1 } :
                        { field: token, order: 1 }
                );
            }
            else if (typeof token === 'function') {
                specs.push({ func: token });
            }
        }

        return specs;
    }


    function compareByFieldSpecs(obj1, obj2, fieldSpecs) {
        var i;
        var cmp;

        for (i = 0; i < fieldSpecs.length; i++) {
            cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);
            if (cmp) {
                return cmp;
            }
        }

        return 0;
    }


    function compareByFieldSpec(obj1, obj2, fieldSpec) {
        if (fieldSpec.func) {
            return fieldSpec.func(obj1, obj2);
        }
        return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *
            (fieldSpec.order || 1);
    }


    function flexibleCompare(a, b) {
        if (!a && !b) {
            return 0;
        }
        if (b == null) {
            return -1;
        }
        if (a == null) {
            return 1;
        }
        if ($.type(a) === 'string' || $.type(b) === 'string') {
            return String(a).localeCompare(String(b));
        }
        return a - b;
    }


    /* FullCalendar-specific Misc Utilities
     ----------------------------------------------------------------------------------------------------------------------*/


// Computes the intersection of the two ranges. Will return fresh date clones in a range.
// Returns undefined if no intersection.
// Expects all dates to be normalized to the same timezone beforehand.
// TODO: move to date section?
    function intersectRanges(subjectRange, constraintRange) {
        var subjectStart = subjectRange.start;
        var subjectEnd = subjectRange.end;
        var constraintStart = constraintRange.start;
        var constraintEnd = constraintRange.end;
        var segStart, segEnd;
        var isStart, isEnd;

        if (subjectEnd > constraintStart && subjectStart < constraintEnd) { // in bounds at all?

            if (subjectStart >= constraintStart) {
                segStart = subjectStart.clone();
                isStart = true;
            }
            else {
                segStart = constraintStart.clone();
                isStart =  false;
            }

            if (subjectEnd <= constraintEnd) {
                segEnd = subjectEnd.clone();
                isEnd = true;
            }
            else {
                segEnd = constraintEnd.clone();
                isEnd = false;
            }

            return {
                start: segStart,
                end: segEnd,
                isStart: isStart,
                isEnd: isEnd
            };
        }
    }


    /* Date Utilities
     ----------------------------------------------------------------------------------------------------------------------*/

    FC.computeGreatestUnit = computeGreatestUnit;
    FC.divideRangeByDuration = divideRangeByDuration;
    FC.divideDurationByDuration = divideDurationByDuration;
    FC.multiplyDuration = multiplyDuration;
    FC.durationHasTime = durationHasTime;

    var dayIDs = [ 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat' ];
    var unitsDesc = [ 'year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond' ]; // descending


// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
    function diffDayTime(a, b) {
        return moment.duration({
            days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
            ms: a.time() - b.time() // time-of-day from day start. disregards timezone
        });
    }


// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
    function diffDay(a, b) {
        return moment.duration({
            days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
        });
    }


// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
    function diffByUnit(a, b, unit) {
        return moment.duration(
            Math.round(a.diff(b, unit, true)), // returnFloat=true
            unit
        );
    }


// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
    function computeGreatestUnit(start, end) {
        var i, unit;
        var val;

        for (i = 0; i < unitsDesc.length; i++) {
            unit = unitsDesc[i];
            val = computeRangeAs(unit, start, end);

            if (val >= 1 && isInt(val)) {
                break;
            }
        }

        return unit; // will be "milliseconds" if nothing else matches
    }


// like computeGreatestUnit, but has special abilities to interpret the source input for clues
    function computeDurationGreatestUnit(duration, durationInput) {
        var unit = computeGreatestUnit(duration);

        // prevent days:7 from being interpreted as a week
        if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {
            unit = 'day';
        }

        return unit;
    }


// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
    function computeRangeAs(unit, start, end) {

        if (end != null) { // given start, end
            return end.diff(start, unit, true);
        }
        else if (moment.isDuration(start)) { // given duration
            return start.as(unit);
        }
        else { // given { start, end } range object
            return start.end.diff(start.start, unit, true);
        }
    }


// Intelligently divides a range (specified by a start/end params) by a duration
    function divideRangeByDuration(start, end, dur) {
        var months;

        if (durationHasTime(dur)) {
            return (end - start) / dur;
        }
        months = dur.asMonths();
        if (Math.abs(months) >= 1 && isInt(months)) {
            return end.diff(start, 'months', true) / months;
        }
        return end.diff(start, 'days', true) / dur.asDays();
    }


// Intelligently divides one duration by another
    function divideDurationByDuration(dur1, dur2) {
        var months1, months2;

        if (durationHasTime(dur1) || durationHasTime(dur2)) {
            return dur1 / dur2;
        }
        months1 = dur1.asMonths();
        months2 = dur2.asMonths();
        if (
            Math.abs(months1) >= 1 && isInt(months1) &&
            Math.abs(months2) >= 1 && isInt(months2)
        ) {
            return months1 / months2;
        }
        return dur1.asDays() / dur2.asDays();
    }


// Intelligently multiplies a duration by a number
    function multiplyDuration(dur, n) {
        var months;

        if (durationHasTime(dur)) {
            return moment.duration(dur * n);
        }
        months = dur.asMonths();
        if (Math.abs(months) >= 1 && isInt(months)) {
            return moment.duration({ months: months * n });
        }
        return moment.duration({ days: dur.asDays() * n });
    }


    function cloneRange(range) {
        return {
            start: range.start.clone(),
            end: range.end.clone()
        };
    }


// Trims the beginning and end of inner range to be completely within outerRange.
// Returns a new range object.
    function constrainRange(innerRange, outerRange) {
        innerRange = cloneRange(innerRange);

        if (outerRange.start) {
            // needs to be inclusively before outerRange's end
            innerRange.start = constrainDate(innerRange.start, outerRange);
        }

        if (outerRange.end) {
            innerRange.end = minMoment(innerRange.end, outerRange.end);
        }

        return innerRange;
    }


// If the given date is not within the given range, move it inside.
// (If it's past the end, make it one millisecond before the end).
// Always returns a new moment.
    function constrainDate(date, range) {
        date = date.clone();

        if (range.start) {
            date = maxMoment(date, range.start);
        }

        if (range.end && date >= range.end) {
            date = range.end.clone().subtract(1);
        }

        return date;
    }


    function isDateWithinRange(date, range) {
        return (!range.start || date >= range.start) &&
            (!range.end || date < range.end);
    }


// TODO: deal with repeat code in intersectRanges
// constraintRange can have unspecified start/end, an open-ended range.
    function doRangesIntersect(subjectRange, constraintRange) {
        return (!constraintRange.start || subjectRange.end >= constraintRange.start) &&
            (!constraintRange.end || subjectRange.start < constraintRange.end);
    }


    function isRangeWithinRange(innerRange, outerRange) {
        return (!outerRange.start || innerRange.start >= outerRange.start) &&
            (!outerRange.end || innerRange.end <= outerRange.end);
    }


    function isRangesEqual(range0, range1) {
        return ((range0.start && range1.start && range0.start.isSame(range1.start)) || (!range0.start && !range1.start)) &&
            ((range0.end && range1.end && range0.end.isSame(range1.end)) || (!range0.end && !range1.end));
    }


// Returns the moment that's earlier in time. Always a copy.
    function minMoment(mom1, mom2) {
        return (mom1.isBefore(mom2) ? mom1 : mom2).clone();
    }


// Returns the moment that's later in time. Always a copy.
    function maxMoment(mom1, mom2) {
        return (mom1.isAfter(mom2) ? mom1 : mom2).clone();
    }


// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
    function durationHasTime(dur) {
        return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
    }


    function isNativeDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
    }


// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
    function isTimeString(str) {
        return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
    }


    /* Logging and Debug
     ----------------------------------------------------------------------------------------------------------------------*/

    FC.log = function() {
        var console = window.console;

        if (console && console.log) {
            return console.log.apply(console, arguments);
        }
    };

    FC.warn = function() {
        var console = window.console;

        if (console && console.warn) {
            return console.warn.apply(console, arguments);
        }
        else {
            return FC.log.apply(FC, arguments);
        }
    };


    /* General Utilities
     ----------------------------------------------------------------------------------------------------------------------*/

    var hasOwnPropMethod = {}.hasOwnProperty;


// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
    function mergeProps(propObjs, complexProps) {
        var dest = {};
        var i, name;
        var complexObjs;
        var j, val;
        var props;

        if (complexProps) {
            for (i = 0; i < complexProps.length; i++) {
                name = complexProps[i];
                complexObjs = [];

                // collect the trailing object values, stopping when a non-object is discovered
                for (j = propObjs.length - 1; j >= 0; j--) {
                    val = propObjs[j][name];

                    if (typeof val === 'object') {
                        complexObjs.unshift(val);
                    }
                    else if (val !== undefined) {
                        dest[name] = val; // if there were no objects, this value will be used
                        break;
                    }
                }

                // if the trailing values were objects, use the merged value
                if (complexObjs.length) {
                    dest[name] = mergeProps(complexObjs);
                }
            }
        }

        // copy values into the destination, going from last to first
        for (i = propObjs.length - 1; i >= 0; i--) {
            props = propObjs[i];

            for (name in props) {
                if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign
                    dest[name] = props[name];
                }
            }
        }

        return dest;
    }


// Create an object that has the given prototype. Just like Object.create
    function createObject(proto) {
        var f = function() {};
        f.prototype = proto;
        return new f();
    }
    FC.createObject = createObject;


    function copyOwnProps(src, dest) {
        for (var name in src) {
            if (hasOwnProp(src, name)) {
                dest[name] = src[name];
            }
        }
    }


    function hasOwnProp(obj, name) {
        return hasOwnPropMethod.call(obj, name);
    }


// Is the given value a non-object non-function value?
    function isAtomic(val) {
        return /undefined|null|boolean|number|string/.test($.type(val));
    }


    function applyAll(functions, thisObj, args) {
        if ($.isFunction(functions)) {
            functions = [ functions ];
        }
        if (functions) {
            var i;
            var ret;
            for (i=0; i<functions.length; i++) {
                ret = functions[i].apply(thisObj, args) || ret;
            }
            return ret;
        }
    }


    function firstDefined() {
        for (var i=0; i<arguments.length; i++) {
            if (arguments[i] !== undefined) {
                return arguments[i];
            }
        }
    }


    function htmlEscape(s) {
        return (s + '').replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/'/g, '&#039;')
            .replace(/"/g, '&quot;')
            .replace(/\n/g, '<br />');
    }


    function stripHtmlEntities(text) {
        return text.replace(/&.*?;/g, '');
    }


// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
    function cssToStr(cssProps) {
        var statements = [];

        $.each(cssProps, function(name, val) {
            if (val != null) {
                statements.push(name + ':' + val);
            }
        });

        return statements.join(';');
    }


// Given an object hash of HTML attribute names to values,
// generates a string that can be injected between < > in HTML
    function attrsToStr(attrs) {
        var parts = [];

        $.each(attrs, function(name, val) {
            if (val != null) {
                parts.push(name + '="' + htmlEscape(val) + '"');
            }
        });

        return parts.join(' ');
    }


    function capitaliseFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }


    function compareNumbers(a, b) { // for .sort()
        return a - b;
    }


    function isInt(n) {
        return n % 1 === 0;
    }


// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
    function proxy(obj, methodName) {
        var method = obj[methodName];

        return function() {
            return method.apply(obj, arguments);
        };
    }


// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
    function debounce(func, wait, immediate) {
        var timeout, args, context, timestamp, result;

        var later = function() {
            var last = +new Date() - timestamp;
            if (last < wait) {
                timeout = setTimeout(later, wait - last);
            }
            else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    context = args = null;
                }
            }
        };

        return function() {
            context = this;
            args = arguments;
            timestamp = +new Date();
            var callNow = immediate && !timeout;
            if (!timeout) {
                timeout = setTimeout(later, wait);
            }
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }
            return result;
        };
    }

    ;;

    /*
     GENERAL NOTE on moments throughout the *entire rest* of the codebase:
     All moments are assumed to be ambiguously-zoned unless otherwise noted,
     with the NOTABLE EXCEOPTION of start/end dates that live on *Event Objects*.
     Ambiguously-TIMED moments are assumed to be ambiguously-zoned by nature.
     */

    var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
    var ambigTimeOrZoneRegex =
        /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
    var newMomentProto = moment.fn; // where we will attach our new methods
    var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods

// tell momentjs to transfer these properties upon clone
    var momentProperties = moment.momentProperties;
    momentProperties.push('_fullCalendar');
    momentProperties.push('_ambigTime');
    momentProperties.push('_ambigZone');


// Creating
// -------------------------------------------------------------------------------------------------

// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
    FC.moment = function() {
        return makeMoment(arguments);
    };

// Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.
    FC.moment.utc = function() {
        var mom = makeMoment(arguments, true);

        // Force it into UTC because makeMoment doesn't guarantee it
        // (if given a pre-existing moment for example)
        if (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone
            mom.utc();
        }

        return mom;
    };

// Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
    FC.moment.parseZone = function() {
        return makeMoment(arguments, true, true);
    };

// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
    function makeMoment(args, parseAsUTC, parseZone) {
        var input = args[0];
        var isSingleString = args.length == 1 && typeof input === 'string';
        var isAmbigTime;
        var isAmbigZone;
        var ambigMatch;
        var mom;

        if (moment.isMoment(input) || isNativeDate(input) || input === undefined) {
            mom = moment.apply(null, args);
        }
        else { // "parsing" is required
            isAmbigTime = false;
            isAmbigZone = false;

            if (isSingleString) {
                if (ambigDateOfMonthRegex.test(input)) {
                    // accept strings like '2014-05', but convert to the first of the month
                    input += '-01';
                    args = [ input ]; // for when we pass it on to moment's constructor
                    isAmbigTime = true;
                    isAmbigZone = true;
                }
                else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
                    isAmbigTime = !ambigMatch[5]; // no time part?
                    isAmbigZone = true;
                }
            }
            else if ($.isArray(input)) {
                // arrays have no timezone information, so assume ambiguous zone
                isAmbigZone = true;
            }
            // otherwise, probably a string with a format

            if (parseAsUTC || isAmbigTime) {
                mom = moment.utc.apply(moment, args);
            }
            else {
                mom = moment.apply(null, args);
            }

            if (isAmbigTime) {
                mom._ambigTime = true;
                mom._ambigZone = true; // ambiguous time always means ambiguous zone
            }
            else if (parseZone) { // let's record the inputted zone somehow
                if (isAmbigZone) {
                    mom._ambigZone = true;
                }
                else if (isSingleString) {
                    mom.utcOffset(input); // if not a valid zone, will assign UTC
                }
            }
        }

        mom._fullCalendar = true; // flag for extended functionality

        return mom;
    }


// Week Number
// -------------------------------------------------------------------------------------------------


// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
    newMomentProto.week = newMomentProto.weeks = function(input) {
        var weekCalc = this._locale._fullCalendar_weekCalc;

        if (input == null && typeof weekCalc === 'function') { // custom function only works for getter
            return weekCalc(this);
        }
        else if (weekCalc === 'ISO') {
            return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
        }

        return oldMomentProto.week.apply(this, arguments); // local getter/setter
    };


// Time-of-day
// -------------------------------------------------------------------------------------------------

// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
    newMomentProto.time = function(time) {

        // Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
        // `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
        if (!this._fullCalendar) {
            return oldMomentProto.time.apply(this, arguments);
        }

        if (time == null) { // getter
            return moment.duration({
                hours: this.hours(),
                minutes: this.minutes(),
                seconds: this.seconds(),
                milliseconds: this.milliseconds()
            });
        }
        else { // setter

            this._ambigTime = false; // mark that the moment now has a time

            if (!moment.isDuration(time) && !moment.isMoment(time)) {
                time = moment.duration(time);
            }

            // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
            // Only for Duration times, not Moment times.
            var dayHours = 0;
            if (moment.isDuration(time)) {
                dayHours = Math.floor(time.asDays()) * 24;
            }

            // We need to set the individual fields.
            // Can't use startOf('day') then add duration. In case of DST at start of day.
            return this.hours(dayHours + time.hours())
                .minutes(time.minutes())
                .seconds(time.seconds())
                .milliseconds(time.milliseconds());
        }
    };

// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
    newMomentProto.stripTime = function() {

        if (!this._ambigTime) {

            this.utc(true); // keepLocalTime=true (for keeping *date* value)

            // set time to zero
            this.set({
                hours: 0,
                minutes: 0,
                seconds: 0,
                ms: 0
            });

            // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
            // which clears all ambig flags.
            this._ambigTime = true;
            this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
        }

        return this; // for chaining
    };

// Returns if the moment has a non-ambiguous time (boolean)
    newMomentProto.hasTime = function() {
        return !this._ambigTime;
    };


// Timezone
// -------------------------------------------------------------------------------------------------

// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
    newMomentProto.stripZone = function() {
        var wasAmbigTime;

        if (!this._ambigZone) {

            wasAmbigTime = this._ambigTime;

            this.utc(true); // keepLocalTime=true (for keeping date and time values)

            // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
            this._ambigTime = wasAmbigTime || false;

            // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
            // which clears the ambig flags.
            this._ambigZone = true;
        }

        return this; // for chaining
    };

// Returns of the moment has a non-ambiguous timezone offset (boolean)
    newMomentProto.hasZone = function() {
        return !this._ambigZone;
    };


// implicitly marks a zone
    newMomentProto.local = function(keepLocalTime) {

        // for when converting from ambiguously-zoned to local,
        // keep the time values when converting from UTC -> local
        oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);

        // ensure non-ambiguous
        // this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
        this._ambigTime = false;
        this._ambigZone = false;

        return this; // for chaining
    };


// implicitly marks a zone
    newMomentProto.utc = function(keepLocalTime) {

        oldMomentProto.utc.call(this, keepLocalTime);

        // ensure non-ambiguous
        // this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
        this._ambigTime = false;
        this._ambigZone = false;

        return this;
    };


// implicitly marks a zone (will probably get called upon .utc() and .local())
    newMomentProto.utcOffset = function(tzo) {

        if (tzo != null) { // setter
            // these assignments needs to happen before the original zone method is called.
            // I forget why, something to do with a browser crash.
            this._ambigTime = false;
            this._ambigZone = false;
        }

        return oldMomentProto.utcOffset.apply(this, arguments);
    };


// Formatting
// -------------------------------------------------------------------------------------------------

    newMomentProto.format = function() {

        if (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?
            return formatDate(this, arguments[0]); // our extended formatting
        }
        if (this._ambigTime) {
            return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
        }
        if (this._ambigZone) {
            return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
        }
        if (this._fullCalendar) { // enhanced non-ambig moment?
            // moment.format() doesn't ensure english, but we want to.
            return oldMomentFormat(englishMoment(this));
        }

        return oldMomentProto.format.apply(this, arguments);
    };

    newMomentProto.toISOString = function() {

        if (this._ambigTime) {
            return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
        }
        if (this._ambigZone) {
            return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
        }
        if (this._fullCalendar) { // enhanced non-ambig moment?
            // depending on browser, moment might not output english. ensure english.
            // https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22
            return oldMomentProto.toISOString.apply(englishMoment(this), arguments);
        }

        return oldMomentProto.toISOString.apply(this, arguments);
    };

    function englishMoment(mom) {
        if (mom.locale() !== 'en') {
            return mom.clone().locale('en');
        }
        return mom;
    }

    ;;
    (function() {

// exports
        FC.formatDate = formatDate;
        FC.formatRange = formatRange;
        FC.oldMomentFormat = oldMomentFormat;
        FC.queryMostGranularFormatUnit = queryMostGranularFormatUnit;


// Config
// ---------------------------------------------------------------------------------------------------------------------

        /*
         Inserted between chunks in the fake ("intermediate") formatting string.
         Important that it passes as whitespace (\s) because moment often identifies non-standalone months
         via a regexp with an \s.
         */
        var PART_SEPARATOR = '\u000b'; // vertical tab

        /*
         Inserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,
         but rather, a "special" token that has custom rendering (see specialTokens map).
         */
        var SPECIAL_TOKEN_MARKER = '\u001f'; // information separator 1

        /*
         Inserted at the beginning and end of a span of text that must have non-zero numeric characters.
         Handling of these markers is done in a post-processing step at the very end of text rendering.
         */
        var MAYBE_MARKER = '\u001e'; // information separator 2
        var MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global

        /*
         Addition formatting tokens we want recognized
         */
        var specialTokens = {
            t: function(date) { // "a" or "p"
                return oldMomentFormat(date, 'a').charAt(0);
            },
            T: function(date) { // "A" or "P"
                return oldMomentFormat(date, 'A').charAt(0);
            }
        };

        /*
         The first characters of formatting tokens for units that are 1 day or larger.
         `value` is for ranking relative size (lower means bigger).
         `unit` is a normalized unit, used for comparing moments.
         */
        var largeTokenMap = {
            Y: { value: 1, unit: 'year' },
            M: { value: 2, unit: 'month' },
            W: { value: 3, unit: 'week' }, // ISO week
            w: { value: 3, unit: 'week' }, // local week
            D: { value: 4, unit: 'day' }, // day of month
            d: { value: 4, unit: 'day' } // day of week
        };


// Single Date Formatting
// ---------------------------------------------------------------------------------------------------------------------

        /*
         Formats `date` with a Moment formatting string, but allow our non-zero areas and special token
         */
        function formatDate(date, formatStr) {
            return renderFakeFormatString(
                getParsedFormatString(formatStr).fakeFormatString,
                date
            );
        }

        /*
         Call this if you want Moment's original format method to be used
         */
        function oldMomentFormat(mom, formatStr) {
            return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
        }


// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset

        /*
         Using a formatting string meant for a single date, generate a range string, like
         "Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
         If the dates are the same as far as the format string is concerned, just return a single
         rendering of one date, without any separator.
         */
        function formatRange(date1, date2, formatStr, separator, isRTL) {
            var localeData;

            date1 = FC.moment.parseZone(date1);
            date2 = FC.moment.parseZone(date2);

            localeData = date1.localeData();

            // Expand localized format strings, like "LL" -> "MMMM D YYYY".
            // BTW, this is not important for `formatDate` because it is impossible to put custom tokens
            // or non-zero areas in Moment's localized format strings.
            formatStr = localeData.longDateFormat(formatStr) || formatStr;

            return renderParsedFormat(
                getParsedFormatString(formatStr),
                date1,
                date2,
                separator || ' - ',
                isRTL
            );
        }

        /*
         Renders a range with an already-parsed format string.
         */
        function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {
            var sameUnits = parsedFormat.sameUnits;
            var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons
            var unzonedDate2 = date2.clone().stripZone(); // "

            var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);
            var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);

            var leftI;
            var leftStr = '';
            var rightI;
            var rightStr = '';
            var middleI;
            var middleStr1 = '';
            var middleStr2 = '';
            var middleStr = '';

            // Start at the leftmost side of the formatting string and continue until you hit a token
            // that is not the same between dates.
            for (
                leftI = 0;
                leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI]));
                leftI++
            ) {
                leftStr += renderedParts1[leftI];
            }

            // Similarly, start at the rightmost side of the formatting string and move left
            for (
                rightI = sameUnits.length - 1;
                rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI]));
                rightI--
            ) {
                // If current chunk is on the boundary of unique date-content, and is a special-case
                // date-formatting postfix character, then don't consume it. Consider it unique date-content.
                // TODO: make configurable
                if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {
                    break;
                }

                rightStr = renderedParts1[rightI] + rightStr;
            }

            // The area in the middle is different for both of the dates.
            // Collect them distinctly so we can jam them together later.
            for (middleI = leftI; middleI <= rightI; middleI++) {
                middleStr1 += renderedParts1[middleI];
                middleStr2 += renderedParts2[middleI];
            }

            if (middleStr1 || middleStr2) {
                if (isRTL) {
                    middleStr = middleStr2 + separator + middleStr1;
                }
                else {
                    middleStr = middleStr1 + separator + middleStr2;
                }
            }

            return processMaybeMarkers(
                leftStr + middleStr + rightStr
            );
        }


// Format String Parsing
// ---------------------------------------------------------------------------------------------------------------------

        var parsedFormatStrCache = {};

        /*
         Returns a parsed format string, leveraging a cache.
         */
        function getParsedFormatString(formatStr) {
            return parsedFormatStrCache[formatStr] ||
                (parsedFormatStrCache[formatStr] = parseFormatString(formatStr));
        }

        /*
         Parses a format string into the following:
         - fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.
         - sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like "day"),
         that indicates how similar a range's start & end must be in order to share the same formatted text.
         If not a token, then the value is null.
         Always a flat array (not nested liked "chunks").
         */
        function parseFormatString(formatStr) {
            var chunks = chunkFormatString(formatStr);

            return {
                fakeFormatString: buildFakeFormatString(chunks),
                sameUnits: buildSameUnits(chunks)
            };
        }

        /*
         Break the formatting string into an array of chunks.
         A 'maybe' chunk will have nested chunks.
         */
        function chunkFormatString(formatStr) {
            var chunks = [];
            var match;

            // TODO: more descrimination
            // \4 is a backreference to the first character of a multi-character set.
            var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;

            while ((match = chunker.exec(formatStr))) {
                if (match[1]) { // a literal string inside [ ... ]
                    chunks.push.apply(chunks, // append
                        splitStringLiteral(match[1])
                    );
                }
                else if (match[2]) { // non-zero formatting inside ( ... )
                    chunks.push({ maybe: chunkFormatString(match[2]) });
                }
                else if (match[3]) { // a formatting token
                    chunks.push({ token: match[3] });
                }
                else if (match[5]) { // an unenclosed literal string
                    chunks.push.apply(chunks, // append
                        splitStringLiteral(match[5])
                    );
                }
            }

            return chunks;
        }

        /*
         Potentially splits a literal-text string into multiple parts. For special cases.
         */
        function splitStringLiteral(s) {
            if (s === '. ') {
                return [ '.', ' ' ]; // for locales with periods bound to the end of each year/month/date
            }
            else {
                return [ s ];
            }
        }

        /*
         Given chunks parsed from a real format string, generate a fake (aka "intermediate") format string with special control
         characters that will eventually be given to moment for formatting, and then post-processed.
         */
        function buildFakeFormatString(chunks) {
            var parts = [];
            var i, chunk;

            for (i = 0; i < chunks.length; i++) {
                chunk = chunks[i];

                if (typeof chunk === 'string') {
                    parts.push('[' + chunk + ']');
                }
                else if (chunk.token) {
                    if (chunk.token in specialTokens) {
                        parts.push(
                            SPECIAL_TOKEN_MARKER + // useful during post-processing
                            '[' + chunk.token + ']' // preserve as literal text
                        );
                    }
                    else {
                        parts.push(chunk.token); // unprotected text implies a format string
                    }
                }
                else if (chunk.maybe) {
                    parts.push(
                        MAYBE_MARKER + // useful during post-processing
                        buildFakeFormatString(chunk.maybe) +
                        MAYBE_MARKER
                    );
                }
            }

            return parts.join(PART_SEPARATOR);
        }

        /*
         Given parsed chunks from a real formatting string, generates an array of unit strings (like "day") that indicate
         in which regard two dates must be similar in order to share range formatting text.
         The `chunks` can be nested (because of "maybe" chunks), however, the returned array will be flat.
         */
        function buildSameUnits(chunks) {
            var units = [];
            var i, chunk;
            var tokenInfo;

            for (i = 0; i < chunks.length; i++) {
                chunk = chunks[i];

                if (chunk.token) {
                    tokenInfo = largeTokenMap[chunk.token.charAt(0)];
                    units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second
                }
                else if (chunk.maybe) {
                    units.push.apply(units, // append
                        buildSameUnits(chunk.maybe)
                    );
                }
                else {
                    units.push(null);
                }
            }

            return units;
        }


// Rendering to text
// ---------------------------------------------------------------------------------------------------------------------

        /*
         Formats a date with a fake format string, post-processes the control characters, then returns.
         */
        function renderFakeFormatString(fakeFormatString, date) {
            return processMaybeMarkers(
                renderFakeFormatStringParts(fakeFormatString, date).join('')
            );
        }

        /*
         Formats a date into parts that will have been post-processed, EXCEPT for the "maybe" markers.
         */
        function renderFakeFormatStringParts(fakeFormatString, date) {
            var parts = [];
            var fakeRender = oldMomentFormat(date, fakeFormatString);
            var fakeParts = fakeRender.split(PART_SEPARATOR);
            var i, fakePart;

            for (i = 0; i < fakeParts.length; i++) {
                fakePart = fakeParts[i];

                if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {
                    parts.push(
                        // the literal string IS the token's name.
                        // call special token's registered function.
                        specialTokens[fakePart.substring(1)](date)
                    );
                }
                else {
                    parts.push(fakePart);
                }
            }

            return parts;
        }

        /*
         Accepts an almost-finally-formatted string and processes the "maybe" control characters, returning a new string.
         */
        function processMaybeMarkers(s) {
            return s.replace(MAYBE_REGEXP, function(m0, m1) { // regex assumed to have 'g' flag
                if (m1.match(/[1-9]/)) { // any non-zero numeric characters?
                    return m1;
                }
                else {
                    return '';
                }
            });
        }


// Misc Utils
// -------------------------------------------------------------------------------------------------

        /*
         Returns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.
         */
        function queryMostGranularFormatUnit(formatStr) {
            var chunks = chunkFormatString(formatStr);
            var i, chunk;
            var candidate;
            var best;

            for (i = 0; i < chunks.length; i++) {
                chunk = chunks[i];

                if (chunk.token) {
                    candidate = largeTokenMap[chunk.token.charAt(0)];
                    if (candidate) {
                        if (!best || candidate.value > best.value) {
                            best = candidate;
                        }
                    }
                }
            }

            if (best) {
                return best.unit;
            }

            return null;
        };

    })();

// quick local references
    var formatDate = FC.formatDate;
    var formatRange = FC.formatRange;
    var oldMomentFormat = FC.oldMomentFormat;

    ;;

    FC.Class = Class; // export

// Class that all other classes will inherit from
    function Class() { }


// Called on a class to create a subclass.
// Last argument contains instance methods. Any argument before the last are considered mixins.
    Class.extend = function() {
        var len = arguments.length;
        var i;
        var members;

        for (i = 0; i < len; i++) {
            members = arguments[i];
            if (i < len - 1) { // not the last argument?
                mixIntoClass(this, members);
            }
        }

        return extendClass(this, members || {}); // members will be undefined if no arguments
    };


// Adds new member variables/methods to the class's prototype.
// Can be called with another class, or a plain object hash containing new members.
    Class.mixin = function(members) {
        mixIntoClass(this, members);
    };


    function extendClass(superClass, members) {
        var subClass;

        // ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist
        if (hasOwnProp(members, 'constructor')) {
            subClass = members.constructor;
        }
        if (typeof subClass !== 'function') {
            subClass = members.constructor = function() {
                superClass.apply(this, arguments);
            };
        }

        // build the base prototype for the subclass, which is an new object chained to the superclass's prototype
        subClass.prototype = createObject(superClass.prototype);

        // copy each member variable/method onto the the subclass's prototype
        copyOwnProps(members, subClass.prototype);

        // copy over all class variables/methods to the subclass, such as `extend` and `mixin`
        copyOwnProps(superClass, subClass);

        return subClass;
    }


    function mixIntoClass(theClass, members) {
        copyOwnProps(members, theClass.prototype);
    }
    ;;

    var Model = Class.extend(EmitterMixin, ListenerMixin, {

        _props: null,
        _watchers: null,
        _globalWatchArgs: null,

        constructor: function() {
            this._watchers = {};
            this._props = {};
            this.applyGlobalWatchers();
        },

        applyGlobalWatchers: function() {
            var argSets = this._globalWatchArgs || [];
            var i;

            for (i = 0; i < argSets.length; i++) {
                this.watch.apply(this, argSets[i]);
            }
        },

        has: function(name) {
            return name in this._props;
        },

        get: function(name) {
            if (name === undefined) {
                return this._props;
            }

            return this._props[name];
        },

        set: function(name, val) {
            var newProps;

            if (typeof name === 'string') {
                newProps = {};
                newProps[name] = val === undefined ? null : val;
            }
            else {
                newProps = name;
            }

            this.setProps(newProps);
        },

        reset: function(newProps) {
            var oldProps = this._props;
            var changeset = {}; // will have undefined's to signal unsets
            var name;

            for (name in oldProps) {
                changeset[name] = undefined;
            }

            for (name in newProps) {
                changeset[name] = newProps[name];
            }

            this.setProps(changeset);
        },

        unset: function(name) { // accepts a string or array of strings
            var newProps = {};
            var names;
            var i;

            if (typeof name === 'string') {
                names = [ name ];
            }
            else {
                names = name;
            }

            for (i = 0; i < names.length; i++) {
                newProps[names[i]] = undefined;
            }

            this.setProps(newProps);
        },

        setProps: function(newProps) {
            var changedProps = {};
            var changedCnt = 0;
            var name, val;

            for (name in newProps) {
                val = newProps[name];

                // a change in value?
                // if an object, don't check equality, because might have been mutated internally.
                // TODO: eventually enforce immutability.
                if (
                    typeof val === 'object' ||
                    val !== this._props[name]
                ) {
                    changedProps[name] = val;
                    changedCnt++;
                }
            }

            if (changedCnt) {

                this.trigger('before:batchChange', changedProps);

                for (name in changedProps) {
                    val = changedProps[name];

                    this.trigger('before:change', name, val);
                    this.trigger('before:change:' + name, val);
                }

                for (name in changedProps) {
                    val = changedProps[name];

                    if (val === undefined) {
                        delete this._props[name];
                    }
                    else {
                        this._props[name] = val;
                    }

                    this.trigger('change:' + name, val);
                    this.trigger('change', name, val);
                }

                this.trigger('batchChange', changedProps);
            }
        },

        watch: function(name, depList, startFunc, stopFunc) {
            var _this = this;

            this.unwatch(name);

            this._watchers[name] = this._watchDeps(depList, function(deps) {
                var res = startFunc.call(_this, deps);

                if (res && res.then) {
                    _this.unset(name); // put in an unset state while resolving
                    res.then(function(val) {
                        _this.set(name, val);
                    });
                }
                else {
                    _this.set(name, res);
                }
            }, function() {
                _this.unset(name);

                if (stopFunc) {
                    stopFunc.call(_this);
                }
            });
        },

        unwatch: function(name) {
            var watcher = this._watchers[name];

            if (watcher) {
                delete this._watchers[name];
                watcher.teardown();
            }
        },

        _watchDeps: function(depList, startFunc, stopFunc) {
            var _this = this;
            var queuedChangeCnt = 0;
            var depCnt = depList.length;
            var satisfyCnt = 0;
            var values = {}; // what's passed as the `deps` arguments
            var bindTuples = []; // array of [ eventName, handlerFunc ] arrays
            var isCallingStop = false;

            function onBeforeDepChange(depName, val, isOptional) {
                queuedChangeCnt++;
                if (queuedChangeCnt === 1) { // first change to cause a "stop" ?
                    if (satisfyCnt === depCnt) { // all deps previously satisfied?
                        isCallingStop = true;
                        stopFunc();
                        isCallingStop = false;
                    }
                }
            }

            function onDepChange(depName, val, isOptional) {

                if (val === undefined) { // unsetting a value?

                    // required dependency that was previously set?
                    if (!isOptional && values[depName] !== undefined) {
                        satisfyCnt--;
                    }

                    delete values[depName];
                }
                else { // setting a value?

                    // required dependency that was previously unset?
                    if (!isOptional && values[depName] === undefined) {
                        satisfyCnt++;
                    }

                    values[depName] = val;
                }

                queuedChangeCnt--;
                if (!queuedChangeCnt) { // last change to cause a "start"?

                    // now finally satisfied or satisfied all along?
                    if (satisfyCnt === depCnt) {

                        // if the stopFunc initiated another value change, ignore it.
                        // it will be processed by another change event anyway.
                        if (!isCallingStop) {
                            startFunc(values);
                        }
                    }
                }
            }

            // intercept for .on() that remembers handlers
            function bind(eventName, handler) {
                _this.on(eventName, handler);
                bindTuples.push([ eventName, handler ]);
            }

            // listen to dependency changes
            depList.forEach(function(depName) {
                var isOptional = false;

                if (depName.charAt(0) === '?') { // TODO: more DRY
                    depName = depName.substring(1);
                    isOptional = true;
                }

                bind('before:change:' + depName, function(val) {
                    onBeforeDepChange(depName, val, isOptional);
                });

                bind('change:' + depName, function(val) {
                    onDepChange(depName, val, isOptional);
                });
            });

            // process current dependency values
            depList.forEach(function(depName) {
                var isOptional = false;

                if (depName.charAt(0) === '?') { // TODO: more DRY
                    depName = depName.substring(1);
                    isOptional = true;
                }

                if (_this.has(depName)) {
                    values[depName] = _this.get(depName);
                    satisfyCnt++;
                }
                else if (isOptional) {
                    satisfyCnt++;
                }
            });

            // initially satisfied
            if (satisfyCnt === depCnt) {
                startFunc(values);
            }

            return {
                teardown: function() {
                    // remove all handlers
                    for (var i = 0; i < bindTuples.length; i++) {
                        _this.off(bindTuples[i][0], bindTuples[i][1]);
                    }
                    bindTuples = null;

                    // was satisfied, so call stopFunc
                    if (satisfyCnt === depCnt) {
                        stopFunc();
                    }
                },
                flash: function() {
                    if (satisfyCnt === depCnt) {
                        stopFunc();
                        startFunc(values);
                    }
                }
            };
        },

        flash: function(name) {
            var watcher = this._watchers[name];

            if (watcher) {
                watcher.flash();
            }
        }

    });


    Model.watch = function(/* same arguments as this.watch() */) {
        var proto = this.prototype;

        if (!proto._globalWatchArgs) {
            proto._globalWatchArgs = [];
        }

        proto._globalWatchArgs.push(arguments);
    };


    FC.Model = Model;


    ;;

    var Promise = {

        construct: function(executor) {
            var deferred = $.Deferred();
            var promise = deferred.promise();

            if (typeof executor === 'function') {
                executor(
                    function(val) { // resolve
                        deferred.resolve(val);
                        attachImmediatelyResolvingThen(promise, val);
                    },
                    function() { // reject
                        deferred.reject();
                        attachImmediatelyRejectingThen(promise);
                    }
                );
            }

            return promise;
        },

        resolve: function(val) {
            var deferred = $.Deferred().resolve(val);
            var promise = deferred.promise();

            attachImmediatelyResolvingThen(promise, val);

            return promise;
        },

        reject: function() {
            var deferred = $.Deferred().reject();
            var promise = deferred.promise();

            attachImmediatelyRejectingThen(promise);

            return promise;
        }

    };


    function attachImmediatelyResolvingThen(promise, val) {
        promise.then = function(onResolve) {
            if (typeof onResolve === 'function') {
                onResolve(val);
            }
            return promise; // for chaining
        };
    }


    function attachImmediatelyRejectingThen(promise) {
        promise.then = function(onResolve, onReject) {
            if (typeof onReject === 'function') {
                onReject();
            }
            return promise; // for chaining
        };
    }


    FC.Promise = Promise;

    ;;

    var TaskQueue = Class.extend(EmitterMixin, {

        q: null,
        isPaused: false,
        isRunning: false,


        constructor: function() {
            this.q = [];
        },


        queue: function(/* taskFunc, taskFunc... */) {
            this.q.push.apply(this.q, arguments); // append
            this.tryStart();
        },


        pause: function() {
            this.isPaused = true;
        },


        resume: function() {
            this.isPaused = false;
            this.tryStart();
        },


        tryStart: function() {
            if (!this.isRunning && this.canRunNext()) {
                this.isRunning = true;
                this.trigger('start');
                this.runNext();
            }
        },


        canRunNext: function() {
            return !this.isPaused && this.q.length;
        },


        runNext: function() { // does not check canRunNext
            this.runTask(this.q.shift());
        },


        runTask: function(task) {
            this.runTaskFunc(task);
        },


        runTaskFunc: function(taskFunc) {
            var _this = this;
            var res = taskFunc();

            if (res && res.then) {
                res.then(done);
            }
            else {
                done();
            }

            function done() {
                if (_this.canRunNext()) {
                    _this.runNext();
                }
                else {
                    _this.isRunning = false;
                    _this.trigger('stop');
                }
            }
        }

    });

    FC.TaskQueue = TaskQueue;

    ;;

    var RenderQueue = TaskQueue.extend({

        waitsByNamespace: null,
        waitNamespace: null,
        waitId: null,


        constructor: function(waitsByNamespace) {
            TaskQueue.call(this); // super-constructor

            this.waitsByNamespace = waitsByNamespace || {};
        },


        queue: function(taskFunc, namespace, type) {
            var task = {
                func: taskFunc,
                namespace: namespace,
                type: type
            };
            var waitMs;

            if (namespace) {
                waitMs = this.waitsByNamespace[namespace];
            }

            if (this.waitNamespace) {
                if (namespace === this.waitNamespace && waitMs != null) {
                    this.delayWait(waitMs);
                }
                else {
                    this.clearWait();
                    this.tryStart();
                }
            }

            if (this.compoundTask(task)) { // appended to queue?

                if (!this.waitNamespace && waitMs != null) {
                    this.startWait(namespace, waitMs);
                }
                else {
                    this.tryStart();
                }
            }
        },


        startWait: function(namespace, waitMs) {
            this.waitNamespace = namespace;
            this.spawnWait(waitMs);
        },


        delayWait: function(waitMs) {
            clearTimeout(this.waitId);
            this.spawnWait(waitMs);
        },


        spawnWait: function(waitMs) {
            var _this = this;

            this.waitId = setTimeout(function() {
                _this.waitNamespace = null;
                _this.tryStart();
            }, waitMs);
        },


        clearWait: function() {
            if (this.waitNamespace) {
                clearTimeout(this.waitId);
                this.waitId = null;
                this.waitNamespace = null;
            }
        },


        canRunNext: function() {
            if (!TaskQueue.prototype.canRunNext.apply(this, arguments)) {
                return false;
            }

            // waiting for a certain namespace to stop receiving tasks?
            if (this.waitNamespace) {

                // if there was a different namespace task in the meantime,
                // that forces all previously-waiting tasks to suddenly execute.
                // TODO: find a way to do this in constant time.
                for (var q = this.q, i = 0; i < q.length; i++) {
                    if (q[i].namespace !== this.waitNamespace) {
                        return true; // allow execution
                    }
                }

                return false;
            }

            return true;
        },


        runTask: function(task) {
            this.runTaskFunc(task.func);
        },


        compoundTask: function(newTask) {
            var q = this.q;
            var shouldAppend = true;
            var i, task;

            if (newTask.namespace) {

                if (newTask.type === 'destroy' || newTask.type === 'init') {

                    // remove all add/remove ops with same namespace, regardless of order
                    for (i = q.length - 1; i >= 0; i--) {
                        task = q[i];

                        if (
                            task.namespace === newTask.namespace &&
                            (task.type === 'add' || task.type === 'remove')
                        ) {
                            q.splice(i, 1); // remove task
                        }
                    }

                    if (newTask.type === 'destroy') {
                        // eat away final init/destroy operation
                        if (q.length) {
                            task = q[q.length - 1]; // last task

                            if (task.namespace === newTask.namespace) {

                                // the init and our destroy cancel each other out
                                if (task.type === 'init') {
                                    shouldAppend = false;
                                    q.pop();
                                }
                                // prefer to use the destroy operation that's already present
                                else if (task.type === 'destroy') {
                                    shouldAppend = false;
                                }
                            }
                        }
                    }
                    else if (newTask.type === 'init') {
                        // eat away final init operation
                        if (q.length) {
                            task = q[q.length - 1]; // last task

                            if (
                                task.namespace === newTask.namespace &&
                                task.type === 'init'
                            ) {
                                // our init operation takes precedence
                                q.pop();
                            }
                        }
                    }
                }
            }

            if (shouldAppend) {
                q.push(newTask);
            }

            return shouldAppend;
        }

    });

    FC.RenderQueue = RenderQueue;

    ;;

    var EmitterMixin = FC.EmitterMixin = {

        // jQuery-ification via $(this) allows a non-DOM object to have
        // the same event handling capabilities (including namespaces).


        on: function(types, handler) {
            $(this).on(types, this._prepareIntercept(handler));
            return this; // for chaining
        },


        one: function(types, handler) {
            $(this).one(types, this._prepareIntercept(handler));
            return this; // for chaining
        },


        _prepareIntercept: function(handler) {
            // handlers are always called with an "event" object as their first param.
            // sneak the `this` context and arguments into the extra parameter object
            // and forward them on to the original handler.
            var intercept = function(ev, extra) {
                return handler.apply(
                    extra.context || this,
                    extra.args || []
                );
            };

            // mimick jQuery's internal "proxy" system (risky, I know)
            // causing all functions with the same .guid to appear to be the same.
            // https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448
            // this is needed for calling .off with the original non-intercept handler.
            if (!handler.guid) {
                handler.guid = $.guid++;
            }
            intercept.guid = handler.guid;

            return intercept;
        },


        off: function(types, handler) {
            $(this).off(types, handler);

            return this; // for chaining
        },


        trigger: function(types) {
            var args = Array.prototype.slice.call(arguments, 1); // arguments after the first

            // pass in "extra" info to the intercept
            $(this).triggerHandler(types, { args: args });

            return this; // for chaining
        },


        triggerWith: function(types, context, args) {

            // `triggerHandler` is less reliant on the DOM compared to `trigger`.
            // pass in "extra" info to the intercept.
            $(this).triggerHandler(types, { context: context, args: args });

            return this; // for chaining
        }

    };

    ;;

    /*
     Utility methods for easily listening to events on another object,
     and more importantly, easily unlistening from them.
     */
    var ListenerMixin = FC.ListenerMixin = (function() {
        var guid = 0;
        var ListenerMixin = {

            listenerId: null,

            /*
             Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.
             The `callback` will be called with the `this` context of the object that .listenTo is being called on.
             Can be called:
             .listenTo(other, eventName, callback)
             OR
             .listenTo(other, {
             eventName1: callback1,
             eventName2: callback2
             })
             */
            listenTo: function(other, arg, callback) {
                if (typeof arg === 'object') { // given dictionary of callbacks
                    for (var eventName in arg) {
                        if (arg.hasOwnProperty(eventName)) {
                            this.listenTo(other, eventName, arg[eventName]);
                        }
                    }
                }
                else if (typeof arg === 'string') {
                    other.on(
                        arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object
                        $.proxy(callback, this) // always use `this` context
                        // the usually-undesired jQuery guid behavior doesn't matter,
                        // because we always unbind via namespace
                    );
                }
            },

            /*
             Causes the current object to stop listening to events on the `other` object.
             `eventName` is optional. If omitted, will stop listening to ALL events on `other`.
             */
            stopListeningTo: function(other, eventName) {
                other.off((eventName || '') + '.' + this.getListenerNamespace());
            },

            /*
             Returns a string, unique to this object, to be used for event namespacing
             */
            getListenerNamespace: function() {
                if (this.listenerId == null) {
                    this.listenerId = guid++;
                }
                return '_listener' + this.listenerId;
            }

        };
        return ListenerMixin;
    })();
    ;;

    /* A rectangular panel that is absolutely positioned over other content
     ------------------------------------------------------------------------------------------------------------------------
     Options:
     - className (string)
     - content (HTML string or jQuery element set)
     - parentEl
     - top
     - left
     - right (the x coord of where the right edge should be. not a "CSS" right)
     - autoHide (boolean)
     - show (callback)
     - hide (callback)
     */

    var Popover = Class.extend(ListenerMixin, {

        isHidden: true,
        options: null,
        el: null, // the container element for the popover. generated by this object
        margin: 10, // the space required between the popover and the edges of the scroll container


        constructor: function(options) {
            this.options = options || {};
        },


        // Shows the popover on the specified position. Renders it if not already
        show: function() {
            if (this.isHidden) {
                if (!this.el) {
                    this.render();
                }
                this.el.show();
                this.position();
                this.isHidden = false;
                this.trigger('show');
            }
        },


        // Hides the popover, through CSS, but does not remove it from the DOM
        hide: function() {
            if (!this.isHidden) {
                this.el.hide();
                this.isHidden = true;
                this.trigger('hide');
            }
        },


        // Creates `this.el` and renders content inside of it
        render: function() {
            var _this = this;
            var options = this.options;

            this.el = $('<div class="fc-popover"/>')
                .addClass(options.className || '')
                .css({
                    // position initially to the top left to avoid creating scrollbars
                    top: 0,
                    left: 0
                })
                .append(options.content)
                .appendTo(options.parentEl);

            // when a click happens on anything inside with a 'fc-close' className, hide the popover
            this.el.on('click', '.fc-close', function() {
                _this.hide();
            });

            if (options.autoHide) {
                this.listenTo($(document), 'mousedown', this.documentMousedown);
            }
        },


        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature
        documentMousedown: function(ev) {
            // only hide the popover if the click happened outside the popover
            if (this.el && !$(ev.target).closest(this.el).length) {
                this.hide();
            }
        },


        // Hides and unregisters any handlers
        removeElement: function() {
            this.hide();

            if (this.el) {
                this.el.remove();
                this.el = null;
            }

            this.stopListeningTo($(document), 'mousedown');
        },


        // Positions the popover optimally, using the top/left/right options
        position: function() {
            var options = this.options;
            var origin = this.el.offsetParent().offset();
            var width = this.el.outerWidth();
            var height = this.el.outerHeight();
            var windowEl = $(window);
            var viewportEl = getScrollParent(this.el);
            var viewportTop;
            var viewportLeft;
            var viewportOffset;
            var top; // the "position" (not "offset") values for the popover
            var left; //

            // compute top and left
            top = options.top || 0;
            if (options.left !== undefined) {
                left = options.left;
            }
            else if (options.right !== undefined) {
                left = options.right - width; // derive the left value from the right value
            }
            else {
                left = 0;
            }

            if (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result
                viewportEl = windowEl;
                viewportTop = 0; // the window is always at the top left
                viewportLeft = 0; // (and .offset() won't work if called here)
            }
            else {
                viewportOffset = viewportEl.offset();
                viewportTop = viewportOffset.top;
                viewportLeft = viewportOffset.left;
            }

            // if the window is scrolled, it causes the visible area to be further down
            viewportTop += windowEl.scrollTop();
            viewportLeft += windowEl.scrollLeft();

            // constrain to the view port. if constrained by two edges, give precedence to top/left
            if (options.viewportConstrain !== false) {
                top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
                top = Math.max(top, viewportTop + this.margin);
                left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
                left = Math.max(left, viewportLeft + this.margin);
            }

            this.el.css({
                top: top - origin.top,
                left: left - origin.left
            });
        },


        // Triggers a callback. Calls a function in the option hash of the same name.
        // Arguments beyond the first `name` are forwarded on.
        // TODO: better code reuse for this. Repeat code
        trigger: function(name) {
            if (this.options[name]) {
                this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
            }
        }

    });

    ;;

    /*
     A cache for the left/right/top/bottom/width/height values for one or more elements.
     Works with both offset (from topleft document) and position (from offsetParent).

     options:
     - els
     - isHorizontal
     - isVertical
     */
    var CoordCache = FC.CoordCache = Class.extend({

        els: null, // jQuery set (assumed to be siblings)
        forcedOffsetParentEl: null, // options can override the natural offsetParent
        origin: null, // {left,top} position of offsetParent of els
        boundingRect: null, // constrain cordinates to this rectangle. {left,right,top,bottom} or null
        isHorizontal: false, // whether to query for left/right/width
        isVertical: false, // whether to query for top/bottom/height

        // arrays of coordinates (offsets from topleft of document)
        lefts: null,
        rights: null,
        tops: null,
        bottoms: null,


        constructor: function(options) {
            this.els = $(options.els);
            this.isHorizontal = options.isHorizontal;
            this.isVertical = options.isVertical;
            this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
        },


        // Queries the els for coordinates and stores them.
        // Call this method before using and of the get* methods below.
        build: function() {
            var offsetParentEl = this.forcedOffsetParentEl;
            if (!offsetParentEl && this.els.length > 0) {
                offsetParentEl = this.els.eq(0).offsetParent();
            }

            this.origin = offsetParentEl ?
                offsetParentEl.offset() :
                null;

            this.boundingRect = this.queryBoundingRect();

            if (this.isHorizontal) {
                this.buildElHorizontals();
            }
            if (this.isVertical) {
                this.buildElVerticals();
            }
        },


        // Destroys all internal data about coordinates, freeing memory
        clear: function() {
            this.origin = null;
            this.boundingRect = null;
            this.lefts = null;
            this.rights = null;
            this.tops = null;
            this.bottoms = null;
        },


        // When called, if coord caches aren't built, builds them
        ensureBuilt: function() {
            if (!this.origin) {
                this.build();
            }
        },


        // Populates the left/right internal coordinate arrays
        buildElHorizontals: function() {
            var lefts = [];
            var rights = [];

            this.els.each(function(i, node) {
                var el = $(node);
                var left = el.offset().left;
                var width = el.outerWidth();

                lefts.push(left);
                rights.push(left + width);
            });

            this.lefts = lefts;
            this.rights = rights;
        },


        // Populates the top/bottom internal coordinate arrays
        buildElVerticals: function() {
            var tops = [];
            var bottoms = [];

            this.els.each(function(i, node) {
                var el = $(node);
                var top = el.offset().top;
                var height = el.outerHeight();

                tops.push(top);
                bottoms.push(top + height);
            });

            this.tops = tops;
            this.bottoms = bottoms;
        },


        // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
        // If no intersection is made, returns undefined.
        getHorizontalIndex: function(leftOffset) {
            this.ensureBuilt();

            var lefts = this.lefts;
            var rights = this.rights;
            var len = lefts.length;
            var i;

            for (i = 0; i < len; i++) {
                if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
                    return i;
                }
            }
        },


        // Given a top offset (from document top), returns the index of the el that it vertically intersects.
        // If no intersection is made, returns undefined.
        getVerticalIndex: function(topOffset) {
            this.ensureBuilt();

            var tops = this.tops;
            var bottoms = this.bottoms;
            var len = tops.length;
            var i;

            for (i = 0; i < len; i++) {
                if (topOffset >= tops[i] && topOffset < bottoms[i]) {
                    return i;
                }
            }
        },


        // Gets the left offset (from document left) of the element at the given index
        getLeftOffset: function(leftIndex) {
            this.ensureBuilt();
            return this.lefts[leftIndex];
        },


        // Gets the left position (from offsetParent left) of the element at the given index
        getLeftPosition: function(leftIndex) {
            this.ensureBuilt();
            return this.lefts[leftIndex] - this.origin.left;
        },


        // Gets the right offset (from document left) of the element at the given index.
        // This value is NOT relative to the document's right edge, like the CSS concept of "right" would be.
        getRightOffset: function(leftIndex) {
            this.ensureBuilt();
            return this.rights[leftIndex];
        },


        // Gets the right position (from offsetParent left) of the element at the given index.
        // This value is NOT relative to the offsetParent's right edge, like the CSS concept of "right" would be.
        getRightPosition: function(leftIndex) {
            this.ensureBuilt();
            return this.rights[leftIndex] - this.origin.left;
        },


        // Gets the width of the element at the given index
        getWidth: function(leftIndex) {
            this.ensureBuilt();
            return this.rights[leftIndex] - this.lefts[leftIndex];
        },


        // Gets the top offset (from document top) of the element at the given index
        getTopOffset: function(topIndex) {
            this.ensureBuilt();
            return this.tops[topIndex];
        },


        // Gets the top position (from offsetParent top) of the element at the given position
        getTopPosition: function(topIndex) {
            this.ensureBuilt();
            return this.tops[topIndex] - this.origin.top;
        },

        // Gets the bottom offset (from the document top) of the element at the given index.
        // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
        getBottomOffset: function(topIndex) {
            this.ensureBuilt();
            return this.bottoms[topIndex];
        },


        // Gets the bottom position (from the offsetParent top) of the element at the given index.
        // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
        getBottomPosition: function(topIndex) {
            this.ensureBuilt();
            return this.bottoms[topIndex] - this.origin.top;
        },


        // Gets the height of the element at the given index
        getHeight: function(topIndex) {
            this.ensureBuilt();
            return this.bottoms[topIndex] - this.tops[topIndex];
        },


        // Bounding Rect
        // TODO: decouple this from CoordCache

        // Compute and return what the elements' bounding rectangle is, from the user's perspective.
        // Right now, only returns a rectangle if constrained by an overflow:scroll element.
        // Returns null if there are no elements
        queryBoundingRect: function() {
            var scrollParentEl;

            if (this.els.length > 0) {
                scrollParentEl = getScrollParent(this.els.eq(0));

                if (!scrollParentEl.is(document)) {
                    return getClientRect(scrollParentEl);
                }
            }

            return null;
        },

        isPointInBounds: function(leftOffset, topOffset) {
            return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);
        },

        isLeftInBounds: function(leftOffset) {
            return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);
        },

        isTopInBounds: function(topOffset) {
            return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);
        }

    });

    ;;

    /* Tracks a drag's mouse movement, firing various handlers
     ----------------------------------------------------------------------------------------------------------------------*/
// TODO: use Emitter

    var DragListener = FC.DragListener = Class.extend(ListenerMixin, {

        options: null,
        subjectEl: null,

        // coordinates of the initial mousedown
        originX: null,
        originY: null,

        // the wrapping element that scrolls, or MIGHT scroll if there's overflow.
        // TODO: do this for wrappers that have overflow:hidden as well.
        scrollEl: null,

        isInteracting: false,
        isDistanceSurpassed: false,
        isDelayEnded: false,
        isDragging: false,
        isTouch: false,
        isGeneric: false, // initiated by 'dragstart' (jqui)

        delay: null,
        delayTimeoutId: null,
        minDistance: null,

        shouldCancelTouchScroll: true,
        scrollAlwaysKills: false,


        constructor: function(options) {
            this.options = options || {};
        },


        // Interaction (high-level)
        // -----------------------------------------------------------------------------------------------------------------


        startInteraction: function(ev, extraOptions) {

            if (ev.type === 'mousedown') {
                if (GlobalEmitter.get().shouldIgnoreMouse()) {
                    return;
                }
                else if (!isPrimaryMouseButton(ev)) {
                    return;
                }
                else {
                    ev.preventDefault(); // prevents native selection in most browsers
                }
            }

            if (!this.isInteracting) {

                // process options
                extraOptions = extraOptions || {};
                this.delay = firstDefined(extraOptions.delay, this.options.delay, 0);
                this.minDistance = firstDefined(extraOptions.distance, this.options.distance, 0);
                this.subjectEl = this.options.subjectEl;

                preventSelection($('body'));

                this.isInteracting = true;
                this.isTouch = getEvIsTouch(ev);
                this.isGeneric = ev.type === 'dragstart';
                this.isDelayEnded = false;
                this.isDistanceSurpassed = false;

                this.originX = getEvX(ev);
                this.originY = getEvY(ev);
                this.scrollEl = getScrollParent($(ev.target));

                this.bindHandlers();
                this.initAutoScroll();
                this.handleInteractionStart(ev);
                this.startDelay(ev);

                if (!this.minDistance) {
                    this.handleDistanceSurpassed(ev);
                }
            }
        },


        handleInteractionStart: function(ev) {
            this.trigger('interactionStart', ev);
        },


        endInteraction: function(ev, isCancelled) {
            if (this.isInteracting) {
                this.endDrag(ev);

                if (this.delayTimeoutId) {
                    clearTimeout(this.delayTimeoutId);
                    this.delayTimeoutId = null;
                }

                this.destroyAutoScroll();
                this.unbindHandlers();

                this.isInteracting = false;
                this.handleInteractionEnd(ev, isCancelled);

                allowSelection($('body'));
            }
        },


        handleInteractionEnd: function(ev, isCancelled) {
            this.trigger('interactionEnd', ev, isCancelled || false);
        },


        // Binding To DOM
        // -----------------------------------------------------------------------------------------------------------------


        bindHandlers: function() {
            // some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,
            // so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.
            var globalEmitter = GlobalEmitter.get();

            if (this.isGeneric) {
                this.listenTo($(document), { // might only work on iOS because of GlobalEmitter's bind :(
                    drag: this.handleMove,
                    dragstop: this.endInteraction
                });
            }
            else if (this.isTouch) {
                this.listenTo(globalEmitter, {
                    touchmove: this.handleTouchMove,
                    touchend: this.endInteraction,
                    scroll: this.handleTouchScroll
                });
            }
            else {
                this.listenTo(globalEmitter, {
                    mousemove: this.handleMouseMove,
                    mouseup: this.endInteraction
                });
            }

            this.listenTo(globalEmitter, {
                selectstart: preventDefault, // don't allow selection while dragging
                contextmenu: preventDefault // long taps would open menu on Chrome dev tools
            });
        },


        unbindHandlers: function() {
            this.stopListeningTo(GlobalEmitter.get());
            this.stopListeningTo($(document)); // for isGeneric
        },


        // Drag (high-level)
        // -----------------------------------------------------------------------------------------------------------------


        // extraOptions ignored if drag already started
        startDrag: function(ev, extraOptions) {
            this.startInteraction(ev, extraOptions); // ensure interaction began

            if (!this.isDragging) {
                this.isDragging = true;
                this.handleDragStart(ev);
            }
        },


        handleDragStart: function(ev) {
            this.trigger('dragStart', ev);
        },


        handleMove: function(ev) {
            var dx = getEvX(ev) - this.originX;
            var dy = getEvY(ev) - this.originY;
            var minDistance = this.minDistance;
            var distanceSq; // current distance from the origin, squared

            if (!this.isDistanceSurpassed) {
                distanceSq = dx * dx + dy * dy;
                if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem
                    this.handleDistanceSurpassed(ev);
                }
            }

            if (this.isDragging) {
                this.handleDrag(dx, dy, ev);
            }
        },


        // Called while the mouse is being moved and when we know a legitimate drag is taking place
        handleDrag: function(dx, dy, ev) {
            this.trigger('drag', dx, dy, ev);
            this.updateAutoScroll(ev); // will possibly cause scrolling
        },


        endDrag: function(ev) {
            if (this.isDragging) {
                this.isDragging = false;
                this.handleDragEnd(ev);
            }
        },


        handleDragEnd: function(ev) {
            this.trigger('dragEnd', ev);
        },


        // Delay
        // -----------------------------------------------------------------------------------------------------------------


        startDelay: function(initialEv) {
            var _this = this;

            if (this.delay) {
                this.delayTimeoutId = setTimeout(function() {
                    _this.handleDelayEnd(initialEv);
                }, this.delay);
            }
            else {
                this.handleDelayEnd(initialEv);
            }
        },


        handleDelayEnd: function(initialEv) {
            this.isDelayEnded = true;

            if (this.isDistanceSurpassed) {
                this.startDrag(initialEv);
            }
        },


        // Distance
        // -----------------------------------------------------------------------------------------------------------------


        handleDistanceSurpassed: function(ev) {
            this.isDistanceSurpassed = true;

            if (this.isDelayEnded) {
                this.startDrag(ev);
            }
        },


        // Mouse / Touch
        // -----------------------------------------------------------------------------------------------------------------


        handleTouchMove: function(ev) {

            // prevent inertia and touchmove-scrolling while dragging
            if (this.isDragging && this.shouldCancelTouchScroll) {
                ev.preventDefault();
            }

            this.handleMove(ev);
        },


        handleMouseMove: function(ev) {
            this.handleMove(ev);
        },


        // Scrolling (unrelated to auto-scroll)
        // -----------------------------------------------------------------------------------------------------------------


        handleTouchScroll: function(ev) {
            // if the drag is being initiated by touch, but a scroll happens before
            // the drag-initiating delay is over, cancel the drag
            if (!this.isDragging || this.scrollAlwaysKills) {
                this.endInteraction(ev, true); // isCancelled=true
            }
        },


        // Utils
        // -----------------------------------------------------------------------------------------------------------------


        // Triggers a callback. Calls a function in the option hash of the same name.
        // Arguments beyond the first `name` are forwarded on.
        trigger: function(name) {
            if (this.options[name]) {
                this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
            }
            // makes _methods callable by event name. TODO: kill this
            if (this['_' + name]) {
                this['_' + name].apply(this, Array.prototype.slice.call(arguments, 1));
            }
        }


    });

    ;;
    /*
     this.scrollEl is set in DragListener
     */
    DragListener.mixin({

        isAutoScroll: false,

        scrollBounds: null, // { top, bottom, left, right }
        scrollTopVel: null, // pixels per second
        scrollLeftVel: null, // pixels per second
        scrollIntervalId: null, // ID of setTimeout for scrolling animation loop

        // defaults
        scrollSensitivity: 30, // pixels from edge for scrolling to start
        scrollSpeed: 200, // pixels per second, at maximum speed
        scrollIntervalMs: 50, // millisecond wait between scroll increment


        initAutoScroll: function() {
            var scrollEl = this.scrollEl;

            this.isAutoScroll =
                this.options.scroll &&
                scrollEl &&
                !scrollEl.is(window) &&
                !scrollEl.is(document);

            if (this.isAutoScroll) {
                // debounce makes sure rapid calls don't happen
                this.listenTo(scrollEl, 'scroll', debounce(this.handleDebouncedScroll, 100));
            }
        },


        destroyAutoScroll: function() {
            this.endAutoScroll(); // kill any animation loop

            // remove the scroll handler if there is a scrollEl
            if (this.isAutoScroll) {
                this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(
            }
        },


        // Computes and stores the bounding rectangle of scrollEl
        computeScrollBounds: function() {
            if (this.isAutoScroll) {
                this.scrollBounds = getOuterRect(this.scrollEl);
                // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
            }
        },


        // Called when the dragging is in progress and scrolling should be updated
        updateAutoScroll: function(ev) {
            var sensitivity = this.scrollSensitivity;
            var bounds = this.scrollBounds;
            var topCloseness, bottomCloseness;
            var leftCloseness, rightCloseness;
            var topVel = 0;
            var leftVel = 0;

            if (bounds) { // only scroll if scrollEl exists

                // compute closeness to edges. valid range is from 0.0 - 1.0
                topCloseness = (sensitivity - (getEvY(ev) - bounds.top)) / sensitivity;
                bottomCloseness = (sensitivity - (bounds.bottom - getEvY(ev))) / sensitivity;
                leftCloseness = (sensitivity - (getEvX(ev) - bounds.left)) / sensitivity;
                rightCloseness = (sensitivity - (bounds.right - getEvX(ev))) / sensitivity;

                // translate vertical closeness into velocity.
                // mouse must be completely in bounds for velocity to happen.
                if (topCloseness >= 0 && topCloseness <= 1) {
                    topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
                }
                else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
                    topVel = bottomCloseness * this.scrollSpeed;
                }

                // translate horizontal closeness into velocity
                if (leftCloseness >= 0 && leftCloseness <= 1) {
                    leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
                }
                else if (rightCloseness >= 0 && rightCloseness <= 1) {
                    leftVel = rightCloseness * this.scrollSpeed;
                }
            }

            this.setScrollVel(topVel, leftVel);
        },


        // Sets the speed-of-scrolling for the scrollEl
        setScrollVel: function(topVel, leftVel) {

            this.scrollTopVel = topVel;
            this.scrollLeftVel = leftVel;

            this.constrainScrollVel(); // massages into realistic values

            // if there is non-zero velocity, and an animation loop hasn't already started, then START
            if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
                this.scrollIntervalId = setInterval(
                    proxy(this, 'scrollIntervalFunc'), // scope to `this`
                    this.scrollIntervalMs
                );
            }
        },


        // Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
        constrainScrollVel: function() {
            var el = this.scrollEl;

            if (this.scrollTopVel < 0) { // scrolling up?
                if (el.scrollTop() <= 0) { // already scrolled all the way up?
                    this.scrollTopVel = 0;
                }
            }
            else if (this.scrollTopVel > 0) { // scrolling down?
                if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?
                    this.scrollTopVel = 0;
                }
            }

            if (this.scrollLeftVel < 0) { // scrolling left?
                if (el.scrollLeft() <= 0) { // already scrolled all the left?
                    this.scrollLeftVel = 0;
                }
            }
            else if (this.scrollLeftVel > 0) { // scrolling right?
                if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?
                    this.scrollLeftVel = 0;
                }
            }
        },


        // This function gets called during every iteration of the scrolling animation loop
        scrollIntervalFunc: function() {
            var el = this.scrollEl;
            var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by

            // change the value of scrollEl's scroll
            if (this.scrollTopVel) {
                el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
            }
            if (this.scrollLeftVel) {
                el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
            }

            this.constrainScrollVel(); // since the scroll values changed, recompute the velocities

            // if scrolled all the way, which causes the vels to be zero, stop the animation loop
            if (!this.scrollTopVel && !this.scrollLeftVel) {
                this.endAutoScroll();
            }
        },


        // Kills any existing scrolling animation loop
        endAutoScroll: function() {
            if (this.scrollIntervalId) {
                clearInterval(this.scrollIntervalId);
                this.scrollIntervalId = null;

                this.handleScrollEnd();
            }
        },


        // Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
        handleDebouncedScroll: function() {
            // recompute all coordinates, but *only* if this is *not* part of our scrolling animation
            if (!this.scrollIntervalId) {
                this.handleScrollEnd();
            }
        },


        // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
        handleScrollEnd: function() {
        }

    });
    ;;

    /* Tracks mouse movements over a component and raises events about which hit the mouse is over.
     ------------------------------------------------------------------------------------------------------------------------
     options:
     - subjectEl
     - subjectCenter
     */

    var HitDragListener = DragListener.extend({

        component: null, // converts coordinates to hits
        // methods: hitsNeeded, hitsNotNeeded, queryHit

        origHit: null, // the hit the mouse was over when listening started
        hit: null, // the hit the mouse is over
        coordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions


        constructor: function(component, options) {
            DragListener.call(this, options); // call the super-constructor

            this.component = component;
        },


        // Called when drag listening starts (but a real drag has not necessarily began).
        // ev might be undefined if dragging was started manually.
        handleInteractionStart: function(ev) {
            var subjectEl = this.subjectEl;
            var subjectRect;
            var origPoint;
            var point;

            this.component.hitsNeeded();
            this.computeScrollBounds(); // for autoscroll

            if (ev) {
                origPoint = { left: getEvX(ev), top: getEvY(ev) };
                point = origPoint;

                // constrain the point to bounds of the element being dragged
                if (subjectEl) {
                    subjectRect = getOuterRect(subjectEl); // used for centering as well
                    point = constrainPoint(point, subjectRect);
                }

                this.origHit = this.queryHit(point.left, point.top);

                // treat the center of the subject as the collision point?
                if (subjectEl && this.options.subjectCenter) {

                    // only consider the area the subject overlaps the hit. best for large subjects.
                    // TODO: skip this if hit didn't supply left/right/top/bottom
                    if (this.origHit) {
                        subjectRect = intersectRects(this.origHit, subjectRect) ||
                            subjectRect; // in case there is no intersection
                    }

                    point = getRectCenter(subjectRect);
                }

                this.coordAdjust = diffPoints(point, origPoint); // point - origPoint
            }
            else {
                this.origHit = null;
                this.coordAdjust = null;
            }

            // call the super-method. do it after origHit has been computed
            DragListener.prototype.handleInteractionStart.apply(this, arguments);
        },


        // Called when the actual drag has started
        handleDragStart: function(ev) {
            var hit;

            DragListener.prototype.handleDragStart.apply(this, arguments); // call the super-method

            // might be different from this.origHit if the min-distance is large
            hit = this.queryHit(getEvX(ev), getEvY(ev));

            // report the initial hit the mouse is over
            // especially important if no min-distance and drag starts immediately
            if (hit) {
                this.handleHitOver(hit);
            }
        },


        // Called when the drag moves
        handleDrag: function(dx, dy, ev) {
            var hit;

            DragListener.prototype.handleDrag.apply(this, arguments); // call the super-method

            hit = this.queryHit(getEvX(ev), getEvY(ev));

            if (!isHitsEqual(hit, this.hit)) { // a different hit than before?
                if (this.hit) {
                    this.handleHitOut();
                }
                if (hit) {
                    this.handleHitOver(hit);
                }
            }
        },


        // Called when dragging has been stopped
        handleDragEnd: function() {
            this.handleHitDone();
            DragListener.prototype.handleDragEnd.apply(this, arguments); // call the super-method
        },


        // Called when a the mouse has just moved over a new hit
        handleHitOver: function(hit) {
            var isOrig = isHitsEqual(hit, this.origHit);

            this.hit = hit;

            this.trigger('hitOver', this.hit, isOrig, this.origHit);
        },


        // Called when the mouse has just moved out of a hit
        handleHitOut: function() {
            if (this.hit) {
                this.trigger('hitOut', this.hit);
                this.handleHitDone();
                this.hit = null;
            }
        },


        // Called after a hitOut. Also called before a dragStop
        handleHitDone: function() {
            if (this.hit) {
                this.trigger('hitDone', this.hit);
            }
        },


        // Called when the interaction ends, whether there was a real drag or not
        handleInteractionEnd: function() {
            DragListener.prototype.handleInteractionEnd.apply(this, arguments); // call the super-method

            this.origHit = null;
            this.hit = null;

            this.component.hitsNotNeeded();
        },


        // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
        handleScrollEnd: function() {
            DragListener.prototype.handleScrollEnd.apply(this, arguments); // call the super-method

            // hits' absolute positions will be in new places after a user's scroll.
            // HACK for recomputing.
            if (this.isDragging) {
                this.component.releaseHits();
                this.component.prepareHits();
            }
        },


        // Gets the hit underneath the coordinates for the given mouse event
        queryHit: function(left, top) {

            if (this.coordAdjust) {
                left += this.coordAdjust.left;
                top += this.coordAdjust.top;
            }

            return this.component.queryHit(left, top);
        }

    });


// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.
// Two null values will be considered equal, as two "out of the component" states are the same.
    function isHitsEqual(hit0, hit1) {

        if (!hit0 && !hit1) {
            return true;
        }

        if (hit0 && hit1) {
            return hit0.component === hit1.component &&
                isHitPropsWithin(hit0, hit1) &&
                isHitPropsWithin(hit1, hit0); // ensures all props are identical
        }

        return false;
    }


// Returns true if all of subHit's non-standard properties are within superHit
    function isHitPropsWithin(subHit, superHit) {
        for (var propName in subHit) {
            if (!/^(component|left|right|top|bottom)$/.test(propName)) {
                if (subHit[propName] !== superHit[propName]) {
                    return false;
                }
            }
        }
        return true;
    }

    ;;

    /*
     Listens to document and window-level user-interaction events, like touch events and mouse events,
     and fires these events as-is to whoever is observing a GlobalEmitter.
     Best when used as a singleton via GlobalEmitter.get()

     Normalizes mouse/touch events. For examples:
     - ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click
     - compensates for various buggy scenarios where a touchend does not fire
     */

    FC.touchMouseIgnoreWait = 500;

    var GlobalEmitter = Class.extend(ListenerMixin, EmitterMixin, {

        isTouching: false,
        mouseIgnoreDepth: 0,
        handleScrollProxy: null,


        bind: function() {
            var _this = this;

            this.listenTo($(document), {
                touchstart: this.handleTouchStart,
                touchcancel: this.handleTouchCancel,
                touchend: this.handleTouchEnd,
                mousedown: this.handleMouseDown,
                mousemove: this.handleMouseMove,
                mouseup: this.handleMouseUp,
                click: this.handleClick,
                selectstart: this.handleSelectStart,
                contextmenu: this.handleContextMenu
            });

            // because we need to call preventDefault
            // because https://www.chromestatus.com/features/5093566007214080
            // TODO: investigate performance because this is a global handler
            window.addEventListener(
                'touchmove',
                this.handleTouchMoveProxy = function(ev) {
                    _this.handleTouchMove($.Event(ev));
                },
                { passive: false } // allows preventDefault()
            );

            // attach a handler to get called when ANY scroll action happens on the page.
            // this was impossible to do with normal on/off because 'scroll' doesn't bubble.
            // http://stackoverflow.com/a/32954565/96342
            window.addEventListener(
                'scroll',
                this.handleScrollProxy = function(ev) {
                    _this.handleScroll($.Event(ev));
                },
                true // useCapture
            );
        },

        unbind: function() {
            this.stopListeningTo($(document));

            window.removeEventListener(
                'touchmove',
                this.handleTouchMoveProxy
            );

            window.removeEventListener(
                'scroll',
                this.handleScrollProxy,
                true // useCapture
            );
        },


        // Touch Handlers
        // -----------------------------------------------------------------------------------------------------------------

        handleTouchStart: function(ev) {

            // if a previous touch interaction never ended with a touchend, then implicitly end it,
            // but since a new touch interaction is about to begin, don't start the mouse ignore period.
            this.stopTouch(ev, true); // skipMouseIgnore=true

            this.isTouching = true;
            this.trigger('touchstart', ev);
        },

        handleTouchMove: function(ev) {
            if (this.isTouching) {
                this.trigger('touchmove', ev);
            }
        },

        handleTouchCancel: function(ev) {
            if (this.isTouching) {
                this.trigger('touchcancel', ev);

                // Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.
                // If touchend fires later, it won't have any effect b/c isTouching will be false.
                this.stopTouch(ev);
            }
        },

        handleTouchEnd: function(ev) {
            this.stopTouch(ev);
        },


        // Mouse Handlers
        // -----------------------------------------------------------------------------------------------------------------

        handleMouseDown: function(ev) {
            if (!this.shouldIgnoreMouse()) {
                this.trigger('mousedown', ev);
            }
        },

        handleMouseMove: function(ev) {
            if (!this.shouldIgnoreMouse()) {
                this.trigger('mousemove', ev);
            }
        },

        handleMouseUp: function(ev) {
            if (!this.shouldIgnoreMouse()) {
                this.trigger('mouseup', ev);
            }
        },

        handleClick: function(ev) {
            if (!this.shouldIgnoreMouse()) {
                this.trigger('click', ev);
            }
        },


        // Misc Handlers
        // -----------------------------------------------------------------------------------------------------------------

        handleSelectStart: function(ev) {
            this.trigger('selectstart', ev);
        },

        handleContextMenu: function(ev) {
            this.trigger('contextmenu', ev);
        },

        handleScroll: function(ev) {
            this.trigger('scroll', ev);
        },


        // Utils
        // -----------------------------------------------------------------------------------------------------------------

        stopTouch: function(ev, skipMouseIgnore) {
            if (this.isTouching) {
                this.isTouching = false;
                this.trigger('touchend', ev);

                if (!skipMouseIgnore) {
                    this.startTouchMouseIgnore();
                }
            }
        },

        startTouchMouseIgnore: function() {
            var _this = this;
            var wait = FC.touchMouseIgnoreWait;

            if (wait) {
                this.mouseIgnoreDepth++;
                setTimeout(function() {
                    _this.mouseIgnoreDepth--;
                }, wait);
            }
        },

        shouldIgnoreMouse: function() {
            return this.isTouching || Boolean(this.mouseIgnoreDepth);
        }

    });


// Singleton
// ---------------------------------------------------------------------------------------------------------------------

    (function() {
        var globalEmitter = null;
        var neededCount = 0;


        // gets the singleton
        GlobalEmitter.get = function() {

            if (!globalEmitter) {
                globalEmitter = new GlobalEmitter();
                globalEmitter.bind();
            }

            return globalEmitter;
        };


        // called when an object knows it will need a GlobalEmitter in the near future.
        GlobalEmitter.needed = function() {
            GlobalEmitter.get(); // ensures globalEmitter
            neededCount++;
        };


        // called when the object that originally called needed() doesn't need a GlobalEmitter anymore.
        GlobalEmitter.unneeded = function() {
            neededCount--;

            if (!neededCount) { // nobody else needs it
                globalEmitter.unbind();
                globalEmitter = null;
            }
        };

    })();

    ;;

    /* Creates a clone of an element and lets it track the mouse as it moves
     ----------------------------------------------------------------------------------------------------------------------*/

    var MouseFollower = Class.extend(ListenerMixin, {

        options: null,

        sourceEl: null, // the element that will be cloned and made to look like it is dragging
        el: null, // the clone of `sourceEl` that will track the mouse
        parentEl: null, // the element that `el` (the clone) will be attached to

        // the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl
        top0: null,
        left0: null,

        // the absolute coordinates of the initiating touch/mouse action
        y0: null,
        x0: null,

        // the number of pixels the mouse has moved from its initial position
        topDelta: null,
        leftDelta: null,

        isFollowing: false,
        isHidden: false,
        isAnimating: false, // doing the revert animation?

        constructor: function(sourceEl, options) {
            this.options = options = options || {};
            this.sourceEl = sourceEl;
            this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
        },


        // Causes the element to start following the mouse
        start: function(ev) {
            if (!this.isFollowing) {
                this.isFollowing = true;

                this.y0 = getEvY(ev);
                this.x0 = getEvX(ev);
                this.topDelta = 0;
                this.leftDelta = 0;

                if (!this.isHidden) {
                    this.updatePosition();
                }

                if (getEvIsTouch(ev)) {
                    this.listenTo($(document), 'touchmove', this.handleMove);
                }
                else {
                    this.listenTo($(document), 'mousemove', this.handleMove);
                }
            }
        },


        // Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
        // `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
        stop: function(shouldRevert, callback) {
            var _this = this;
            var revertDuration = this.options.revertDuration;

            function complete() { // might be called by .animate(), which might change `this` context
                _this.isAnimating = false;
                _this.removeElement();

                _this.top0 = _this.left0 = null; // reset state for future updatePosition calls

                if (callback) {
                    callback();
                }
            }

            if (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time
                this.isFollowing = false;

                this.stopListeningTo($(document));

                if (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?
                    this.isAnimating = true;
                    this.el.animate({
                        top: this.top0,
                        left: this.left0
                    }, {
                        duration: revertDuration,
                        complete: complete
                    });
                }
                else {
                    complete();
                }
            }
        },


        // Gets the tracking element. Create it if necessary
        getEl: function() {
            var el = this.el;

            if (!el) {
                el = this.el = this.sourceEl.clone()
                    .addClass(this.options.additionalClass || '')
                    .css({
                        position: 'absolute',
                        visibility: '', // in case original element was hidden (commonly through hideEvents())
                        display: this.isHidden ? 'none' : '', // for when initially hidden
                        margin: 0,
                        right: 'auto', // erase and set width instead
                        bottom: 'auto', // erase and set height instead
                        width: this.sourceEl.width(), // explicit height in case there was a 'right' value
                        height: this.sourceEl.height(), // explicit width in case there was a 'bottom' value
                        opacity: this.options.opacity || '',
                        zIndex: this.options.zIndex
                    });

                // we don't want long taps or any mouse interaction causing selection/menus.
                // would use preventSelection(), but that prevents selectstart, causing problems.
                el.addClass('fc-unselectable');

                el.appendTo(this.parentEl);
            }

            return el;
        },


        // Removes the tracking element if it has already been created
        removeElement: function() {
            if (this.el) {
                this.el.remove();
                this.el = null;
            }
        },


        // Update the CSS position of the tracking element
        updatePosition: function() {
            var sourceOffset;
            var origin;

            this.getEl(); // ensure this.el

            // make sure origin info was computed
            if (this.top0 === null) {
                sourceOffset = this.sourceEl.offset();
                origin = this.el.offsetParent().offset();
                this.top0 = sourceOffset.top - origin.top;
                this.left0 = sourceOffset.left - origin.left;
            }

            this.el.css({
                top: this.top0 + this.topDelta,
                left: this.left0 + this.leftDelta
            });
        },


        // Gets called when the user moves the mouse
        handleMove: function(ev) {
            this.topDelta = getEvY(ev) - this.y0;
            this.leftDelta = getEvX(ev) - this.x0;

            if (!this.isHidden) {
                this.updatePosition();
            }
        },


        // Temporarily makes the tracking element invisible. Can be called before following starts
        hide: function() {
            if (!this.isHidden) {
                this.isHidden = true;
                if (this.el) {
                    this.el.hide();
                }
            }
        },


        // Show the tracking element after it has been temporarily hidden
        show: function() {
            if (this.isHidden) {
                this.isHidden = false;
                this.updatePosition();
                this.getEl().show();
            }
        }

    });

    ;;

    /* An abstract class comprised of a "grid" of areas that each represent a specific datetime
     ----------------------------------------------------------------------------------------------------------------------*/

    var Grid = FC.Grid = Class.extend(ListenerMixin, {

        // self-config, overridable by subclasses
        hasDayInteractions: true, // can user click/select ranges of time?

        view: null, // a View object
        isRTL: null, // shortcut to the view's isRTL option

        start: null,
        end: null,

        el: null, // the containing element
        elsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.

        // derived from options
        eventTimeFormat: null,
        displayEventTime: null,
        displayEventEnd: null,

        minResizeDuration: null, // TODO: hack. set by subclasses. minumum event resize duration

        // if defined, holds the unit identified (ex: "year" or "month") that determines the level of granularity
        // of the date areas. if not defined, assumes to be day and time granularity.
        // TODO: port isTimeScale into same system?
        largeUnit: null,

        dayClickListener: null,
        daySelectListener: null,
        segDragListener: null,
        segResizeListener: null,
        externalDragListener: null,


        constructor: function(view) {
            this.view = view;
            this.isRTL = view.opt('isRTL');
            this.elsByFill = {};

            this.dayClickListener = this.buildDayClickListener();
            this.daySelectListener = this.buildDaySelectListener();
        },


        /* Options
         ------------------------------------------------------------------------------------------------------------------*/


        // Generates the format string used for event time text, if not explicitly defined by 'timeFormat'
        computeEventTimeFormat: function() {
            return this.view.opt('smallTimeFormat');
        },


        // Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.
        // Only applies to non-all-day events.
        computeDisplayEventTime: function() {
            return true;
        },


        // Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'
        computeDisplayEventEnd: function() {
            return true;
        },


        /* Dates
         ------------------------------------------------------------------------------------------------------------------*/


        // Tells the grid about what period of time to display.
        // Any date-related internal data should be generated.
        setRange: function(range) {
            this.start = range.start.clone();
            this.end = range.end.clone();

            this.rangeUpdated();
            this.processRangeOptions();
        },


        // Called when internal variables that rely on the range should be updated
        rangeUpdated: function() {
        },


        // Updates values that rely on options and also relate to range
        processRangeOptions: function() {
            var view = this.view;
            var displayEventTime;
            var displayEventEnd;

            this.eventTimeFormat =
                view.opt('eventTimeFormat') ||
                view.opt('timeFormat') || // deprecated
                this.computeEventTimeFormat();

            displayEventTime = view.opt('displayEventTime');
            if (displayEventTime == null) {
                displayEventTime = this.computeDisplayEventTime(); // might be based off of range
            }

            displayEventEnd = view.opt('displayEventEnd');
            if (displayEventEnd == null) {
                displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
            }

            this.displayEventTime = displayEventTime;
            this.displayEventEnd = displayEventEnd;
        },


        // Converts a span (has unzoned start/end and any other grid-specific location information)
        // into an array of segments (pieces of events whose format is decided by the grid).
        spanToSegs: function(span) {
            // subclasses must implement
        },


        // Diffs the two dates, returning a duration, based on granularity of the grid
        // TODO: port isTimeScale into this system?
        diffDates: function(a, b) {
            if (this.largeUnit) {
                return diffByUnit(a, b, this.largeUnit);
            }
            else {
                return diffDayTime(a, b);
            }
        },


        /* Hit Area
         ------------------------------------------------------------------------------------------------------------------*/

        hitsNeededDepth: 0, // necessary because multiple callers might need the same hits

        hitsNeeded: function() {
            if (!(this.hitsNeededDepth++)) {
                this.prepareHits();
            }
        },

        hitsNotNeeded: function() {
            if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {
                this.releaseHits();
            }
        },


        // Called before one or more queryHit calls might happen. Should prepare any cached coordinates for queryHit
        prepareHits: function() {
        },


        // Called when queryHit calls have subsided. Good place to clear any coordinate caches.
        releaseHits: function() {
        },


        // Given coordinates from the topleft of the document, return data about the date-related area underneath.
        // Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
        // Must have a `grid` property, a reference to this current grid. TODO: avoid this
        // The returned object will be processed by getHitSpan and getHitEl.
        queryHit: function(leftOffset, topOffset) {
        },


        // like getHitSpan, but returns null if the resulting span's range is invalid
        getSafeHitSpan: function(hit) {
            var hitSpan = this.getHitSpan(hit);

            if (!isRangeWithinRange(hitSpan, this.view.activeRange)) {
                return null;
            }

            return hitSpan;
        },


        // Given position-level information about a date-related area within the grid,
        // should return an object with at least a start/end date. Can provide other information as well.
        getHitSpan: function(hit) {
        },


        // Given position-level information about a date-related area within the grid,
        // should return a jQuery element that best represents it. passed to dayClick callback.
        getHitEl: function(hit) {
        },


        /* Rendering
         ------------------------------------------------------------------------------------------------------------------*/


        // Sets the container element that the grid should render inside of.
        // Does other DOM-related initializations.
        setElement: function(el) {
            this.el = el;

            if (this.hasDayInteractions) {
                preventSelection(el);

                this.bindDayHandler('touchstart', this.dayTouchStart);
                this.bindDayHandler('mousedown', this.dayMousedown);
            }

            // attach event-element-related handlers. in Grid.events
            // same garbage collection note as above.
            this.bindSegHandlers();

            this.bindGlobalHandlers();
        },


        bindDayHandler: function(name, handler) {
            var _this = this;

            // attach a handler to the grid's root element.
            // jQuery will take care of unregistering them when removeElement gets called.
            this.el.on(name, function(ev) {
                if (
                    !$(ev.target).is(
                        _this.segSelector + ',' + // directly on an event element
                        _this.segSelector + ' *,' + // within an event element
                        '.fc-more,' + // a "more.." link
                        'a[data-goto]' // a clickable nav link
                    )
                ) {
                    return handler.call(_this, ev);
                }
            });
        },


        // Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.
        // DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View
        removeElement: function() {
            this.unbindGlobalHandlers();
            this.clearDragListeners();

            this.el.remove();

            // NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement
        },


        // Renders the basic structure of grid view before any content is rendered
        renderSkeleton: function() {
            // subclasses should implement
        },


        // Renders the grid's date-related content (like areas that represent days/times).
        // Assumes setRange has already been called and the skeleton has already been rendered.
        renderDates: function() {
            // subclasses should implement
        },


        // Unrenders the grid's date-related content
        unrenderDates: function() {
            // subclasses should implement
        },


        /* Handlers
         ------------------------------------------------------------------------------------------------------------------*/


        // Binds DOM handlers to elements that reside outside the grid, such as the document
        bindGlobalHandlers: function() {
            this.listenTo($(document), {
                dragstart: this.externalDragStart, // jqui
                sortstart: this.externalDragStart // jqui
            });
        },


        // Unbinds DOM handlers from elements that reside outside the grid
        unbindGlobalHandlers: function() {
            this.stopListeningTo($(document));
        },


        // Process a mousedown on an element that represents a day. For day clicking and selecting.
        dayMousedown: function(ev) {
            var view = this.view;

            // HACK
            // This will still work even though bindDayHandler doesn't use GlobalEmitter.
            if (GlobalEmitter.get().shouldIgnoreMouse()) {
                return;
            }

            this.dayClickListener.startInteraction(ev);

            if (view.opt('selectable')) {
                this.daySelectListener.startInteraction(ev, {
                    distance: view.opt('selectMinDistance')
                });
            }
        },


        dayTouchStart: function(ev) {
            var view = this.view;
            var selectLongPressDelay;

            // On iOS (and Android?) when a new selection is initiated overtop another selection,
            // the touchend never fires because the elements gets removed mid-touch-interaction (my theory).
            // HACK: simply don't allow this to happen.
            // ALSO: prevent selection when an *event* is already raised.
            if (view.isSelected || view.selectedEvent) {
                return;
            }

            selectLongPressDelay = view.opt('selectLongPressDelay');
            if (selectLongPressDelay == null) {
                selectLongPressDelay = view.opt('longPressDelay'); // fallback
            }

            this.dayClickListener.startInteraction(ev);

            if (view.opt('selectable')) {
                this.daySelectListener.startInteraction(ev, {
                    delay: selectLongPressDelay
                });
            }
        },


        // Creates a listener that tracks the user's drag across day elements, for day clicking.
        buildDayClickListener: function() {
            var _this = this;
            var view = this.view;
            var dayClickHit; // null if invalid dayClick

            var dragListener = new HitDragListener(this, {
                scroll: view.opt('dragScroll'),
                interactionStart: function() {
                    dayClickHit = dragListener.origHit;
                },
                hitOver: function(hit, isOrig, origHit) {
                    // if user dragged to another cell at any point, it can no longer be a dayClick
                    if (!isOrig) {
                        dayClickHit = null;
                    }
                },
                hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
                    dayClickHit = null;
                },
                interactionEnd: function(ev, isCancelled) {
                    var hitSpan;

                    if (!isCancelled && dayClickHit) {
                        hitSpan = _this.getSafeHitSpan(dayClickHit);

                        if (hitSpan) {
                            view.triggerDayClick(hitSpan, _this.getHitEl(dayClickHit), ev);
                        }
                    }
                }
            });

            // because dayClickListener won't be called with any time delay, "dragging" will begin immediately,
            // which will kill any touchmoving/scrolling. Prevent this.
            dragListener.shouldCancelTouchScroll = false;

            dragListener.scrollAlwaysKills = true;

            return dragListener;
        },


        // Creates a listener that tracks the user's drag across day elements, for day selecting.
        buildDaySelectListener: function() {
            var _this = this;
            var view = this.view;
            var selectionSpan; // null if invalid selection

            var dragListener = new HitDragListener(this, {
                scroll: view.opt('dragScroll'),
                interactionStart: function() {
                    selectionSpan = null;
                },
                dragStart: function() {
                    view.unselect(); // since we could be rendering a new selection, we want to clear any old one
                },
                hitOver: function(hit, isOrig, origHit) {
                    var origHitSpan;
                    var hitSpan;

                    if (origHit) { // click needs to have started on a hit

                        origHitSpan = _this.getSafeHitSpan(origHit);
                        hitSpan = _this.getSafeHitSpan(hit);

                        if (origHitSpan && hitSpan) {
                            selectionSpan = _this.computeSelection(origHitSpan, hitSpan);
                        }
                        else {
                            selectionSpan = null;
                        }

                        if (selectionSpan) {
                            _this.renderSelection(selectionSpan);
                        }
                        else if (selectionSpan === false) {
                            disableCursor();
                        }
                    }
                },
                hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
                    selectionSpan = null;
                    _this.unrenderSelection();
                },
                hitDone: function() { // called after a hitOut OR before a dragEnd
                    enableCursor();
                },
                interactionEnd: function(ev, isCancelled) {
                    if (!isCancelled && selectionSpan) {
                        // the selection will already have been rendered. just report it
                        view.reportSelection(selectionSpan, ev);
                    }
                }
            });

            return dragListener;
        },


        // Kills all in-progress dragging.
        // Useful for when public API methods that result in re-rendering are invoked during a drag.
        // Also useful for when touch devices misbehave and don't fire their touchend.
        clearDragListeners: function() {
            this.dayClickListener.endInteraction();
            this.daySelectListener.endInteraction();

            if (this.segDragListener) {
                this.segDragListener.endInteraction(); // will clear this.segDragListener
            }
            if (this.segResizeListener) {
                this.segResizeListener.endInteraction(); // will clear this.segResizeListener
            }
            if (this.externalDragListener) {
                this.externalDragListener.endInteraction(); // will clear this.externalDragListener
            }
        },


        /* Event Helper
         ------------------------------------------------------------------------------------------------------------------*/
        // TODO: should probably move this to Grid.events, like we did event dragging / resizing


        // Renders a mock event at the given event location, which contains zoned start/end properties.
        // Returns all mock event elements.
        renderEventLocationHelper: function(eventLocation, sourceSeg) {
            var fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);

            return this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering
        },


        // Builds a fake event given zoned event date properties and a segment is should be inspired from.
        // The range's end can be null, in which case the mock event that is rendered will have a null end time.
        // `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.
        fabricateHelperEvent: function(eventLocation, sourceSeg) {
            var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible

            fakeEvent.start = eventLocation.start.clone();
            fakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;
            fakeEvent.allDay = null; // force it to be freshly computed by normalizeEventDates
            this.view.calendar.normalizeEventDates(fakeEvent);

            // this extra className will be useful for differentiating real events from mock events in CSS
            fakeEvent.className = (fakeEvent.className || []).concat('fc-helper');

            // if something external is being dragged in, don't render a resizer
            if (!sourceSeg) {
                fakeEvent.editable = false;
            }

            return fakeEvent;
        },


        // Renders a mock event. Given zoned event date properties.
        // Must return all mock event elements.
        renderHelper: function(eventLocation, sourceSeg) {
            // subclasses must implement
        },


        // Unrenders a mock event
        unrenderHelper: function() {
            // subclasses must implement
        },


        /* Selection
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.
        // Given a span (unzoned start/end and other misc data)
        renderSelection: function(span) {
            this.renderHighlight(span);
        },


        // Unrenders any visual indications of a selection. Will unrender a highlight by default.
        unrenderSelection: function() {
            this.unrenderHighlight();
        },


        // Given the first and last date-spans of a selection, returns another date-span object.
        // Subclasses can override and provide additional data in the span object. Will be passed to renderSelection().
        // Will return false if the selection is invalid and this should be indicated to the user.
        // Will return null/undefined if a selection invalid but no error should be reported.
        computeSelection: function(span0, span1) {
            var span = this.computeSelectionSpan(span0, span1);

            if (span && !this.view.calendar.isSelectionSpanAllowed(span)) {
                return false;
            }

            return span;
        },


        // Given two spans, must return the combination of the two.
        // TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
        computeSelectionSpan: function(span0, span1) {
            var dates = [ span0.start, span0.end, span1.start, span1.end ];

            dates.sort(compareNumbers); // sorts chronologically. works with Moments

            return { start: dates[0].clone(), end: dates[3].clone() };
        },


        /* Highlight
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
        renderHighlight: function(span) {
            this.renderFill('highlight', this.spanToSegs(span));
        },


        // Unrenders the emphasis on a date range
        unrenderHighlight: function() {
            this.unrenderFill('highlight');
        },


        // Generates an array of classNames for rendering the highlight. Used by the fill system.
        highlightSegClasses: function() {
            return [ 'fc-highlight' ];
        },


        /* Business Hours
         ------------------------------------------------------------------------------------------------------------------*/


        renderBusinessHours: function() {
        },


        unrenderBusinessHours: function() {
        },


        /* Now Indicator
         ------------------------------------------------------------------------------------------------------------------*/


        getNowIndicatorUnit: function() {
        },


        renderNowIndicator: function(date) {
        },


        unrenderNowIndicator: function() {
        },


        /* Fill System (highlight, background events, business hours)
         --------------------------------------------------------------------------------------------------------------------
         TODO: remove this system. like we did in TimeGrid
         */


        // Renders a set of rectangles over the given segments of time.
        // MUST RETURN a subset of segs, the segs that were actually rendered.
        // Responsible for populating this.elsByFill. TODO: better API for expressing this requirement
        renderFill: function(type, segs) {
            // subclasses must implement
        },


        // Unrenders a specific type of fill that is currently rendered on the grid
        unrenderFill: function(type) {
            var el = this.elsByFill[type];

            if (el) {
                el.remove();
                delete this.elsByFill[type];
            }
        },


        // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
        // Only returns segments that successfully rendered.
        // To be harnessed by renderFill (implemented by subclasses).
        // Analagous to renderFgSegEls.
        renderFillSegEls: function(type, segs) {
            var _this = this;
            var segElMethod = this[type + 'SegEl'];
            var html = '';
            var renderedSegs = [];
            var i;

            if (segs.length) {

                // build a large concatenation of segment HTML
                for (i = 0; i < segs.length; i++) {
                    html += this.fillSegHtml(type, segs[i]);
                }

                // Grab individual elements from the combined HTML string. Use each as the default rendering.
                // Then, compute the 'el' for each segment.
                $(html).each(function(i, node) {
                    var seg = segs[i];
                    var el = $(node);

                    // allow custom filter methods per-type
                    if (segElMethod) {
                        el = segElMethod.call(_this, seg, el);
                    }

                    if (el) { // custom filters did not cancel the render
                        el = $(el); // allow custom filter to return raw DOM node

                        // correct element type? (would be bad if a non-TD were inserted into a table for example)
                        if (el.is(_this.fillSegTag)) {
                            seg.el = el;
                            renderedSegs.push(seg);
                        }
                    }
                });
            }

            return renderedSegs;
        },


        fillSegTag: 'div', // subclasses can override


        // Builds the HTML needed for one fill segment. Generic enough to work with different types.
        fillSegHtml: function(type, seg) {

            // custom hooks per-type
            var classesMethod = this[type + 'SegClasses'];
            var cssMethod = this[type + 'SegCss'];

            var classes = classesMethod ? classesMethod.call(this, seg) : [];
            var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});

            return '<' + this.fillSegTag +
                (classes.length ? ' class="' + classes.join(' ') + '"' : '') +
                (css ? ' style="' + css + '"' : '') +
                ' />';
        },



        /* Generic rendering utilities for subclasses
         ------------------------------------------------------------------------------------------------------------------*/


        // Computes HTML classNames for a single-day element
        getDayClasses: function(date, noThemeHighlight) {
            var view = this.view;
            var classes = [];
            var today;

            if (!isDateWithinRange(date, view.activeRange)) {
                classes.push('fc-disabled-day'); // TODO: jQuery UI theme?
            }
            else {
                classes.push('fc-' + dayIDs[date.day()]);

                if (
                    view.currentRangeAs('months') == 1 && // TODO: somehow get into MonthView
                    date.month() != view.currentRange.start.month()
                ) {
                    classes.push('fc-other-month');
                }

                today = view.calendar.getNow();

                if (date.isSame(today, 'day')) {
                    classes.push('fc-today');

                    if (noThemeHighlight !== true) {
                        classes.push(view.highlightStateClass);
                    }
                }
                else if (date < today) {
                    classes.push('fc-past');
                }
                else {
                    classes.push('fc-future');
                }
            }

            return classes;
        }

    });

    ;;

    /* Event-rendering and event-interaction methods for the abstract Grid class
     ----------------------------------------------------------------------------------------------------------------------

     Data Types:
     event - { title, id, start, (end), whatever }
     location - { start, (end), allDay }
     rawEventRange - { start, end }
     eventRange - { start, end, isStart, isEnd }
     eventSpan - { start, end, isStart, isEnd, whatever }
     eventSeg - { event, whatever }
     seg - { whatever }
     */

    Grid.mixin({

        // self-config, overridable by subclasses
        segSelector: '.fc-event-container > *', // what constitutes an event element?

        mousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing
        isDraggingSeg: false, // is a segment being dragged? boolean
        isResizingSeg: false, // is a segment being resized? boolean
        isDraggingExternal: false, // jqui-dragging an external element? boolean
        segs: null, // the *event* segments currently rendered in the grid. TODO: rename to `eventSegs`


        // Renders the given events onto the grid
        renderEvents: function(events) {
            var bgEvents = [];
            var fgEvents = [];
            var i;

            for (i = 0; i < events.length; i++) {
                (isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);
            }

            this.segs = [].concat( // record all segs
                this.renderBgEvents(bgEvents),
                this.renderFgEvents(fgEvents)
            );
        },


        renderBgEvents: function(events) {
            var segs = this.eventsToSegs(events);

            // renderBgSegs might return a subset of segs, segs that were actually rendered
            return this.renderBgSegs(segs) || segs;
        },


        renderFgEvents: function(events) {
            var segs = this.eventsToSegs(events);

            // renderFgSegs might return a subset of segs, segs that were actually rendered
            return this.renderFgSegs(segs) || segs;
        },


        // Unrenders all events currently rendered on the grid
        unrenderEvents: function() {
            this.handleSegMouseout(); // trigger an eventMouseout if user's mouse is over an event
            this.clearDragListeners();

            this.unrenderFgSegs();
            this.unrenderBgSegs();

            this.segs = null;
        },


        // Retrieves all rendered segment objects currently rendered on the grid
        getEventSegs: function() {
            return this.segs || [];
        },


        /* Foreground Segment Rendering
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders foreground event segments onto the grid. May return a subset of segs that were rendered.
        renderFgSegs: function(segs) {
            // subclasses must implement
        },


        // Unrenders all currently rendered foreground segments
        unrenderFgSegs: function() {
            // subclasses must implement
        },


        // Renders and assigns an `el` property for each foreground event segment.
        // Only returns segments that successfully rendered.
        // A utility that subclasses may use.
        renderFgSegEls: function(segs, disableResizing) {
            var view = this.view;
            var html = '';
            var renderedSegs = [];
            var i;

            if (segs.length) { // don't build an empty html string

                // build a large concatenation of event segment HTML
                for (i = 0; i < segs.length; i++) {
                    html += this.fgSegHtml(segs[i], disableResizing);
                }

                // Grab individual elements from the combined HTML string. Use each as the default rendering.
                // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
                $(html).each(function(i, node) {
                    var seg = segs[i];
                    var el = view.resolveEventEl(seg.event, $(node));

                    if (el) {
                        el.data('fc-seg', seg); // used by handlers
                        seg.el = el;
                        renderedSegs.push(seg);
                    }
                });
            }

            return renderedSegs;
        },


        // Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
        fgSegHtml: function(seg, disableResizing) {
            // subclasses should implement
        },


        /* Background Segment Rendering
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders the given background event segments onto the grid.
        // Returns a subset of the segs that were actually rendered.
        renderBgSegs: function(segs) {
            return this.renderFill('bgEvent', segs);
        },


        // Unrenders all the currently rendered background event segments
        unrenderBgSegs: function() {
            this.unrenderFill('bgEvent');
        },


        // Renders a background event element, given the default rendering. Called by the fill system.
        bgEventSegEl: function(seg, el) {
            return this.view.resolveEventEl(seg.event, el); // will filter through eventRender
        },


        // Generates an array of classNames to be used for the default rendering of a background event.
        // Called by fillSegHtml.
        bgEventSegClasses: function(seg) {
            var event = seg.event;
            var source = event.source || {};

            return [ 'fc-bgevent' ].concat(
                event.className,
                source.className || []
            );
        },


        // Generates a semicolon-separated CSS string to be used for the default rendering of a background event.
        // Called by fillSegHtml.
        bgEventSegCss: function(seg) {
            return {
                'background-color': this.getSegSkinCss(seg)['background-color']
            };
        },


        // Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.
        // Called by fillSegHtml.
        businessHoursSegClasses: function(seg) {
            return [ 'fc-nonbusiness', 'fc-bgevent' ];
        },


        /* Business Hours
         ------------------------------------------------------------------------------------------------------------------*/


        // Compute business hour segs for the grid's current date range.
        // Caller must ask if whole-day business hours are needed.
        // If no `businessHours` configuration value is specified, assumes the calendar default.
        buildBusinessHourSegs: function(wholeDay, businessHours) {
            return this.eventsToSegs(
                this.buildBusinessHourEvents(wholeDay, businessHours)
            );
        },


        // Compute business hour *events* for the grid's current date range.
        // Caller must ask if whole-day business hours are needed.
        // If no `businessHours` configuration value is specified, assumes the calendar default.
        buildBusinessHourEvents: function(wholeDay, businessHours) {
            var calendar = this.view.calendar;
            var events;

            if (businessHours == null) {
                // fallback
                // access from calendawr. don't access from view. doesn't update with dynamic options.
                businessHours = calendar.opt('businessHours');
            }

            events = calendar.computeBusinessHourEvents(wholeDay, businessHours);

            // HACK. Eventually refactor business hours "events" system.
            // If no events are given, but businessHours is activated, this means the entire visible range should be
            // marked as *not* business-hours, via inverse-background rendering.
            if (!events.length && businessHours) {
                events = [
                    $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, {
                        start: this.view.activeRange.end, // guaranteed out-of-range
                        end: this.view.activeRange.end,   // "
                        dow: null
                    })
                ];
            }

            return events;
        },


        /* Handlers
         ------------------------------------------------------------------------------------------------------------------*/


        // Attaches event-element-related handlers for *all* rendered event segments of the view.
        bindSegHandlers: function() {
            this.bindSegHandlersToEl(this.el);
        },


        // Attaches event-element-related handlers to an arbitrary container element. leverages bubbling.
        bindSegHandlersToEl: function(el) {
            this.bindSegHandlerToEl(el, 'touchstart', this.handleSegTouchStart);
            this.bindSegHandlerToEl(el, 'mouseenter', this.handleSegMouseover);
            this.bindSegHandlerToEl(el, 'mouseleave', this.handleSegMouseout);
            this.bindSegHandlerToEl(el, 'mousedown', this.handleSegMousedown);
            this.bindSegHandlerToEl(el, 'click', this.handleSegClick);
        },


        // Executes a handler for any a user-interaction on a segment.
        // Handler gets called with (seg, ev), and with the `this` context of the Grid
        bindSegHandlerToEl: function(el, name, handler) {
            var _this = this;

            el.on(name, this.segSelector, function(ev) {
                var seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents

                // only call the handlers if there is not a drag/resize in progress
                if (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {
                    return handler.call(_this, seg, ev); // context will be the Grid
                }
            });
        },


        handleSegClick: function(seg, ev) {
            var res = this.view.publiclyTrigger('eventClick', seg.el[0], seg.event, ev); // can return `false` to cancel
            if (res === false) {
                ev.preventDefault();
            }
        },


        // Updates internal state and triggers handlers for when an event element is moused over
        handleSegMouseover: function(seg, ev) {
            if (
                !GlobalEmitter.get().shouldIgnoreMouse() &&
                !this.mousedOverSeg
            ) {
                this.mousedOverSeg = seg;
                if (this.view.isEventResizable(seg.event)) {
                    seg.el.addClass('fc-allow-mouse-resize');
                }
                this.view.publiclyTrigger('eventMouseover', seg.el[0], seg.event, ev);
            }
        },


        // Updates internal state and triggers handlers for when an event element is moused out.
        // Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
        handleSegMouseout: function(seg, ev) {
            ev = ev || {}; // if given no args, make a mock mouse event

            if (this.mousedOverSeg) {
                seg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment
                this.mousedOverSeg = null;
                if (this.view.isEventResizable(seg.event)) {
                    seg.el.removeClass('fc-allow-mouse-resize');
                }
                this.view.publiclyTrigger('eventMouseout', seg.el[0], seg.event, ev);
            }
        },


        handleSegMousedown: function(seg, ev) {
            var isResizing = this.startSegResize(seg, ev, { distance: 5 });

            if (!isResizing && this.view.isEventDraggable(seg.event)) {
                this.buildSegDragListener(seg)
                    .startInteraction(ev, {
                        distance: 5
                    });
            }
        },


        handleSegTouchStart: function(seg, ev) {
            var view = this.view;
            var event = seg.event;
            var isSelected = view.isEventSelected(event);
            var isDraggable = view.isEventDraggable(event);
            var isResizable = view.isEventResizable(event);
            var isResizing = false;
            var dragListener;
            var eventLongPressDelay;

            if (isSelected && isResizable) {
                // only allow resizing of the event is selected
                isResizing = this.startSegResize(seg, ev);
            }

            if (!isResizing && (isDraggable || isResizable)) { // allowed to be selected?

                eventLongPressDelay = view.opt('eventLongPressDelay');
                if (eventLongPressDelay == null) {
                    eventLongPressDelay = view.opt('longPressDelay'); // fallback
                }

                dragListener = isDraggable ?
                    this.buildSegDragListener(seg) :
                    this.buildSegSelectListener(seg); // seg isn't draggable, but still needs to be selected

                dragListener.startInteraction(ev, { // won't start if already started
                    delay: isSelected ? 0 : eventLongPressDelay // do delay if not already selected
                });
            }
        },


        // returns boolean whether resizing actually started or not.
        // assumes the seg allows resizing.
        // `dragOptions` are optional.
        startSegResize: function(seg, ev, dragOptions) {
            if ($(ev.target).is('.fc-resizer')) {
                this.buildSegResizeListener(seg, $(ev.target).is('.fc-start-resizer'))
                    .startInteraction(ev, dragOptions);
                return true;
            }
            return false;
        },



        /* Event Dragging
         ------------------------------------------------------------------------------------------------------------------*/


        // Builds a listener that will track user-dragging on an event segment.
        // Generic enough to work with any type of Grid.
        // Has side effect of setting/unsetting `segDragListener`
        buildSegDragListener: function(seg) {
            var _this = this;
            var view = this.view;
            var el = seg.el;
            var event = seg.event;
            var isDragging;
            var mouseFollower; // A clone of the original element that will move with the mouse
            var dropLocation; // zoned event date properties

            if (this.segDragListener) {
                return this.segDragListener;
            }

            // Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
            // of the view.
            var dragListener = this.segDragListener = new HitDragListener(view, {
                scroll: view.opt('dragScroll'),
                subjectEl: el,
                subjectCenter: true,
                interactionStart: function(ev) {
                    seg.component = _this; // for renderDrag
                    isDragging = false;
                    mouseFollower = new MouseFollower(seg.el, {
                        additionalClass: 'fc-dragging',
                        parentEl: view.el,
                        opacity: dragListener.isTouch ? null : view.opt('dragOpacity'),
                        revertDuration: view.opt('dragRevertDuration'),
                        zIndex: 2 // one above the .fc-view
                    });
                    mouseFollower.hide(); // don't show until we know this is a real drag
                    mouseFollower.start(ev);
                },
                dragStart: function(ev) {
                    if (dragListener.isTouch && !view.isEventSelected(event)) {
                        // if not previously selected, will fire after a delay. then, select the event
                        view.selectEvent(event);
                    }
                    isDragging = true;
                    _this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
                    _this.segDragStart(seg, ev);
                    view.hideEvent(event); // hide all event segments. our mouseFollower will take over
                },
                hitOver: function(hit, isOrig, origHit) {
                    var isAllowed = true;
                    var origHitSpan;
                    var hitSpan;
                    var dragHelperEls;

                    // starting hit could be forced (DayGrid.limit)
                    if (seg.hit) {
                        origHit = seg.hit;
                    }

                    // hit might not belong to this grid, so query origin grid
                    origHitSpan = origHit.component.getSafeHitSpan(origHit);
                    hitSpan = hit.component.getSafeHitSpan(hit);

                    if (origHitSpan && hitSpan) {
                        dropLocation = _this.computeEventDrop(origHitSpan, hitSpan, event);
                        isAllowed = dropLocation && _this.isEventLocationAllowed(dropLocation, event);
                    }
                    else {
                        isAllowed = false;
                    }

                    if (!isAllowed) {
                        dropLocation = null;
                        disableCursor();
                    }

                    // if a valid drop location, have the subclass render a visual indication
                    if (dropLocation && (dragHelperEls = view.renderDrag(dropLocation, seg))) {

                        dragHelperEls.addClass('fc-dragging');
                        if (!dragListener.isTouch) {
                            _this.applyDragOpacity(dragHelperEls);
                        }

                        mouseFollower.hide(); // if the subclass is already using a mock event "helper", hide our own
                    }
                    else {
                        mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
                    }

                    if (isOrig) {
                        dropLocation = null; // needs to have moved hits to be a valid drop
                    }
                },
                hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
                    view.unrenderDrag(); // unrender whatever was done in renderDrag
                    mouseFollower.show(); // show in case we are moving out of all hits
                    dropLocation = null;
                },
                hitDone: function() { // Called after a hitOut OR before a dragEnd
                    enableCursor();
                },
                interactionEnd: function(ev) {
                    delete seg.component; // prevent side effects

                    // do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
                    mouseFollower.stop(!dropLocation, function() {
                        if (isDragging) {
                            view.unrenderDrag();
                            _this.segDragStop(seg, ev);
                        }

                        if (dropLocation) {
                            // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                            view.reportSegDrop(seg, dropLocation, _this.largeUnit, el, ev);
                        }
                        else {
                            view.showEvent(event);
                        }
                    });
                    _this.segDragListener = null;
                }
            });

            return dragListener;
        },


        // seg isn't draggable, but let's use a generic DragListener
        // simply for the delay, so it can be selected.
        // Has side effect of setting/unsetting `segDragListener`
        buildSegSelectListener: function(seg) {
            var _this = this;
            var view = this.view;
            var event = seg.event;

            if (this.segDragListener) {
                return this.segDragListener;
            }

            var dragListener = this.segDragListener = new DragListener({
                dragStart: function(ev) {
                    if (dragListener.isTouch && !view.isEventSelected(event)) {
                        // if not previously selected, will fire after a delay. then, select the event
                        view.selectEvent(event);
                    }
                },
                interactionEnd: function(ev) {
                    _this.segDragListener = null;
                }
            });

            return dragListener;
        },


        // Called before event segment dragging starts
        segDragStart: function(seg, ev) {
            this.isDraggingSeg = true;
            this.view.publiclyTrigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
        },


        // Called after event segment dragging stops
        segDragStop: function(seg, ev) {
            this.isDraggingSeg = false;
            this.view.publiclyTrigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
        },


        // Given the spans an event drag began, and the span event was dropped, calculates the new zoned start/end/allDay
        // values for the event. Subclasses may override and set additional properties to be used by renderDrag.
        // A falsy returned value indicates an invalid drop.
        // DOES NOT consider overlap/constraint.
        computeEventDrop: function(startSpan, endSpan, event) {
            var calendar = this.view.calendar;
            var dragStart = startSpan.start;
            var dragEnd = endSpan.start;
            var delta;
            var dropLocation; // zoned event date properties

            if (dragStart.hasTime() === dragEnd.hasTime()) {
                delta = this.diffDates(dragEnd, dragStart);

                // if an all-day event was in a timed area and it was dragged to a different time,
                // guarantee an end and adjust start/end to have times
                if (event.allDay && durationHasTime(delta)) {
                    dropLocation = {
                        start: event.start.clone(),
                        end: calendar.getEventEnd(event), // will be an ambig day
                        allDay: false // for normalizeEventTimes
                    };
                    calendar.normalizeEventTimes(dropLocation);
                }
                // othewise, work off existing values
                else {
                    dropLocation = pluckEventDateProps(event);
                }

                dropLocation.start.add(delta);
                if (dropLocation.end) {
                    dropLocation.end.add(delta);
                }
            }
            else {
                // if switching from day <-> timed, start should be reset to the dropped date, and the end cleared
                dropLocation = {
                    start: dragEnd.clone(),
                    end: null, // end should be cleared
                    allDay: !dragEnd.hasTime()
                };
            }

            return dropLocation;
        },


        // Utility for apply dragOpacity to a jQuery set
        applyDragOpacity: function(els) {
            var opacity = this.view.opt('dragOpacity');

            if (opacity != null) {
                els.css('opacity', opacity);
            }
        },


        /* External Element Dragging
         ------------------------------------------------------------------------------------------------------------------*/


        // Called when a jQuery UI drag is initiated anywhere in the DOM
        externalDragStart: function(ev, ui) {
            var view = this.view;
            var el;
            var accept;

            if (view.opt('droppable')) { // only listen if this setting is on
                el = $((ui ? ui.item : null) || ev.target);

                // Test that the dragged element passes the dropAccept selector or filter function.
                // FYI, the default is "*" (matches all)
                accept = view.opt('dropAccept');
                if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
                    if (!this.isDraggingExternal) { // prevent double-listening if fired twice
                        this.listenToExternalDrag(el, ev, ui);
                    }
                }
            }
        },


        // Called when a jQuery UI drag starts and it needs to be monitored for dropping
        listenToExternalDrag: function(el, ev, ui) {
            var _this = this;
            var view = this.view;
            var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
            var dropLocation; // a null value signals an unsuccessful drag

            // listener that tracks mouse movement over date-associated pixel regions
            var dragListener = _this.externalDragListener = new HitDragListener(this, {
                interactionStart: function() {
                    _this.isDraggingExternal = true;
                },
                hitOver: function(hit) {
                    var isAllowed = true;
                    var hitSpan = hit.component.getSafeHitSpan(hit); // hit might not belong to this grid

                    if (hitSpan) {
                        dropLocation = _this.computeExternalDrop(hitSpan, meta);
                        isAllowed = dropLocation && _this.isExternalLocationAllowed(dropLocation, meta.eventProps);
                    }
                    else {
                        isAllowed = false;
                    }

                    if (!isAllowed) {
                        dropLocation = null;
                        disableCursor();
                    }

                    if (dropLocation) {
                        _this.renderDrag(dropLocation); // called without a seg parameter
                    }
                },
                hitOut: function() {
                    dropLocation = null; // signal unsuccessful
                },
                hitDone: function() { // Called after a hitOut OR before a dragEnd
                    enableCursor();
                    _this.unrenderDrag();
                },
                interactionEnd: function(ev) {
                    if (dropLocation) { // element was dropped on a valid hit
                        view.reportExternalDrop(meta, dropLocation, el, ev, ui);
                    }
                    _this.isDraggingExternal = false;
                    _this.externalDragListener = null;
                }
            });

            dragListener.startDrag(ev); // start listening immediately
        },


        // Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
        // returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
        // Returning a null value signals an invalid drop hit.
        // DOES NOT consider overlap/constraint.
        computeExternalDrop: function(span, meta) {
            var calendar = this.view.calendar;
            var dropLocation = {
                start: calendar.applyTimezone(span.start), // simulate a zoned event start date
                end: null
            };

            // if dropped on an all-day span, and element's metadata specified a time, set it
            if (meta.startTime && !dropLocation.start.hasTime()) {
                dropLocation.start.time(meta.startTime);
            }

            if (meta.duration) {
                dropLocation.end = dropLocation.start.clone().add(meta.duration);
            }

            return dropLocation;
        },



        /* Drag Rendering (for both events and an external elements)
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of an event or external element being dragged.
        // `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.
        // `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.
        // A truthy returned value indicates this method has rendered a helper element.
        // Must return elements used for any mock events.
        renderDrag: function(dropLocation, seg) {
            // subclasses must implement
        },


        // Unrenders a visual indication of an event or external element being dragged
        unrenderDrag: function() {
            // subclasses must implement
        },


        /* Resizing
         ------------------------------------------------------------------------------------------------------------------*/


        // Creates a listener that tracks the user as they resize an event segment.
        // Generic enough to work with any type of Grid.
        buildSegResizeListener: function(seg, isStart) {
            var _this = this;
            var view = this.view;
            var calendar = view.calendar;
            var el = seg.el;
            var event = seg.event;
            var eventEnd = calendar.getEventEnd(event);
            var isDragging;
            var resizeLocation; // zoned event date properties. falsy if invalid resize

            // Tracks mouse movement over the *grid's* coordinate map
            var dragListener = this.segResizeListener = new HitDragListener(this, {
                scroll: view.opt('dragScroll'),
                subjectEl: el,
                interactionStart: function() {
                    isDragging = false;
                },
                dragStart: function(ev) {
                    isDragging = true;
                    _this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
                    _this.segResizeStart(seg, ev);
                },
                hitOver: function(hit, isOrig, origHit) {
                    var isAllowed = true;
                    var origHitSpan = _this.getSafeHitSpan(origHit);
                    var hitSpan = _this.getSafeHitSpan(hit);

                    if (origHitSpan && hitSpan) {
                        resizeLocation = isStart ?
                            _this.computeEventStartResize(origHitSpan, hitSpan, event) :
                            _this.computeEventEndResize(origHitSpan, hitSpan, event);

                        isAllowed = resizeLocation && _this.isEventLocationAllowed(resizeLocation, event);
                    }
                    else {
                        isAllowed = false;
                    }

                    if (!isAllowed) {
                        resizeLocation = null;
                        disableCursor();
                    }
                    else {
                        if (
                            resizeLocation.start.isSame(event.start.clone().stripZone()) &&
                            resizeLocation.end.isSame(eventEnd.clone().stripZone())
                        ) {
                            // no change. (FYI, event dates might have zones)
                            resizeLocation = null;
                        }
                    }

                    if (resizeLocation) {
                        view.hideEvent(event);
                        _this.renderEventResize(resizeLocation, seg);
                    }
                },
                hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
                    resizeLocation = null;
                    view.showEvent(event); // for when out-of-bounds. show original
                },
                hitDone: function() { // resets the rendering to show the original event
                    _this.unrenderEventResize();
                    enableCursor();
                },
                interactionEnd: function(ev) {
                    if (isDragging) {
                        _this.segResizeStop(seg, ev);
                    }

                    if (resizeLocation) { // valid date to resize to?
                        // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                        view.reportSegResize(seg, resizeLocation, _this.largeUnit, el, ev);
                    }
                    else {
                        view.showEvent(event);
                    }
                    _this.segResizeListener = null;
                }
            });

            return dragListener;
        },


        // Called before event segment resizing starts
        segResizeStart: function(seg, ev) {
            this.isResizingSeg = true;
            this.view.publiclyTrigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
        },


        // Called after event segment resizing stops
        segResizeStop: function(seg, ev) {
            this.isResizingSeg = false;
            this.view.publiclyTrigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
        },


        // Returns new date-information for an event segment being resized from its start
        computeEventStartResize: function(startSpan, endSpan, event) {
            return this.computeEventResize('start', startSpan, endSpan, event);
        },


        // Returns new date-information for an event segment being resized from its end
        computeEventEndResize: function(startSpan, endSpan, event) {
            return this.computeEventResize('end', startSpan, endSpan, event);
        },


        // Returns new zoned date information for an event segment being resized from its start OR end
        // `type` is either 'start' or 'end'.
        // DOES NOT consider overlap/constraint.
        computeEventResize: function(type, startSpan, endSpan, event) {
            var calendar = this.view.calendar;
            var delta = this.diffDates(endSpan[type], startSpan[type]);
            var resizeLocation; // zoned event date properties
            var defaultDuration;

            // build original values to work from, guaranteeing a start and end
            resizeLocation = {
                start: event.start.clone(),
                end: calendar.getEventEnd(event),
                allDay: event.allDay
            };

            // if an all-day event was in a timed area and was resized to a time, adjust start/end to have times
            if (resizeLocation.allDay && durationHasTime(delta)) {
                resizeLocation.allDay = false;
                calendar.normalizeEventTimes(resizeLocation);
            }

            resizeLocation[type].add(delta); // apply delta to start or end

            // if the event was compressed too small, find a new reasonable duration for it
            if (!resizeLocation.start.isBefore(resizeLocation.end)) {

                defaultDuration =
                    this.minResizeDuration || // TODO: hack
                    (event.allDay ?
                        calendar.defaultAllDayEventDuration :
                        calendar.defaultTimedEventDuration);

                if (type == 'start') { // resizing the start?
                    resizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);
                }
                else { // resizing the end?
                    resizeLocation.end = resizeLocation.start.clone().add(defaultDuration);
                }
            }

            return resizeLocation;
        },


        // Renders a visual indication of an event being resized.
        // `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.
        // Must return elements used for any mock events.
        renderEventResize: function(range, seg) {
            // subclasses must implement
        },


        // Unrenders a visual indication of an event being resized.
        unrenderEventResize: function() {
            // subclasses must implement
        },


        /* Rendering Utils
         ------------------------------------------------------------------------------------------------------------------*/


        // Compute the text that should be displayed on an event's element.
        // `range` can be the Event object itself, or something range-like, with at least a `start`.
        // If event times are disabled, or the event has no time, will return a blank string.
        // If not specified, formatStr will default to the eventTimeFormat setting,
        // and displayEnd will default to the displayEventEnd setting.
        getEventTimeText: function(range, formatStr, displayEnd) {

            if (formatStr == null) {
                formatStr = this.eventTimeFormat;
            }

            if (displayEnd == null) {
                displayEnd = this.displayEventEnd;
            }

            if (this.displayEventTime && range.start.hasTime()) {
                if (displayEnd && range.end) {
                    return this.view.formatRange(range, formatStr);
                }
                else {
                    return range.start.format(formatStr);
                }
            }

            return '';
        },


        // Generic utility for generating the HTML classNames for an event segment's element
        getSegClasses: function(seg, isDraggable, isResizable) {
            var view = this.view;
            var classes = [
                'fc-event',
                seg.isStart ? 'fc-start' : 'fc-not-start',
                seg.isEnd ? 'fc-end' : 'fc-not-end'
            ].concat(this.getSegCustomClasses(seg));

            if (isDraggable) {
                classes.push('fc-draggable');
            }
            if (isResizable) {
                classes.push('fc-resizable');
            }

            // event is currently selected? attach a className.
            if (view.isEventSelected(seg.event)) {
                classes.push('fc-selected');
            }

            return classes;
        },


        // List of classes that were defined by the caller of the API in some way
        getSegCustomClasses: function(seg) {
            var event = seg.event;

            return [].concat(
                event.className, // guaranteed to be an array
                event.source ? event.source.className : []
            );
        },


        // Utility for generating event skin-related CSS properties
        getSegSkinCss: function(seg) {
            return {
                'background-color': this.getSegBackgroundColor(seg),
                'border-color': this.getSegBorderColor(seg),
                color: this.getSegTextColor(seg)
            };
        },


        // Queries for caller-specified color, then falls back to default
        getSegBackgroundColor: function(seg) {
            return seg.event.backgroundColor ||
                seg.event.color ||
                this.getSegDefaultBackgroundColor(seg);
        },


        getSegDefaultBackgroundColor: function(seg) {
            var source = seg.event.source || {};

            return source.backgroundColor ||
                source.color ||
                this.view.opt('eventBackgroundColor') ||
                this.view.opt('eventColor');
        },


        // Queries for caller-specified color, then falls back to default
        getSegBorderColor: function(seg) {
            return seg.event.borderColor ||
                seg.event.color ||
                this.getSegDefaultBorderColor(seg);
        },


        getSegDefaultBorderColor: function(seg) {
            var source = seg.event.source || {};

            return source.borderColor ||
                source.color ||
                this.view.opt('eventBorderColor') ||
                this.view.opt('eventColor');
        },


        // Queries for caller-specified color, then falls back to default
        getSegTextColor: function(seg) {
            return seg.event.textColor ||
                this.getSegDefaultTextColor(seg);
        },


        getSegDefaultTextColor: function(seg) {
            var source = seg.event.source || {};

            return source.textColor ||
                this.view.opt('eventTextColor');
        },


        /* Event Location Validation
         ------------------------------------------------------------------------------------------------------------------*/


        isEventLocationAllowed: function(eventLocation, event) {
            if (this.isEventLocationInRange(eventLocation)) {
                var calendar = this.view.calendar;
                var eventSpans = this.eventToSpans(eventLocation);
                var i;

                if (eventSpans.length) {
                    for (i = 0; i < eventSpans.length; i++) {
                        if (!calendar.isEventSpanAllowed(eventSpans[i], event)) {
                            return false;
                        }
                    }

                    return true;
                }
            }

            return false;
        },


        isExternalLocationAllowed: function(eventLocation, metaProps) { // FOR the external element
            if (this.isEventLocationInRange(eventLocation)) {
                var calendar = this.view.calendar;
                var eventSpans = this.eventToSpans(eventLocation);
                var i;

                if (eventSpans.length) {
                    for (i = 0; i < eventSpans.length; i++) {
                        if (!calendar.isExternalSpanAllowed(eventSpans[i], eventLocation, metaProps)) {
                            return false;
                        }
                    }

                    return true;
                }
            }

            return false;
        },


        isEventLocationInRange: function(eventLocation) {
            return isRangeWithinRange(
                this.eventToRawRange(eventLocation),
                this.view.validRange
            );
        },


        /* Converting events -> eventRange -> eventSpan -> eventSegs
         ------------------------------------------------------------------------------------------------------------------*/


        // Generates an array of segments for the given single event
        // Can accept an event "location" as well (which only has start/end and no allDay)
        eventToSegs: function(event) {
            return this.eventsToSegs([ event ]);
        },


        // Generates spans (always unzoned) for the given event.
        // Does not do any inverting for inverse-background events.
        // Can accept an event "location" as well (which only has start/end and no allDay)
        eventToSpans: function(event) {
            var eventRange = this.eventToRange(event); // { start, end, isStart, isEnd }

            if (eventRange) {
                return this.eventRangeToSpans(eventRange, event);
            }
            else { // out of view's valid range
                return [];
            }
        },



        // Converts an array of event objects into an array of event segment objects.
        // A custom `segSliceFunc` may be given for arbitrarily slicing up events.
        // Doesn't guarantee an order for the resulting array.
        eventsToSegs: function(allEvents, segSliceFunc) {
            var _this = this;
            var eventsById = groupEventsById(allEvents);
            var segs = [];

            $.each(eventsById, function(id, events) {
                var visibleEvents = [];
                var eventRanges = [];
                var eventRange; // { start, end, isStart, isEnd }
                var i;

                for (i = 0; i < events.length; i++) {
                    eventRange = _this.eventToRange(events[i]); // might be null if completely out of range

                    if (eventRange) {
                        eventRanges.push(eventRange);
                        visibleEvents.push(events[i]);
                    }
                }

                // inverse-background events (utilize only the first event in calculations)
                if (isInverseBgEvent(events[0])) {
                    eventRanges = _this.invertRanges(eventRanges); // will lose isStart/isEnd

                    for (i = 0; i < eventRanges.length; i++) {
                        segs.push.apply(segs, // append to
                            _this.eventRangeToSegs(eventRanges[i], events[0], segSliceFunc)
                        );
                    }
                }
                // normal event ranges
                else {
                    for (i = 0; i < eventRanges.length; i++) {
                        segs.push.apply(segs, // append to
                            _this.eventRangeToSegs(eventRanges[i], visibleEvents[i], segSliceFunc)
                        );
                    }
                }
            });

            return segs;
        },


        // Generates the unzoned start/end dates an event appears to occupy
        // Can accept an event "location" as well (which only has start/end and no allDay)
        // returns { start, end, isStart, isEnd }
        // If the event is completely outside of the grid's valid range, will return undefined.
        eventToRange: function(event) {
            return this.refineRawEventRange(
                this.eventToRawRange(event)
            );
        },


        // Ensures the given range is within the view's activeRange and is correctly localized.
        // Always returns a result
        refineRawEventRange: function(rawRange) {
            var view = this.view;
            var calendar = view.calendar;
            var range = intersectRanges(rawRange, view.activeRange);

            if (range) { // otherwise, event doesn't have valid range

                // hack: dynamic locale change forgets to upate stored event localed
                calendar.localizeMoment(range.start);
                calendar.localizeMoment(range.end);

                return range;
            }
        },


        // not constrained to valid dates
        // not given localizeMoment hack
        eventToRawRange: function(event) {
            var calendar = this.view.calendar;
            var start = event.start.clone().stripZone();
            var end = (
                event.end ?
                    event.end.clone() :
                    // derive the end from the start and allDay. compute allDay if necessary
                    calendar.getDefaultEventEnd(
                        event.allDay != null ?
                            event.allDay :
                            !event.start.hasTime(),
                        event.start
                    )
            ).stripZone();

            return { start: start, end: end };
        },


        // Given an event's range (unzoned start/end), and the event itself,
        // slice into segments (using the segSliceFunc function if specified)
        // eventRange - { start, end, isStart, isEnd }
        eventRangeToSegs: function(eventRange, event, segSliceFunc) {
            var eventSpans = this.eventRangeToSpans(eventRange, event);
            var segs = [];
            var i;

            for (i = 0; i < eventSpans.length; i++) {
                segs.push.apply(segs, // append to
                    this.eventSpanToSegs(eventSpans[i], event, segSliceFunc)
                );
            }

            return segs;
        },


        // Given an event's unzoned date range, return an array of eventSpan objects.
        // eventSpan - { start, end, isStart, isEnd, otherthings... }
        // Subclasses can override.
        // Subclasses are obligated to forward eventRange.isStart/isEnd to the resulting spans.
        eventRangeToSpans: function(eventRange, event) {
            return [ $.extend({}, eventRange) ]; // copy into a single-item array
        },


        // Given an event's span (unzoned start/end and other misc data), and the event itself,
        // slices into segments and attaches event-derived properties to them.
        // eventSpan - { start, end, isStart, isEnd, otherthings... }
        eventSpanToSegs: function(eventSpan, event, segSliceFunc) {
            var segs = segSliceFunc ? segSliceFunc(eventSpan) : this.spanToSegs(eventSpan);
            var i, seg;

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];

                // the eventSpan's isStart/isEnd takes precedence over the seg's
                if (!eventSpan.isStart) {
                    seg.isStart = false;
                }
                if (!eventSpan.isEnd) {
                    seg.isEnd = false;
                }

                seg.event = event;
                seg.eventStartMS = +eventSpan.start; // TODO: not the best name after making spans unzoned
                seg.eventDurationMS = eventSpan.end - eventSpan.start;
            }

            return segs;
        },


        // Produces a new array of range objects that will cover all the time NOT covered by the given ranges.
        // SIDE EFFECT: will mutate the given array and will use its date references.
        invertRanges: function(ranges) {
            var view = this.view;
            var viewStart = view.activeRange.start.clone(); // need a copy
            var viewEnd = view.activeRange.end.clone(); // need a copy
            var inverseRanges = [];
            var start = viewStart; // the end of the previous range. the start of the new range
            var i, range;

            // ranges need to be in order. required for our date-walking algorithm
            ranges.sort(compareRanges);

            for (i = 0; i < ranges.length; i++) {
                range = ranges[i];

                // add the span of time before the event (if there is any)
                if (range.start > start) { // compare millisecond time (skip any ambig logic)
                    inverseRanges.push({
                        start: start,
                        end: range.start
                    });
                }

                if (range.end > start) {
                    start = range.end;
                }
            }

            // add the span of time after the last event (if there is any)
            if (start < viewEnd) { // compare millisecond time (skip any ambig logic)
                inverseRanges.push({
                    start: start,
                    end: viewEnd
                });
            }

            return inverseRanges;
        },


        sortEventSegs: function(segs) {
            segs.sort(proxy(this, 'compareEventSegs'));
        },


        // A cmp function for determining which segments should take visual priority
        compareEventSegs: function(seg1, seg2) {
            return seg1.eventStartMS - seg2.eventStartMS || // earlier events go first
                seg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first
                seg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)
                compareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);
        }

    });


    /* Utilities
     ----------------------------------------------------------------------------------------------------------------------*/


    function pluckEventDateProps(event) {
        return {
            start: event.start.clone(),
            end: event.end ? event.end.clone() : null,
            allDay: event.allDay // keep it the same
        };
    }
    FC.pluckEventDateProps = pluckEventDateProps;


    function isBgEvent(event) { // returns true if background OR inverse-background
        var rendering = getEventRendering(event);
        return rendering === 'background' || rendering === 'inverse-background';
    }
    FC.isBgEvent = isBgEvent; // export


    function isInverseBgEvent(event) {
        return getEventRendering(event) === 'inverse-background';
    }


    function getEventRendering(event) {
        return firstDefined((event.source || {}).rendering, event.rendering);
    }


    function groupEventsById(events) {
        var eventsById = {};
        var i, event;

        for (i = 0; i < events.length; i++) {
            event = events[i];
            (eventsById[event._id] || (eventsById[event._id] = [])).push(event);
        }

        return eventsById;
    }


// A cmp function for determining which non-inverted "ranges" (see above) happen earlier
    function compareRanges(range1, range2) {
        return range1.start - range2.start; // earlier ranges go first
    }


    /* External-Dragging-Element Data
     ----------------------------------------------------------------------------------------------------------------------*/

// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
    FC.dataAttrPrefix = '';

// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
    function getDraggedElMeta(el) {
        var prefix = FC.dataAttrPrefix;
        var eventProps; // properties for creating the event, not related to date/time
        var startTime; // a Duration
        var duration;
        var stick;

        if (prefix) { prefix += '-'; }
        eventProps = el.data(prefix + 'event') || null;

        if (eventProps) {
            if (typeof eventProps === 'object') {
                eventProps = $.extend({}, eventProps); // make a copy
            }
            else { // something like 1 or true. still signal event creation
                eventProps = {};
            }

            // pluck special-cased date/time properties
            startTime = eventProps.start;
            if (startTime == null) { startTime = eventProps.time; } // accept 'time' as well
            duration = eventProps.duration;
            stick = eventProps.stick;
            delete eventProps.start;
            delete eventProps.time;
            delete eventProps.duration;
            delete eventProps.stick;
        }

        // fallback to standalone attribute values for each of the date/time properties
        if (startTime == null) { startTime = el.data(prefix + 'start'); }
        if (startTime == null) { startTime = el.data(prefix + 'time'); } // accept 'time' as well
        if (duration == null) { duration = el.data(prefix + 'duration'); }
        if (stick == null) { stick = el.data(prefix + 'stick'); }

        // massage into correct data types
        startTime = startTime != null ? moment.duration(startTime) : null;
        duration = duration != null ? moment.duration(duration) : null;
        stick = Boolean(stick);

        return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };
    }


    ;;

    /*
     A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.
     Prerequisite: the object being mixed into needs to be a *Grid*
     */
    var DayTableMixin = FC.DayTableMixin = {

        breakOnWeeks: false, // should create a new row for each week?
        dayDates: null, // whole-day dates for each column. left to right
        dayIndices: null, // for each day from start, the offset
        daysPerRow: null,
        rowCnt: null,
        colCnt: null,
        colHeadFormat: null,


        // Populates internal variables used for date calculation and rendering
        updateDayTable: function() {
            var view = this.view;
            var date = this.start.clone();
            var dayIndex = -1;
            var dayIndices = [];
            var dayDates = [];
            var daysPerRow;
            var firstDay;
            var rowCnt;

            while (date.isBefore(this.end)) { // loop each day from start to end
                if (view.isHiddenDay(date)) {
                    dayIndices.push(dayIndex + 0.5); // mark that it's between indices
                }
                else {
                    dayIndex++;
                    dayIndices.push(dayIndex);
                    dayDates.push(date.clone());
                }
                date.add(1, 'days');
            }

            if (this.breakOnWeeks) {
                // count columns until the day-of-week repeats
                firstDay = dayDates[0].day();
                for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
                    if (dayDates[daysPerRow].day() == firstDay) {
                        break;
                    }
                }
                rowCnt = Math.ceil(dayDates.length / daysPerRow);
            }
            else {
                rowCnt = 1;
                daysPerRow = dayDates.length;
            }

            this.dayDates = dayDates;
            this.dayIndices = dayIndices;
            this.daysPerRow = daysPerRow;
            this.rowCnt = rowCnt;

            this.updateDayTableCols();
        },


        // Computes and assigned the colCnt property and updates any options that may be computed from it
        updateDayTableCols: function() {
            this.colCnt = this.computeColCnt();
            this.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();
        },


        // Determines how many columns there should be in the table
        computeColCnt: function() {
            return this.daysPerRow;
        },


        // Computes the ambiguously-timed moment for the given cell
        getCellDate: function(row, col) {
            return this.dayDates[
                this.getCellDayIndex(row, col)
                ].clone();
        },


        // Computes the ambiguously-timed date range for the given cell
        getCellRange: function(row, col) {
            var start = this.getCellDate(row, col);
            var end = start.clone().add(1, 'days');

            return { start: start, end: end };
        },


        // Returns the number of day cells, chronologically, from the first of the grid (0-based)
        getCellDayIndex: function(row, col) {
            return row * this.daysPerRow + this.getColDayIndex(col);
        },


        // Returns the numner of day cells, chronologically, from the first cell in *any given row*
        getColDayIndex: function(col) {
            if (this.isRTL) {
                return this.colCnt - 1 - col;
            }
            else {
                return col;
            }
        },


        // Given a date, returns its chronolocial cell-index from the first cell of the grid.
        // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
        // If before the first offset, returns a negative number.
        // If after the last offset, returns an offset past the last cell offset.
        // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
        getDateDayIndex: function(date) {
            var dayIndices = this.dayIndices;
            var dayOffset = date.diff(this.start, 'days');

            if (dayOffset < 0) {
                return dayIndices[0] - 1;
            }
            else if (dayOffset >= dayIndices.length) {
                return dayIndices[dayIndices.length - 1] + 1;
            }
            else {
                return dayIndices[dayOffset];
            }
        },


        /* Options
         ------------------------------------------------------------------------------------------------------------------*/


        // Computes a default column header formatting string if `colFormat` is not explicitly defined
        computeColHeadFormat: function() {
            // if more than one week row, or if there are a lot of columns with not much space,
            // put just the day numbers will be in each cell
            if (this.rowCnt > 1 || this.colCnt > 10) {
                return 'ddd'; // "Sat"
            }
            // multiple days, so full single date string WON'T be in title text
            else if (this.colCnt > 1) {
                return this.view.opt('dayOfMonthFormat'); // "Sat 12/10"
            }
            // single day, so full single date string will probably be in title text
            else {
                return 'dddd'; // "Saturday"
            }
        },


        /* Slicing
         ------------------------------------------------------------------------------------------------------------------*/


        // Slices up a date range into a segment for every week-row it intersects with
        sliceRangeByRow: function(range) {
            var daysPerRow = this.daysPerRow;
            var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
            var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
            var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
            var segs = [];
            var row;
            var rowFirst, rowLast; // inclusive day-index range for current row
            var segFirst, segLast; // inclusive day-index range for segment

            for (row = 0; row < this.rowCnt; row++) {
                rowFirst = row * daysPerRow;
                rowLast = rowFirst + daysPerRow - 1;

                // intersect segment's offset range with the row's
                segFirst = Math.max(rangeFirst, rowFirst);
                segLast = Math.min(rangeLast, rowLast);

                // deal with in-between indices
                segFirst = Math.ceil(segFirst); // in-between starts round to next cell
                segLast = Math.floor(segLast); // in-between ends round to prev cell

                if (segFirst <= segLast) { // was there any intersection with the current row?
                    segs.push({
                        row: row,

                        // normalize to start of row
                        firstRowDayIndex: segFirst - rowFirst,
                        lastRowDayIndex: segLast - rowFirst,

                        // must be matching integers to be the segment's start/end
                        isStart: segFirst === rangeFirst,
                        isEnd: segLast === rangeLast
                    });
                }
            }

            return segs;
        },


        // Slices up a date range into a segment for every day-cell it intersects with.
        // TODO: make more DRY with sliceRangeByRow somehow.
        sliceRangeByDay: function(range) {
            var daysPerRow = this.daysPerRow;
            var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
            var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
            var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
            var segs = [];
            var row;
            var rowFirst, rowLast; // inclusive day-index range for current row
            var i;
            var segFirst, segLast; // inclusive day-index range for segment

            for (row = 0; row < this.rowCnt; row++) {
                rowFirst = row * daysPerRow;
                rowLast = rowFirst + daysPerRow - 1;

                for (i = rowFirst; i <= rowLast; i++) {

                    // intersect segment's offset range with the row's
                    segFirst = Math.max(rangeFirst, i);
                    segLast = Math.min(rangeLast, i);

                    // deal with in-between indices
                    segFirst = Math.ceil(segFirst); // in-between starts round to next cell
                    segLast = Math.floor(segLast); // in-between ends round to prev cell

                    if (segFirst <= segLast) { // was there any intersection with the current row?
                        segs.push({
                            row: row,

                            // normalize to start of row
                            firstRowDayIndex: segFirst - rowFirst,
                            lastRowDayIndex: segLast - rowFirst,

                            // must be matching integers to be the segment's start/end
                            isStart: segFirst === rangeFirst,
                            isEnd: segLast === rangeLast
                        });
                    }
                }
            }

            return segs;
        },


        /* Header Rendering
         ------------------------------------------------------------------------------------------------------------------*/


        renderHeadHtml: function() {
            var view = this.view;

            return '' +
                '<div class="fc-row ' + view.widgetHeaderClass + '">' +
                '<table>' +
                '<thead>' +
                this.renderHeadTrHtml() +
                '</thead>' +
                '</table>' +
                '</div>';
        },


        renderHeadIntroHtml: function() {
            return this.renderIntroHtml(); // fall back to generic
        },


        renderHeadTrHtml: function() {
            return '' +
                '<tr>' +
                (this.isRTL ? '' : this.renderHeadIntroHtml()) +
                this.renderHeadDateCellsHtml() +
                (this.isRTL ? this.renderHeadIntroHtml() : '') +
                '</tr>';
        },


        renderHeadDateCellsHtml: function() {
            var htmls = [];
            var col, date;

            for (col = 0; col < this.colCnt; col++) {
                date = this.getCellDate(0, col);
                htmls.push(this.renderHeadDateCellHtml(date));
            }

            return htmls.join('');
        },


        // TODO: when internalApiVersion, accept an object for HTML attributes
        // (colspan should be no different)
        renderHeadDateCellHtml: function(date, colspan, otherAttrs) {
            var view = this.view;
            var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
            var classNames = [
                'fc-day-header',
                view.widgetHeaderClass
            ];
            var innerHtml = htmlEscape(date.format(this.colHeadFormat));

            // if only one row of days, the classNames on the header can represent the specific days beneath
            if (this.rowCnt === 1) {
                classNames = classNames.concat(
                    // includes the day-of-week class
                    // noThemeHighlight=true (don't highlight the header)
                    this.getDayClasses(date, true)
                );
            }
            else {
                classNames.push('fc-' + dayIDs[date.day()]); // only add the day-of-week class
            }

            return '' +
                '<th class="' + classNames.join(' ') + '"' +
                ((isDateValid && this.rowCnt) === 1 ?
                    ' data-date="' + date.format('YYYY-MM-DD') + '"' :
                    '') +
                (colspan > 1 ?
                    ' colspan="' + colspan + '"' :
                    '') +
                (otherAttrs ?
                    ' ' + otherAttrs :
                    '') +
                '>' +
                (isDateValid ?
                        // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
                        view.buildGotoAnchorHtml(
                            { date: date, forceOff: this.rowCnt > 1 || this.colCnt === 1 },
                            innerHtml
                        ) :
                        // if not valid, display text, but no link
                        innerHtml
                ) +
                '</th>';
        },


        /* Background Rendering
         ------------------------------------------------------------------------------------------------------------------*/


        renderBgTrHtml: function(row) {
            return '' +
                '<tr>' +
                (this.isRTL ? '' : this.renderBgIntroHtml(row)) +
                this.renderBgCellsHtml(row) +
                (this.isRTL ? this.renderBgIntroHtml(row) : '') +
                '</tr>';
        },


        renderBgIntroHtml: function(row) {
            return this.renderIntroHtml(); // fall back to generic
        },


        renderBgCellsHtml: function(row) {
            var htmls = [];
            var col, date;

            for (col = 0; col < this.colCnt; col++) {
                date = this.getCellDate(row, col);
                htmls.push(this.renderBgCellHtml(date));
            }

            return htmls.join('');
        },


        renderBgCellHtml: function(date, otherAttrs) {
            var view = this.view;
            var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
            var classes = this.getDayClasses(date);

            classes.unshift('fc-day', view.widgetContentClass);

            return '<td class="' + classes.join(' ') + '"' +
                (isDateValid ?
                    ' data-date="' + date.format('YYYY-MM-DD') + '"' : // if date has a time, won't format it
                    '') +
                (otherAttrs ?
                    ' ' + otherAttrs :
                    '') +
                '></td>';
        },


        /* Generic
         ------------------------------------------------------------------------------------------------------------------*/


        // Generates the default HTML intro for any row. User classes should override
        renderIntroHtml: function() {
        },


        // TODO: a generic method for dealing with <tr>, RTL, intro
        // when increment internalApiVersion
        // wrapTr (scheduler)


        /* Utils
         ------------------------------------------------------------------------------------------------------------------*/


        // Applies the generic "intro" and "outro" HTML to the given cells.
        // Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
        bookendCells: function(trEl) {
            var introHtml = this.renderIntroHtml();

            if (introHtml) {
                if (this.isRTL) {
                    trEl.append(introHtml);
                }
                else {
                    trEl.prepend(introHtml);
                }
            }
        }

    };

    ;;

    /* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
     ----------------------------------------------------------------------------------------------------------------------*/

    var DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {

        numbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal
        bottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid

        rowEls: null, // set of fake row elements
        cellEls: null, // set of whole-day elements comprising the row's background
        helperEls: null, // set of cell skeleton elements for rendering the mock event "helper"

        rowCoordCache: null,
        colCoordCache: null,


        // Renders the rows and columns into the component's `this.el`, which should already be assigned.
        // isRigid determins whether the individual rows should ignore the contents and be a constant height.
        // Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
        renderDates: function(isRigid) {
            var view = this.view;
            var rowCnt = this.rowCnt;
            var colCnt = this.colCnt;
            var html = '';
            var row;
            var col;

            for (row = 0; row < rowCnt; row++) {
                html += this.renderDayRowHtml(row, isRigid);
            }
            this.el.html(html);

            this.rowEls = this.el.find('.fc-row');
            this.cellEls = this.el.find('.fc-day, .fc-disabled-day');

            this.rowCoordCache = new CoordCache({
                els: this.rowEls,
                isVertical: true
            });
            this.colCoordCache = new CoordCache({
                els: this.cellEls.slice(0, this.colCnt), // only the first row
                isHorizontal: true
            });

            // trigger dayRender with each cell's element
            for (row = 0; row < rowCnt; row++) {
                for (col = 0; col < colCnt; col++) {
                    view.publiclyTrigger(
                        'dayRender',
                        null,
                        this.getCellDate(row, col),
                        this.getCellEl(row, col)
                    );
                }
            }
        },


        unrenderDates: function() {
            this.removeSegPopover();
        },


        renderBusinessHours: function() {
            var segs = this.buildBusinessHourSegs(true); // wholeDay=true
            this.renderFill('businessHours', segs, 'bgevent');
        },


        unrenderBusinessHours: function() {
            this.unrenderFill('businessHours');
        },


        // Generates the HTML for a single row, which is a div that wraps a table.
        // `row` is the row number.
        renderDayRowHtml: function(row, isRigid) {
            var view = this.view;
            var classes = [ 'fc-row', 'fc-week', view.widgetContentClass ];

            if (isRigid) {
                classes.push('fc-rigid');
            }

            return '' +
                '<div class="' + classes.join(' ') + '">' +
                '<div class="fc-bg">' +
                '<table>' +
                this.renderBgTrHtml(row) +
                '</table>' +
                '</div>' +
                '<div class="fc-content-skeleton">' +
                '<table>' +
                (this.numbersVisible ?
                        '<thead>' +
                        this.renderNumberTrHtml(row) +
                        '</thead>' :
                        ''
                ) +
                '</table>' +
                '</div>' +
                '</div>';
        },


        /* Grid Number Rendering
         ------------------------------------------------------------------------------------------------------------------*/


        renderNumberTrHtml: function(row) {
            return '' +
                '<tr>' +
                (this.isRTL ? '' : this.renderNumberIntroHtml(row)) +
                this.renderNumberCellsHtml(row) +
                (this.isRTL ? this.renderNumberIntroHtml(row) : '') +
                '</tr>';
        },


        renderNumberIntroHtml: function(row) {
            return this.renderIntroHtml();
        },


        renderNumberCellsHtml: function(row) {
            var htmls = [];
            var col, date;

            for (col = 0; col < this.colCnt; col++) {
                date = this.getCellDate(row, col);
                htmls.push(this.renderNumberCellHtml(date));
            }

            return htmls.join('');
        },


        // Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
        // The number row will only exist if either day numbers or week numbers are turned on.
        renderNumberCellHtml: function(date) {
            var view = this.view;
            var html = '';
            var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
            var isDayNumberVisible = view.dayNumbersVisible && isDateValid;
            var classes;
            var weekCalcFirstDoW;

            if (!isDayNumberVisible && !view.cellWeekNumbersVisible) {
                // no numbers in day cell (week number must be along the side)
                return '<td/>'; //  will create an empty space above events :(
            }

            classes = this.getDayClasses(date);
            classes.unshift('fc-day-top');

            if (view.cellWeekNumbersVisible) {
                // To determine the day of week number change under ISO, we cannot
                // rely on moment.js methods such as firstDayOfWeek() or weekday(),
                // because they rely on the locale's dow (possibly overridden by
                // our firstDay option), which may not be Monday. We cannot change
                // dow, because that would affect the calendar start day as well.
                if (date._locale._fullCalendar_weekCalc === 'ISO') {
                    weekCalcFirstDoW = 1;  // Monday by ISO 8601 definition
                }
                else {
                    weekCalcFirstDoW = date._locale.firstDayOfWeek();
                }
            }

            html += '<td class="' + classes.join(' ') + '"' +
                (isDateValid ?
                        ' data-date="' + date.format() + '"' :
                        ''
                ) +
                '>';

            if (view.cellWeekNumbersVisible && (date.day() == weekCalcFirstDoW)) {
                html += view.buildGotoAnchorHtml(
                    { date: date, type: 'week' },
                    { 'class': 'fc-week-number' },
                    date.format('w') // inner HTML
                );
            }

            if (isDayNumberVisible) {
                html += view.buildGotoAnchorHtml(
                    date,
                    { 'class': 'fc-day-number' },
                    date.date() // inner HTML
                );
            }

            html += '</td>';

            return html;
        },


        /* Options
         ------------------------------------------------------------------------------------------------------------------*/


        // Computes a default event time formatting string if `timeFormat` is not explicitly defined
        computeEventTimeFormat: function() {
            return this.view.opt('extraSmallTimeFormat'); // like "6p" or "6:30p"
        },


        // Computes a default `displayEventEnd` value if one is not expliclty defined
        computeDisplayEventEnd: function() {
            return this.colCnt == 1; // we'll likely have space if there's only one day
        },


        /* Dates
         ------------------------------------------------------------------------------------------------------------------*/


        rangeUpdated: function() {
            this.updateDayTable();
        },


        // Slices up the given span (unzoned start/end with other misc data) into an array of segments
        spanToSegs: function(span) {
            var segs = this.sliceRangeByRow(span);
            var i, seg;

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                if (this.isRTL) {
                    seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
                    seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
                }
                else {
                    seg.leftCol = seg.firstRowDayIndex;
                    seg.rightCol = seg.lastRowDayIndex;
                }
            }

            return segs;
        },


        /* Hit System
         ------------------------------------------------------------------------------------------------------------------*/


        prepareHits: function() {
            this.colCoordCache.build();
            this.rowCoordCache.build();
            this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
        },


        releaseHits: function() {
            this.colCoordCache.clear();
            this.rowCoordCache.clear();
        },


        queryHit: function(leftOffset, topOffset) {
            if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {
                var col = this.colCoordCache.getHorizontalIndex(leftOffset);
                var row = this.rowCoordCache.getVerticalIndex(topOffset);

                if (row != null && col != null) {
                    return this.getCellHit(row, col);
                }
            }
        },


        getHitSpan: function(hit) {
            return this.getCellRange(hit.row, hit.col);
        },


        getHitEl: function(hit) {
            return this.getCellEl(hit.row, hit.col);
        },


        /* Cell System
         ------------------------------------------------------------------------------------------------------------------*/
        // FYI: the first column is the leftmost column, regardless of date


        getCellHit: function(row, col) {
            return {
                row: row,
                col: col,
                component: this, // needed unfortunately :(
                left: this.colCoordCache.getLeftOffset(col),
                right: this.colCoordCache.getRightOffset(col),
                top: this.rowCoordCache.getTopOffset(row),
                bottom: this.rowCoordCache.getBottomOffset(row)
            };
        },


        getCellEl: function(row, col) {
            return this.cellEls.eq(row * this.colCnt + col);
        },


        /* Event Drag Visualization
         ------------------------------------------------------------------------------------------------------------------*/
        // TODO: move to DayGrid.event, similar to what we did with Grid's drag methods


        // Renders a visual indication of an event or external element being dragged.
        // `eventLocation` has zoned start and end (optional)
        renderDrag: function(eventLocation, seg) {
            var eventSpans = this.eventToSpans(eventLocation);
            var i;

            // always render a highlight underneath
            for (i = 0; i < eventSpans.length; i++) {
                this.renderHighlight(eventSpans[i]);
            }

            // if a segment from the same calendar but another component is being dragged, render a helper event
            if (seg && seg.component !== this) {
                return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
            }
        },


        // Unrenders any visual indication of a hovering event
        unrenderDrag: function() {
            this.unrenderHighlight();
            this.unrenderHelper();
        },


        /* Event Resize Visualization
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of an event being resized
        renderEventResize: function(eventLocation, seg) {
            var eventSpans = this.eventToSpans(eventLocation);
            var i;

            for (i = 0; i < eventSpans.length; i++) {
                this.renderHighlight(eventSpans[i]);
            }

            return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
        },


        // Unrenders a visual indication of an event being resized
        unrenderEventResize: function() {
            this.unrenderHighlight();
            this.unrenderHelper();
        },


        /* Event Helper
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
        renderHelper: function(event, sourceSeg) {
            var helperNodes = [];
            var segs = this.eventToSegs(event);
            var rowStructs;

            segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered
            rowStructs = this.renderSegRows(segs);

            // inject each new event skeleton into each associated row
            this.rowEls.each(function(row, rowNode) {
                var rowEl = $(rowNode); // the .fc-row
                var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>'); // will be absolutely positioned
                var skeletonTop;

                // If there is an original segment, match the top position. Otherwise, put it at the row's top level
                if (sourceSeg && sourceSeg.row === row) {
                    skeletonTop = sourceSeg.el.position().top;
                }
                else {
                    skeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;
                }

                skeletonEl.css('top', skeletonTop)
                    .find('table')
                    .append(rowStructs[row].tbodyEl);

                rowEl.append(skeletonEl);
                helperNodes.push(skeletonEl[0]);
            });

            return ( // must return the elements rendered
                this.helperEls = $(helperNodes) // array -> jQuery set
            );
        },


        // Unrenders any visual indication of a mock helper event
        unrenderHelper: function() {
            if (this.helperEls) {
                this.helperEls.remove();
                this.helperEls = null;
            }
        },


        /* Fill System (highlight, background events, business hours)
         ------------------------------------------------------------------------------------------------------------------*/


        fillSegTag: 'td', // override the default tag name


        // Renders a set of rectangles over the given segments of days.
        // Only returns segments that successfully rendered.
        renderFill: function(type, segs, className) {
            var nodes = [];
            var i, seg;
            var skeletonEl;

            segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                skeletonEl = this.renderFillRow(type, seg, className);
                this.rowEls.eq(seg.row).append(skeletonEl);
                nodes.push(skeletonEl[0]);
            }

            this.elsByFill[type] = $(nodes);

            return segs;
        },


        // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
        renderFillRow: function(type, seg, className) {
            var colCnt = this.colCnt;
            var startCol = seg.leftCol;
            var endCol = seg.rightCol + 1;
            var skeletonEl;
            var trEl;

            className = className || type.toLowerCase();

            skeletonEl = $(
                '<div class="fc-' + className + '-skeleton">' +
                '<table><tr/></table>' +
                '</div>'
            );
            trEl = skeletonEl.find('tr');

            if (startCol > 0) {
                trEl.append('<td colspan="' + startCol + '"/>');
            }

            trEl.append(
                seg.el.attr('colspan', endCol - startCol)
            );

            if (endCol < colCnt) {
                trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
            }

            this.bookendCells(trEl);

            return skeletonEl;
        }

    });

    ;;

    /* Event-rendering methods for the DayGrid class
     ----------------------------------------------------------------------------------------------------------------------*/

    DayGrid.mixin({

        rowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering


        // Unrenders all events currently rendered on the grid
        unrenderEvents: function() {
            this.removeSegPopover(); // removes the "more.." events popover
            Grid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method
        },


        // Retrieves all rendered segment objects currently rendered on the grid
        getEventSegs: function() {
            return Grid.prototype.getEventSegs.call(this) // get the segments from the super-method
                .concat(this.popoverSegs || []); // append the segments from the "more..." popover
        },


        // Renders the given background event segments onto the grid
        renderBgSegs: function(segs) {

            // don't render timed background events
            var allDaySegs = $.grep(segs, function(seg) {
                return seg.event.allDay;
            });

            return Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method
        },


        // Renders the given foreground event segments onto the grid
        renderFgSegs: function(segs) {
            var rowStructs;

            // render an `.el` on each seg
            // returns a subset of the segs. segs that were actually rendered
            segs = this.renderFgSegEls(segs);

            rowStructs = this.rowStructs = this.renderSegRows(segs);

            // append to each row's content skeleton
            this.rowEls.each(function(i, rowNode) {
                $(rowNode).find('.fc-content-skeleton > table').append(
                    rowStructs[i].tbodyEl
                );
            });

            return segs; // return only the segs that were actually rendered
        },


        // Unrenders all currently rendered foreground event segments
        unrenderFgSegs: function() {
            var rowStructs = this.rowStructs || [];
            var rowStruct;

            while ((rowStruct = rowStructs.pop())) {
                rowStruct.tbodyEl.remove();
            }

            this.rowStructs = null;
        },


        // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
        // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
        // PRECONDITION: each segment shoud already have a rendered and assigned `.el`
        renderSegRows: function(segs) {
            var rowStructs = [];
            var segRows;
            var row;

            segRows = this.groupSegRows(segs); // group into nested arrays

            // iterate each row of segment groupings
            for (row = 0; row < segRows.length; row++) {
                rowStructs.push(
                    this.renderSegRow(row, segRows[row])
                );
            }

            return rowStructs;
        },


        // Builds the HTML to be used for the default element for an individual segment
        fgSegHtml: function(seg, disableResizing) {
            var view = this.view;
            var event = seg.event;
            var isDraggable = view.isEventDraggable(event);
            var isResizableFromStart = !disableResizing && event.allDay &&
                seg.isStart && view.isEventResizableFromStart(event);
            var isResizableFromEnd = !disableResizing && event.allDay &&
                seg.isEnd && view.isEventResizableFromEnd(event);
            var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
            var skinCss = cssToStr(this.getSegSkinCss(seg));
            var timeHtml = '';
            var timeText;
            var titleHtml;

            classes.unshift('fc-day-grid-event', 'fc-h-event');

            // Only display a timed events time if it is the starting segment
            if (seg.isStart) {
                timeText = this.getEventTimeText(event);
                if (timeText) {
                    timeHtml = '<span class="fc-time">' + htmlEscape(timeText) + '</span>';
                }
            }

            titleHtml =
                '<span class="fc-title">' +
                (htmlEscape(event.title || '') || '&nbsp;') + // we always want one line of height
                '</span>';

            return '<a class="' + classes.join(' ') + '"' +
                (event.url ?
                        ' href="' + htmlEscape(event.url) + '"' :
                        ''
                ) +
                (skinCss ?
                        ' style="' + skinCss + '"' :
                        ''
                ) +
                '>' +
                '<div class="fc-content">' +
                (this.isRTL ?
                        titleHtml + ' ' + timeHtml : // put a natural space in between
                        timeHtml + ' ' + titleHtml   //
                ) +
                '</div>' +
                (isResizableFromStart ?
                        '<div class="fc-resizer fc-start-resizer" />' :
                        ''
                ) +
                (isResizableFromEnd ?
                        '<div class="fc-resizer fc-end-resizer" />' :
                        ''
                ) +
                '</a>';
        },


        // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
        // the segments. Returns object with a bunch of internal data about how the render was calculated.
        // NOTE: modifies rowSegs
        renderSegRow: function(row, rowSegs) {
            var colCnt = this.colCnt;
            var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
            var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
            var tbody = $('<tbody/>');
            var segMatrix = []; // lookup for which segments are rendered into which level+col cells
            var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
            var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
            var i, levelSegs;
            var col;
            var tr;
            var j, seg;
            var td;

            // populates empty cells from the current column (`col`) to `endCol`
            function emptyCellsUntil(endCol) {
                while (col < endCol) {
                    // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
                    td = (loneCellMatrix[i - 1] || [])[col];
                    if (td) {
                        td.attr(
                            'rowspan',
                            parseInt(td.attr('rowspan') || 1, 10) + 1
                        );
                    }
                    else {
                        td = $('<td/>');
                        tr.append(td);
                    }
                    cellMatrix[i][col] = td;
                    loneCellMatrix[i][col] = td;
                    col++;
                }
            }

            for (i = 0; i < levelCnt; i++) { // iterate through all levels
                levelSegs = segLevels[i];
                col = 0;
                tr = $('<tr/>');

                segMatrix.push([]);
                cellMatrix.push([]);
                loneCellMatrix.push([]);

                // levelCnt might be 1 even though there are no actual levels. protect against this.
                // this single empty row is useful for styling.
                if (levelSegs) {
                    for (j = 0; j < levelSegs.length; j++) { // iterate through segments in level
                        seg = levelSegs[j];

                        emptyCellsUntil(seg.leftCol);

                        // create a container that occupies or more columns. append the event element.
                        td = $('<td class="fc-event-container"/>').append(seg.el);
                        if (seg.leftCol != seg.rightCol) {
                            td.attr('colspan', seg.rightCol - seg.leftCol + 1);
                        }
                        else { // a single-column segment
                            loneCellMatrix[i][col] = td;
                        }

                        while (col <= seg.rightCol) {
                            cellMatrix[i][col] = td;
                            segMatrix[i][col] = seg;
                            col++;
                        }

                        tr.append(td);
                    }
                }

                emptyCellsUntil(colCnt); // finish off the row
                this.bookendCells(tr);
                tbody.append(tr);
            }

            return { // a "rowStruct"
                row: row, // the row number
                tbodyEl: tbody,
                cellMatrix: cellMatrix,
                segMatrix: segMatrix,
                segLevels: segLevels,
                segs: rowSegs
            };
        },


        // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
        // NOTE: modifies segs
        buildSegLevels: function(segs) {
            var levels = [];
            var i, seg;
            var j;

            // Give preference to elements with certain criteria, so they have
            // a chance to be closer to the top.
            this.sortEventSegs(segs);

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];

                // loop through levels, starting with the topmost, until the segment doesn't collide with other segments
                for (j = 0; j < levels.length; j++) {
                    if (!isDaySegCollision(seg, levels[j])) {
                        break;
                    }
                }
                // `j` now holds the desired subrow index
                seg.level = j;

                // create new level array if needed and append segment
                (levels[j] || (levels[j] = [])).push(seg);
            }

            // order segments left-to-right. very important if calendar is RTL
            for (j = 0; j < levels.length; j++) {
                levels[j].sort(compareDaySegCols);
            }

            return levels;
        },


        // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
        groupSegRows: function(segs) {
            var segRows = [];
            var i;

            for (i = 0; i < this.rowCnt; i++) {
                segRows.push([]);
            }

            for (i = 0; i < segs.length; i++) {
                segRows[segs[i].row].push(segs[i]);
            }

            return segRows;
        }

    });


// Computes whether two segments' columns collide. They are assumed to be in the same row.
    function isDaySegCollision(seg, otherSegs) {
        var i, otherSeg;

        for (i = 0; i < otherSegs.length; i++) {
            otherSeg = otherSegs[i];

            if (
                otherSeg.leftCol <= seg.rightCol &&
                otherSeg.rightCol >= seg.leftCol
            ) {
                return true;
            }
        }

        return false;
    }


// A cmp function for determining the leftmost event
    function compareDaySegCols(a, b) {
        return a.leftCol - b.leftCol;
    }

    ;;

    /* Methods relate to limiting the number events for a given day on a DayGrid
     ----------------------------------------------------------------------------------------------------------------------*/
// NOTE: all the segs being passed around in here are foreground segs

    DayGrid.mixin({

        segPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible
        popoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible


        removeSegPopover: function() {
            if (this.segPopover) {
                this.segPopover.hide(); // in handler, will call segPopover's removeElement
            }
        },


        // Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
        // `levelLimit` can be false (don't limit), a number, or true (should be computed).
        limitRows: function(levelLimit) {
            var rowStructs = this.rowStructs || [];
            var row; // row #
            var rowLevelLimit;

            for (row = 0; row < rowStructs.length; row++) {
                this.unlimitRow(row);

                if (!levelLimit) {
                    rowLevelLimit = false;
                }
                else if (typeof levelLimit === 'number') {
                    rowLevelLimit = levelLimit;
                }
                else {
                    rowLevelLimit = this.computeRowLevelLimit(row);
                }

                if (rowLevelLimit !== false) {
                    this.limitRow(row, rowLevelLimit);
                }
            }
        },


        // Computes the number of levels a row will accomodate without going outside its bounds.
        // Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
        // `row` is the row number.
        computeRowLevelLimit: function(row) {
            var rowEl = this.rowEls.eq(row); // the containing "fake" row div
            var rowHeight = rowEl.height(); // TODO: cache somehow?
            var trEls = this.rowStructs[row].tbodyEl.children();
            var i, trEl;
            var trHeight;

            function iterInnerHeights(i, childNode) {
                trHeight = Math.max(trHeight, $(childNode).outerHeight());
            }

            // Reveal one level <tr> at a time and stop when we find one out of bounds
            for (i = 0; i < trEls.length; i++) {
                trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)

                // with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
                // so instead, find the tallest inner content element.
                trHeight = 0;
                trEl.find('> td > :first-child').each(iterInnerHeights);

                if (trEl.position().top + trHeight > rowHeight) {
                    return i;
                }
            }

            return false; // should not limit at all
        },


        // Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
        // `row` is the row number.
        // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
        limitRow: function(row, levelLimit) {
            var _this = this;
            var rowStruct = this.rowStructs[row];
            var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
            var col = 0; // col #, left-to-right (not chronologically)
            var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
            var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row
            var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
            var i, seg;
            var segsBelow; // array of segment objects below `seg` in the current `col`
            var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
            var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
            var td, rowspan;
            var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
            var j;
            var moreTd, moreWrap, moreLink;

            // Iterates through empty level cells and places "more" links inside if need be
            function emptyCellsUntil(endCol) { // goes from current `col` to `endCol`
                while (col < endCol) {
                    segsBelow = _this.getCellSegs(row, col, levelLimit);
                    if (segsBelow.length) {
                        td = cellMatrix[levelLimit - 1][col];
                        moreLink = _this.renderMoreLink(row, col, segsBelow);
                        moreWrap = $('<div/>').append(moreLink);
                        td.append(moreWrap);
                        moreNodes.push(moreWrap[0]);
                    }
                    col++;
                }
            }

            if (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?
                levelSegs = rowStruct.segLevels[levelLimit - 1];
                cellMatrix = rowStruct.cellMatrix;

                limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit
                    .addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array

                // iterate though segments in the last allowable level
                for (i = 0; i < levelSegs.length; i++) {
                    seg = levelSegs[i];
                    emptyCellsUntil(seg.leftCol); // process empty cells before the segment

                    // determine *all* segments below `seg` that occupy the same columns
                    colSegsBelow = [];
                    totalSegsBelow = 0;
                    while (col <= seg.rightCol) {
                        segsBelow = this.getCellSegs(row, col, levelLimit);
                        colSegsBelow.push(segsBelow);
                        totalSegsBelow += segsBelow.length;
                        col++;
                    }

                    if (totalSegsBelow) { // do we need to replace this segment with one or many "more" links?
                        td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
                        rowspan = td.attr('rowspan') || 1;
                        segMoreNodes = [];

                        // make a replacement <td> for each column the segment occupies. will be one for each colspan
                        for (j = 0; j < colSegsBelow.length; j++) {
                            moreTd = $('<td class="fc-more-cell"/>').attr('rowspan', rowspan);
                            segsBelow = colSegsBelow[j];
                            moreLink = this.renderMoreLink(
                                row,
                                seg.leftCol + j,
                                [ seg ].concat(segsBelow) // count seg as hidden too
                            );
                            moreWrap = $('<div/>').append(moreLink);
                            moreTd.append(moreWrap);
                            segMoreNodes.push(moreTd[0]);
                            moreNodes.push(moreTd[0]);
                        }

                        td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements
                        limitedNodes.push(td[0]);
                    }
                }

                emptyCellsUntil(this.colCnt); // finish off the level
                rowStruct.moreEls = $(moreNodes); // for easy undoing later
                rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
            }
        },


        // Reveals all levels and removes all "more"-related elements for a grid's row.
        // `row` is a row number.
        unlimitRow: function(row) {
            var rowStruct = this.rowStructs[row];

            if (rowStruct.moreEls) {
                rowStruct.moreEls.remove();
                rowStruct.moreEls = null;
            }

            if (rowStruct.limitedEls) {
                rowStruct.limitedEls.removeClass('fc-limited');
                rowStruct.limitedEls = null;
            }
        },


        // Renders an <a> element that represents hidden event element for a cell.
        // Responsible for attaching click handler as well.
        renderMoreLink: function(row, col, hiddenSegs) {
            var _this = this;
            var view = this.view;

            return $('<a class="fc-more"/>')
                .text(
                    this.getMoreLinkText(hiddenSegs.length)
                )
                .on('click', function(ev) {
                    var clickOption = view.opt('eventLimitClick');
                    var date = _this.getCellDate(row, col);
                    var moreEl = $(this);
                    var dayEl = _this.getCellEl(row, col);
                    var allSegs = _this.getCellSegs(row, col);

                    // rescope the segments to be within the cell's date
                    var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
                    var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);

                    if (typeof clickOption === 'function') {
                        // the returned value can be an atomic option
                        clickOption = view.publiclyTrigger('eventLimitClick', null, {
                            date: date,
                            dayEl: dayEl,
                            moreEl: moreEl,
                            segs: reslicedAllSegs,
                            hiddenSegs: reslicedHiddenSegs
                        }, ev);
                    }

                    if (clickOption === 'popover') {
                        _this.showSegPopover(row, col, moreEl, reslicedAllSegs);
                    }
                    else if (typeof clickOption === 'string') { // a view name
                        view.calendar.zoomTo(date, clickOption);
                    }
                });
        },


        // Reveals the popover that displays all events within a cell
        showSegPopover: function(row, col, moreLink, segs) {
            var _this = this;
            var view = this.view;
            var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>
            var topEl; // the element we want to match the top coordinate of
            var options;

            if (this.rowCnt == 1) {
                topEl = view.el; // will cause the popover to cover any sort of header
            }
            else {
                topEl = this.rowEls.eq(row); // will align with top of row
            }

            options = {
                className: 'fc-more-popover',
                content: this.renderSegPopoverContent(row, col, segs),
                parentEl: this.view.el, // attach to root of view. guarantees outside of scrollbars.
                top: topEl.offset().top,
                autoHide: true, // when the user clicks elsewhere, hide the popover
                viewportConstrain: view.opt('popoverViewportConstrain'),
                hide: function() {
                    // kill everything when the popover is hidden
                    // notify events to be removed
                    if (_this.popoverSegs) {
                        var seg;
                        for (var i = 0; i < _this.popoverSegs.length; ++i) {
                            seg = _this.popoverSegs[i];
                            view.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);
                        }
                    }
                    _this.segPopover.removeElement();
                    _this.segPopover = null;
                    _this.popoverSegs = null;
                }
            };

            // Determine horizontal coordinate.
            // We use the moreWrap instead of the <td> to avoid border confusion.
            if (this.isRTL) {
                options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
            }
            else {
                options.left = moreWrap.offset().left - 1; // -1 to be over cell border
            }

            this.segPopover = new Popover(options);
            this.segPopover.show();

            // the popover doesn't live within the grid's container element, and thus won't get the event
            // delegated-handlers for free. attach event-related handlers to the popover.
            this.bindSegHandlersToEl(this.segPopover.el);
        },


        // Builds the inner DOM contents of the segment popover
        renderSegPopoverContent: function(row, col, segs) {
            var view = this.view;
            var isTheme = view.opt('theme');
            var title = this.getCellDate(row, col).format(view.opt('dayPopoverFormat'));
            var content = $(
                '<div class="fc-header ' + view.widgetHeaderClass + '">' +
                '<span class="fc-close ' +
                (isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') +
                '"></span>' +
                '<span class="fc-title">' +
                htmlEscape(title) +
                '</span>' +
                '<div class="fc-clear"/>' +
                '</div>' +
                '<div class="fc-body ' + view.widgetContentClass + '">' +
                '<div class="fc-event-container"></div>' +
                '</div>'
            );
            var segContainer = content.find('.fc-event-container');
            var i;

            // render each seg's `el` and only return the visible segs
            segs = this.renderFgSegEls(segs, true); // disableResizing=true
            this.popoverSegs = segs;

            for (i = 0; i < segs.length; i++) {

                // because segments in the popover are not part of a grid coordinate system, provide a hint to any
                // grids that want to do drag-n-drop about which cell it came from
                this.hitsNeeded();
                segs[i].hit = this.getCellHit(row, col);
                this.hitsNotNeeded();

                segContainer.append(segs[i].el);
            }

            return content;
        },


        // Given the events within an array of segment objects, reslice them to be in a single day
        resliceDaySegs: function(segs, dayDate) {

            // build an array of the original events
            var events = $.map(segs, function(seg) {
                return seg.event;
            });

            var dayStart = dayDate.clone();
            var dayEnd = dayStart.clone().add(1, 'days');
            var dayRange = { start: dayStart, end: dayEnd };

            // slice the events with a custom slicing function
            segs = this.eventsToSegs(
                events,
                function(range) {
                    var seg = intersectRanges(range, dayRange); // undefind if no intersection
                    return seg ? [ seg ] : []; // must return an array of segments
                }
            );

            // force an order because eventsToSegs doesn't guarantee one
            this.sortEventSegs(segs);

            return segs;
        },


        // Generates the text that should be inside a "more" link, given the number of events it represents
        getMoreLinkText: function(num) {
            var opt = this.view.opt('eventLimitText');

            if (typeof opt === 'function') {
                return opt(num);
            }
            else {
                return '+' + num + ' ' + opt;
            }
        },


        // Returns segments within a given cell.
        // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
        getCellSegs: function(row, col, startLevel) {
            var segMatrix = this.rowStructs[row].segMatrix;
            var level = startLevel || 0;
            var segs = [];
            var seg;

            while (level < segMatrix.length) {
                seg = segMatrix[level][col];
                if (seg) {
                    segs.push(seg);
                }
                level++;
            }

            return segs;
        }

    });

    ;;

    /* A component that renders one or more columns of vertical time slots
     ----------------------------------------------------------------------------------------------------------------------*/
// We mixin DayTable, even though there is only a single row of days

    var TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {

        slotDuration: null, // duration of a "slot", a distinct time segment on given day, visualized by lines
        snapDuration: null, // granularity of time for dragging and selecting
        snapsPerSlot: null,
        labelFormat: null, // formatting string for times running along vertical axis
        labelInterval: null, // duration of how often a label should be displayed for a slot

        colEls: null, // cells elements in the day-row background
        slatContainerEl: null, // div that wraps all the slat rows
        slatEls: null, // elements running horizontally across all columns
        nowIndicatorEls: null,

        colCoordCache: null,
        slatCoordCache: null,


        constructor: function() {
            Grid.apply(this, arguments); // call the super-constructor

            this.processOptions();
        },


        // Renders the time grid into `this.el`, which should already be assigned.
        // Relies on the view's colCnt. In the future, this component should probably be self-sufficient.
        renderDates: function() {
            this.el.html(this.renderHtml());
            this.colEls = this.el.find('.fc-day, .fc-disabled-day');
            this.slatContainerEl = this.el.find('.fc-slats');
            this.slatEls = this.slatContainerEl.find('tr');

            this.colCoordCache = new CoordCache({
                els: this.colEls,
                isHorizontal: true
            });
            this.slatCoordCache = new CoordCache({
                els: this.slatEls,
                isVertical: true
            });

            this.renderContentSkeleton();
        },


        // Renders the basic HTML skeleton for the grid
        renderHtml: function() {
            return '' +
                '<div class="fc-bg">' +
                '<table>' +
                this.renderBgTrHtml(0) + // row=0
                '</table>' +
                '</div>' +
                '<div class="fc-slats">' +
                '<table>' +
                this.renderSlatRowHtml() +
                '</table>' +
                '</div>';
        },


        // Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
        renderSlatRowHtml: function() {
            var view = this.view;
            var isRTL = this.isRTL;
            var html = '';
            var slotTime = moment.duration(+this.view.minTime); // wish there was .clone() for durations
            var slotDate; // will be on the view's first day, but we only care about its time
            var isLabeled;
            var axisHtml;

            // Calculate the time for each slot
            while (slotTime < this.view.maxTime) {
                slotDate = this.start.clone().time(slotTime);
                isLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));

                axisHtml =
                    '<td class="fc-axis fc-time ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
                    (isLabeled ?
                            '<span>' + // for matchCellWidths
                            htmlEscape(slotDate.format(this.labelFormat)) +
                            '</span>' :
                            ''
                    ) +
                    '</td>';

                html +=
                    '<tr data-time="' + slotDate.format('HH:mm:ss') + '"' +
                    (isLabeled ? '' : ' class="fc-minor"') +
                    '>' +
                    (!isRTL ? axisHtml : '') +
                    '<td class="' + view.widgetContentClass + '"/>' +
                    (isRTL ? axisHtml : '') +
                    "</tr>";

                slotTime.add(this.slotDuration);
            }

            return html;
        },


        /* Options
         ------------------------------------------------------------------------------------------------------------------*/


        // Parses various options into properties of this object
        processOptions: function() {
            var view = this.view;
            var slotDuration = view.opt('slotDuration');
            var snapDuration = view.opt('snapDuration');
            var input;

            slotDuration = moment.duration(slotDuration);
            snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;

            this.slotDuration = slotDuration;
            this.snapDuration = snapDuration;
            this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?

            this.minResizeDuration = snapDuration; // hack

            // might be an array value (for TimelineView).
            // if so, getting the most granular entry (the last one probably).
            input = view.opt('slotLabelFormat');
            if ($.isArray(input)) {
                input = input[input.length - 1];
            }

            this.labelFormat =
                input ||
                view.opt('smallTimeFormat'); // the computed default

            input = view.opt('slotLabelInterval');
            this.labelInterval = input ?
                moment.duration(input) :
                this.computeLabelInterval(slotDuration);
        },


        // Computes an automatic value for slotLabelInterval
        computeLabelInterval: function(slotDuration) {
            var i;
            var labelInterval;
            var slotsPerLabel;

            // find the smallest stock label interval that results in more than one slots-per-label
            for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
                labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
                slotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);
                if (isInt(slotsPerLabel) && slotsPerLabel > 1) {
                    return labelInterval;
                }
            }

            return moment.duration(slotDuration); // fall back. clone
        },


        // Computes a default event time formatting string if `timeFormat` is not explicitly defined
        computeEventTimeFormat: function() {
            return this.view.opt('noMeridiemTimeFormat'); // like "6:30" (no AM/PM)
        },


        // Computes a default `displayEventEnd` value if one is not expliclty defined
        computeDisplayEventEnd: function() {
            return true;
        },


        /* Hit System
         ------------------------------------------------------------------------------------------------------------------*/


        prepareHits: function() {
            this.colCoordCache.build();
            this.slatCoordCache.build();
        },


        releaseHits: function() {
            this.colCoordCache.clear();
            // NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop
        },


        queryHit: function(leftOffset, topOffset) {
            var snapsPerSlot = this.snapsPerSlot;
            var colCoordCache = this.colCoordCache;
            var slatCoordCache = this.slatCoordCache;

            if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {
                var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
                var slatIndex = slatCoordCache.getVerticalIndex(topOffset);

                if (colIndex != null && slatIndex != null) {
                    var slatTop = slatCoordCache.getTopOffset(slatIndex);
                    var slatHeight = slatCoordCache.getHeight(slatIndex);
                    var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1
                    var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
                    var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
                    var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
                    var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;

                    return {
                        col: colIndex,
                        snap: snapIndex,
                        component: this, // needed unfortunately :(
                        left: colCoordCache.getLeftOffset(colIndex),
                        right: colCoordCache.getRightOffset(colIndex),
                        top: snapTop,
                        bottom: snapBottom
                    };
                }
            }
        },


        getHitSpan: function(hit) {
            var start = this.getCellDate(0, hit.col); // row=0
            var time = this.computeSnapTime(hit.snap); // pass in the snap-index
            var end;

            start.time(time);
            end = start.clone().add(this.snapDuration);

            return { start: start, end: end };
        },


        getHitEl: function(hit) {
            return this.colEls.eq(hit.col);
        },


        /* Dates
         ------------------------------------------------------------------------------------------------------------------*/


        rangeUpdated: function() {
            this.updateDayTable();
        },


        // Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
        computeSnapTime: function(snapIndex) {
            return moment.duration(this.view.minTime + this.snapDuration * snapIndex);
        },


        // Slices up the given span (unzoned start/end with other misc data) into an array of segments
        spanToSegs: function(span) {
            var segs = this.sliceRangeByTimes(span);
            var i;

            for (i = 0; i < segs.length; i++) {
                if (this.isRTL) {
                    segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
                }
                else {
                    segs[i].col = segs[i].dayIndex;
                }
            }

            return segs;
        },


        sliceRangeByTimes: function(range) {
            var segs = [];
            var seg;
            var dayIndex;
            var dayDate;
            var dayRange;

            for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
                dayDate = this.dayDates[dayIndex].clone().time(0); // TODO: better API for this?
                dayRange = {
                    start: dayDate.clone().add(this.view.minTime), // don't use .time() because it sux with negatives
                    end: dayDate.clone().add(this.view.maxTime)
                };
                seg = intersectRanges(range, dayRange); // both will be ambig timezone
                if (seg) {
                    seg.dayIndex = dayIndex;
                    segs.push(seg);
                }
            }

            return segs;
        },


        /* Coordinates
         ------------------------------------------------------------------------------------------------------------------*/


        updateSize: function(isResize) { // NOT a standard Grid method
            this.slatCoordCache.build();

            if (isResize) {
                this.updateSegVerticals(
                    [].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || [])
                );
            }
        },


        getTotalSlatHeight: function() {
            return this.slatContainerEl.outerHeight();
        },


        // Computes the top coordinate, relative to the bounds of the grid, of the given date.
        // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
        computeDateTop: function(date, startOfDayDate) {
            return this.computeTimeTop(
                moment.duration(
                    date - startOfDayDate.clone().stripTime()
                )
            );
        },


        // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
        computeTimeTop: function(time) {
            var len = this.slatEls.length;
            var slatCoverage = (time - this.view.minTime) / this.slotDuration; // floating-point value of # of slots covered
            var slatIndex;
            var slatRemainder;

            // compute a floating-point number for how many slats should be progressed through.
            // from 0 to number of slats (inclusive)
            // constrained because minTime/maxTime might be customized.
            slatCoverage = Math.max(0, slatCoverage);
            slatCoverage = Math.min(len, slatCoverage);

            // an integer index of the furthest whole slat
            // from 0 to number slats (*exclusive*, so len-1)
            slatIndex = Math.floor(slatCoverage);
            slatIndex = Math.min(slatIndex, len - 1);

            // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
            // could be 1.0 if slatCoverage is covering *all* the slots
            slatRemainder = slatCoverage - slatIndex;

            return this.slatCoordCache.getTopPosition(slatIndex) +
                this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
        },



        /* Event Drag Visualization
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of an event being dragged over the specified date(s).
        // A returned value of `true` signals that a mock "helper" event has been rendered.
        renderDrag: function(eventLocation, seg) {
            var eventSpans;
            var i;

            if (seg) { // if there is event information for this drag, render a helper event

                // returns mock event elements
                // signal that a helper has been rendered
                return this.renderEventLocationHelper(eventLocation, seg);
            }
            else { // otherwise, just render a highlight
                eventSpans = this.eventToSpans(eventLocation);

                for (i = 0; i < eventSpans.length; i++) {
                    this.renderHighlight(eventSpans[i]);
                }
            }
        },


        // Unrenders any visual indication of an event being dragged
        unrenderDrag: function() {
            this.unrenderHelper();
            this.unrenderHighlight();
        },


        /* Event Resize Visualization
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of an event being resized
        renderEventResize: function(eventLocation, seg) {
            return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
        },


        // Unrenders any visual indication of an event being resized
        unrenderEventResize: function() {
            this.unrenderHelper();
        },


        /* Event Helper
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders a mock "helper" event. `sourceSeg` is the original segment object and might be null (an external drag)
        renderHelper: function(event, sourceSeg) {
            return this.renderHelperSegs(this.eventToSegs(event), sourceSeg); // returns mock event elements
        },


        // Unrenders any mock helper event
        unrenderHelper: function() {
            this.unrenderHelperSegs();
        },


        /* Business Hours
         ------------------------------------------------------------------------------------------------------------------*/


        renderBusinessHours: function() {
            this.renderBusinessSegs(
                this.buildBusinessHourSegs()
            );
        },


        unrenderBusinessHours: function() {
            this.unrenderBusinessSegs();
        },


        /* Now Indicator
         ------------------------------------------------------------------------------------------------------------------*/


        getNowIndicatorUnit: function() {
            return 'minute'; // will refresh on the minute
        },


        renderNowIndicator: function(date) {
            // seg system might be overkill, but it handles scenario where line needs to be rendered
            //  more than once because of columns with the same date (resources columns for example)
            var segs = this.spanToSegs({ start: date, end: date });
            var top = this.computeDateTop(date, date);
            var nodes = [];
            var i;

            // render lines within the columns
            for (i = 0; i < segs.length; i++) {
                nodes.push($('<div class="fc-now-indicator fc-now-indicator-line"></div>')
                    .css('top', top)
                    .appendTo(this.colContainerEls.eq(segs[i].col))[0]);
            }

            // render an arrow over the axis
            if (segs.length > 0) { // is the current time in view?
                nodes.push($('<div class="fc-now-indicator fc-now-indicator-arrow"></div>')
                    .css('top', top)
                    .appendTo(this.el.find('.fc-content-skeleton'))[0]);
            }

            this.nowIndicatorEls = $(nodes);
        },


        unrenderNowIndicator: function() {
            if (this.nowIndicatorEls) {
                this.nowIndicatorEls.remove();
                this.nowIndicatorEls = null;
            }
        },


        /* Selection
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
        renderSelection: function(span) {
            if (this.view.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered

                // normally acceps an eventLocation, span has a start/end, which is good enough
                this.renderEventLocationHelper(span);
            }
            else {
                this.renderHighlight(span);
            }
        },


        // Unrenders any visual indication of a selection
        unrenderSelection: function() {
            this.unrenderHelper();
            this.unrenderHighlight();
        },


        /* Highlight
         ------------------------------------------------------------------------------------------------------------------*/


        renderHighlight: function(span) {
            this.renderHighlightSegs(this.spanToSegs(span));
        },


        unrenderHighlight: function() {
            this.unrenderHighlightSegs();
        }

    });

    ;;

    /* Methods for rendering SEGMENTS, pieces of content that live on the view
     ( this file is no longer just for events )
     ----------------------------------------------------------------------------------------------------------------------*/

    TimeGrid.mixin({

        colContainerEls: null, // containers for each column

        // inner-containers for each column where different types of segs live
        fgContainerEls: null,
        bgContainerEls: null,
        helperContainerEls: null,
        highlightContainerEls: null,
        businessContainerEls: null,

        // arrays of different types of displayed segments
        fgSegs: null,
        bgSegs: null,
        helperSegs: null,
        highlightSegs: null,
        businessSegs: null,


        // Renders the DOM that the view's content will live in
        renderContentSkeleton: function() {
            var cellHtml = '';
            var i;
            var skeletonEl;

            for (i = 0; i < this.colCnt; i++) {
                cellHtml +=
                    '<td>' +
                    '<div class="fc-content-col">' +
                    '<div class="fc-event-container fc-helper-container"></div>' +
                    '<div class="fc-event-container"></div>' +
                    '<div class="fc-highlight-container"></div>' +
                    '<div class="fc-bgevent-container"></div>' +
                    '<div class="fc-business-container"></div>' +
                    '</div>' +
                    '</td>';
            }

            skeletonEl = $(
                '<div class="fc-content-skeleton">' +
                '<table>' +
                '<tr>' + cellHtml + '</tr>' +
                '</table>' +
                '</div>'
            );

            this.colContainerEls = skeletonEl.find('.fc-content-col');
            this.helperContainerEls = skeletonEl.find('.fc-helper-container');
            this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');
            this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');
            this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');
            this.businessContainerEls = skeletonEl.find('.fc-business-container');

            this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level
            this.el.append(skeletonEl);
        },


        /* Foreground Events
         ------------------------------------------------------------------------------------------------------------------*/


        renderFgSegs: function(segs) {
            segs = this.renderFgSegsIntoContainers(segs, this.fgContainerEls);
            this.fgSegs = segs;
            return segs; // needed for Grid::renderEvents
        },


        unrenderFgSegs: function() {
            this.unrenderNamedSegs('fgSegs');
        },


        /* Foreground Helper Events
         ------------------------------------------------------------------------------------------------------------------*/


        renderHelperSegs: function(segs, sourceSeg) {
            var helperEls = [];
            var i, seg;
            var sourceEl;

            segs = this.renderFgSegsIntoContainers(segs, this.helperContainerEls);

            // Try to make the segment that is in the same row as sourceSeg look the same
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                if (sourceSeg && sourceSeg.col === seg.col) {
                    sourceEl = sourceSeg.el;
                    seg.el.css({
                        left: sourceEl.css('left'),
                        right: sourceEl.css('right'),
                        'margin-left': sourceEl.css('margin-left'),
                        'margin-right': sourceEl.css('margin-right')
                    });
                }
                helperEls.push(seg.el[0]);
            }

            this.helperSegs = segs;

            return $(helperEls); // must return rendered helpers
        },


        unrenderHelperSegs: function() {
            this.unrenderNamedSegs('helperSegs');
        },


        /* Background Events
         ------------------------------------------------------------------------------------------------------------------*/


        renderBgSegs: function(segs) {
            segs = this.renderFillSegEls('bgEvent', segs); // TODO: old fill system
            this.updateSegVerticals(segs);
            this.attachSegsByCol(this.groupSegsByCol(segs), this.bgContainerEls);
            this.bgSegs = segs;
            return segs; // needed for Grid::renderEvents
        },


        unrenderBgSegs: function() {
            this.unrenderNamedSegs('bgSegs');
        },


        /* Highlight
         ------------------------------------------------------------------------------------------------------------------*/


        renderHighlightSegs: function(segs) {
            segs = this.renderFillSegEls('highlight', segs); // TODO: old fill system
            this.updateSegVerticals(segs);
            this.attachSegsByCol(this.groupSegsByCol(segs), this.highlightContainerEls);
            this.highlightSegs = segs;
        },


        unrenderHighlightSegs: function() {
            this.unrenderNamedSegs('highlightSegs');
        },


        /* Business Hours
         ------------------------------------------------------------------------------------------------------------------*/


        renderBusinessSegs: function(segs) {
            segs = this.renderFillSegEls('businessHours', segs); // TODO: old fill system
            this.updateSegVerticals(segs);
            this.attachSegsByCol(this.groupSegsByCol(segs), this.businessContainerEls);
            this.businessSegs = segs;
        },


        unrenderBusinessSegs: function() {
            this.unrenderNamedSegs('businessSegs');
        },


        /* Seg Rendering Utils
         ------------------------------------------------------------------------------------------------------------------*/


        // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
        groupSegsByCol: function(segs) {
            var segsByCol = [];
            var i;

            for (i = 0; i < this.colCnt; i++) {
                segsByCol.push([]);
            }

            for (i = 0; i < segs.length; i++) {
                segsByCol[segs[i].col].push(segs[i]);
            }

            return segsByCol;
        },


        // Given segments grouped by column, insert the segments' elements into a parallel array of container
        // elements, each living within a column.
        attachSegsByCol: function(segsByCol, containerEls) {
            var col;
            var segs;
            var i;

            for (col = 0; col < this.colCnt; col++) { // iterate each column grouping
                segs = segsByCol[col];

                for (i = 0; i < segs.length; i++) {
                    containerEls.eq(col).append(segs[i].el);
                }
            }
        },


        // Given the name of a property of `this` object, assumed to be an array of segments,
        // loops through each segment and removes from DOM. Will null-out the property afterwards.
        unrenderNamedSegs: function(propName) {
            var segs = this[propName];
            var i;

            if (segs) {
                for (i = 0; i < segs.length; i++) {
                    segs[i].el.remove();
                }
                this[propName] = null;
            }
        },



        /* Foreground Event Rendering Utils
         ------------------------------------------------------------------------------------------------------------------*/


        // Given an array of foreground segments, render a DOM element for each, computes position,
        // and attaches to the column inner-container elements.
        renderFgSegsIntoContainers: function(segs, containerEls) {
            var segsByCol;
            var col;

            segs = this.renderFgSegEls(segs); // will call fgSegHtml
            segsByCol = this.groupSegsByCol(segs);

            for (col = 0; col < this.colCnt; col++) {
                this.updateFgSegCoords(segsByCol[col]);
            }

            this.attachSegsByCol(segsByCol, containerEls);

            return segs;
        },


        // Renders the HTML for a single event segment's default rendering
        fgSegHtml: function(seg, disableResizing) {
            var view = this.view;
            var event = seg.event;
            var isDraggable = view.isEventDraggable(event);
            var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);
            var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);
            var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
            var skinCss = cssToStr(this.getSegSkinCss(seg));
            var timeText;
            var fullTimeText; // more verbose time text. for the print stylesheet
            var startTimeText; // just the start time text

            classes.unshift('fc-time-grid-event', 'fc-v-event');

            if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...
                // Don't display time text on segments that run entirely through a day.
                // That would appear as midnight-midnight and would look dumb.
                // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
                if (seg.isStart || seg.isEnd) {
                    timeText = this.getEventTimeText(seg);
                    fullTimeText = this.getEventTimeText(seg, 'LT');
                    startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false
                }
            } else {
                // Display the normal time text for the *event's* times
                timeText = this.getEventTimeText(event);
                fullTimeText = this.getEventTimeText(event, 'LT');
                startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false
            }

            return '<a class="' + classes.join(' ') + '"' +
                (event.url ?
                        ' href="' + htmlEscape(event.url) + '"' :
                        ''
                ) +
                (skinCss ?
                        ' style="' + skinCss + '"' :
                        ''
                ) +
                '>' +
                '<div class="fc-content">' +
                (timeText ?
                        '<div class="fc-time"' +
                        ' data-start="' + htmlEscape(startTimeText) + '"' +
                        ' data-full="' + htmlEscape(fullTimeText) + '"' +
                        '>' +
                        '<span>' + htmlEscape(timeText) + '</span>' +
                        '</div>' :
                        ''
                ) +
                (event.title ?
                        '<div class="fc-title">' +
                        htmlEscape(event.title) +
                        '</div>' :
                        ''
                ) +
                '</div>' +
                '<div class="fc-bg"/>' +
                /* TODO: write CSS for this
                 (isResizableFromStart ?
                 '<div class="fc-resizer fc-start-resizer" />' :
                 ''
                 ) +
                 */
                (isResizableFromEnd ?
                        '<div class="fc-resizer fc-end-resizer" />' :
                        ''
                ) +
                '</a>';
        },


        /* Seg Position Utils
         ------------------------------------------------------------------------------------------------------------------*/


        // Refreshes the CSS top/bottom coordinates for each segment element.
        // Works when called after initial render, after a window resize/zoom for example.
        updateSegVerticals: function(segs) {
            this.computeSegVerticals(segs);
            this.assignSegVerticals(segs);
        },


        // For each segment in an array, computes and assigns its top and bottom properties
        computeSegVerticals: function(segs) {
            var i, seg;
            var dayDate;

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                dayDate = this.dayDates[seg.dayIndex];

                seg.top = this.computeDateTop(seg.start, dayDate);
                seg.bottom = this.computeDateTop(seg.end, dayDate);
            }
        },


        // Given segments that already have their top/bottom properties computed, applies those values to
        // the segments' elements.
        assignSegVerticals: function(segs) {
            var i, seg;

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                seg.el.css(this.generateSegVerticalCss(seg));
            }
        },


        // Generates an object with CSS properties for the top/bottom coordinates of a segment element
        generateSegVerticalCss: function(seg) {
            return {
                top: seg.top,
                bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
            };
        },


        /* Foreground Event Positioning Utils
         ------------------------------------------------------------------------------------------------------------------*/


        // Given segments that are assumed to all live in the *same column*,
        // compute their verical/horizontal coordinates and assign to their elements.
        updateFgSegCoords: function(segs) {
            this.computeSegVerticals(segs); // horizontals relies on this
            this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array
            this.assignSegVerticals(segs);
            this.assignFgSegHorizontals(segs);
        },


        // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
        // NOTE: Also reorders the given array by date!
        computeFgSegHorizontals: function(segs) {
            var levels;
            var level0;
            var i;

            this.sortEventSegs(segs); // order by certain criteria
            levels = buildSlotSegLevels(segs);
            computeForwardSlotSegs(levels);

            if ((level0 = levels[0])) {

                for (i = 0; i < level0.length; i++) {
                    computeSlotSegPressures(level0[i]);
                }

                for (i = 0; i < level0.length; i++) {
                    this.computeFgSegForwardBack(level0[i], 0, 0);
                }
            }
        },


        // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
        // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
        // seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
        //
        // The segment might be part of a "series", which means consecutive segments with the same pressure
        // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
        // segments behind this one in the current series, and `seriesBackwardCoord` is the starting
        // coordinate of the first segment in the series.
        computeFgSegForwardBack: function(seg, seriesBackwardPressure, seriesBackwardCoord) {
            var forwardSegs = seg.forwardSegs;
            var i;

            if (seg.forwardCoord === undefined) { // not already computed

                if (!forwardSegs.length) {

                    // if there are no forward segments, this segment should butt up against the edge
                    seg.forwardCoord = 1;
                }
                else {

                    // sort highest pressure first
                    this.sortForwardSegs(forwardSegs);

                    // this segment's forwardCoord will be calculated from the backwardCoord of the
                    // highest-pressure forward segment.
                    this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
                    seg.forwardCoord = forwardSegs[0].backwardCoord;
                }

                // calculate the backwardCoord from the forwardCoord. consider the series
                seg.backwardCoord = seg.forwardCoord -
                    (seg.forwardCoord - seriesBackwardCoord) / // available width for series
                    (seriesBackwardPressure + 1); // # of segments in the series

                // use this segment's coordinates to computed the coordinates of the less-pressurized
                // forward segments
                for (i=0; i<forwardSegs.length; i++) {
                    this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
                }
            }
        },


        sortForwardSegs: function(forwardSegs) {
            forwardSegs.sort(proxy(this, 'compareForwardSegs'));
        },


        // A cmp function for determining which forward segment to rely on more when computing coordinates.
        compareForwardSegs: function(seg1, seg2) {
            // put higher-pressure first
            return seg2.forwardPressure - seg1.forwardPressure ||
                // put segments that are closer to initial edge first (and favor ones with no coords yet)
                (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
                // do normal sorting...
                this.compareEventSegs(seg1, seg2);
        },


        // Given foreground event segments that have already had their position coordinates computed,
        // assigns position-related CSS values to their elements.
        assignFgSegHorizontals: function(segs) {
            var i, seg;

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                seg.el.css(this.generateFgSegHorizontalCss(seg));

                // if the height is short, add a className for alternate styling
                if (seg.bottom - seg.top < 30) {
                    seg.el.addClass('fc-short');
                }
            }
        },


        // Generates an object with CSS properties/values that should be applied to an event segment element.
        // Contains important positioning-related properties that should be applied to any event element, customized or not.
        generateFgSegHorizontalCss: function(seg) {
            var shouldOverlap = this.view.opt('slotEventOverlap');
            var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
            var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
            var props = this.generateSegVerticalCss(seg); // get top/bottom first
            var left; // amount of space from left edge, a fraction of the total width
            var right; // amount of space from right edge, a fraction of the total width

            if (shouldOverlap) {
                // double the width, but don't go beyond the maximum forward coordinate (1.0)
                forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
            }

            if (this.isRTL) {
                left = 1 - forwardCoord;
                right = backwardCoord;
            }
            else {
                left = backwardCoord;
                right = 1 - forwardCoord;
            }

            props.zIndex = seg.level + 1; // convert from 0-base to 1-based
            props.left = left * 100 + '%';
            props.right = right * 100 + '%';

            if (shouldOverlap && seg.forwardPressure) {
                // add padding to the edge so that forward stacked events don't cover the resizer's icon
                props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
            }

            return props;
        }

    });


// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
    function buildSlotSegLevels(segs) {
        var levels = [];
        var i, seg;
        var j;

        for (i=0; i<segs.length; i++) {
            seg = segs[i];

            // go through all the levels and stop on the first level where there are no collisions
            for (j=0; j<levels.length; j++) {
                if (!computeSlotSegCollisions(seg, levels[j]).length) {
                    break;
                }
            }

            seg.level = j;

            (levels[j] || (levels[j] = [])).push(seg);
        }

        return levels;
    }


// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
    function computeForwardSlotSegs(levels) {
        var i, level;
        var j, seg;
        var k;

        for (i=0; i<levels.length; i++) {
            level = levels[i];

            for (j=0; j<level.length; j++) {
                seg = level[j];

                seg.forwardSegs = [];
                for (k=i+1; k<levels.length; k++) {
                    computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
                }
            }
        }
    }


// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
    function computeSlotSegPressures(seg) {
        var forwardSegs = seg.forwardSegs;
        var forwardPressure = 0;
        var i, forwardSeg;

        if (seg.forwardPressure === undefined) { // not already computed

            for (i=0; i<forwardSegs.length; i++) {
                forwardSeg = forwardSegs[i];

                // figure out the child's maximum forward path
                computeSlotSegPressures(forwardSeg);

                // either use the existing maximum, or use the child's forward pressure
                // plus one (for the forwardSeg itself)
                forwardPressure = Math.max(
                    forwardPressure,
                    1 + forwardSeg.forwardPressure
                );
            }

            seg.forwardPressure = forwardPressure;
        }
    }


// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
    function computeSlotSegCollisions(seg, otherSegs, results) {
        results = results || [];

        for (var i=0; i<otherSegs.length; i++) {
            if (isSlotSegCollision(seg, otherSegs[i])) {
                results.push(otherSegs[i]);
            }
        }

        return results;
    }


// Do these segments occupy the same vertical space?
    function isSlotSegCollision(seg1, seg2) {
        return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
    }

    ;;

    /* An abstract class from which other views inherit from
     ----------------------------------------------------------------------------------------------------------------------*/

    var View = FC.View = Model.extend({

        type: null, // subclass' view name (string)
        name: null, // deprecated. use `type` instead
        title: null, // the text that will be displayed in the header's title

        calendar: null, // owner Calendar object
        viewSpec: null,
        options: null, // hash containing all options. already merged with view-specific-options
        el: null, // the view's containing element. set by Calendar

        renderQueue: null,
        batchRenderDepth: 0,
        isDatesRendered: false,
        isEventsRendered: false,
        isBaseRendered: false, // related to viewRender/viewDestroy triggers

        queuedScroll: null,

        isRTL: false,
        isSelected: false, // boolean whether a range of time is user-selected or not
        selectedEvent: null,

        eventOrderSpecs: null, // criteria for ordering events when they have same date/time

        // classNames styled by jqui themes
        widgetHeaderClass: null,
        widgetContentClass: null,
        highlightStateClass: null,

        // for date utils, computed from options
        nextDayThreshold: null,
        isHiddenDayHash: null,

        // now indicator
        isNowIndicatorRendered: null,
        initialNowDate: null, // result first getNow call
        initialNowQueriedMs: null, // ms time the getNow was called
        nowIndicatorTimeoutID: null, // for refresh timing of now indicator
        nowIndicatorIntervalID: null, // "


        constructor: function(calendar, viewSpec) {
            Model.prototype.constructor.call(this);

            this.calendar = calendar;
            this.viewSpec = viewSpec;

            // shortcuts
            this.type = viewSpec.type;
            this.options = viewSpec.options;

            // .name is deprecated
            this.name = this.type;

            this.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));
            this.initThemingProps();
            this.initHiddenDays();
            this.isRTL = this.opt('isRTL');

            this.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));

            this.renderQueue = this.buildRenderQueue();
            this.initAutoBatchRender();

            this.initialize();
        },


        buildRenderQueue: function() {
            var _this = this;
            var renderQueue = new RenderQueue({
                event: this.opt('eventRenderWait')
            });

            renderQueue.on('start', function() {
                _this.freezeHeight();
                _this.addScroll(_this.queryScroll());
            });

            renderQueue.on('stop', function() {
                _this.thawHeight();
                _this.popScroll();
            });

            return renderQueue;
        },


        initAutoBatchRender: function() {
            var _this = this;

            this.on('before:change', function() {
                _this.startBatchRender();
            });

            this.on('change', function() {
                _this.stopBatchRender();
            });
        },


        startBatchRender: function() {
            if (!(this.batchRenderDepth++)) {
                this.renderQueue.pause();
            }
        },


        stopBatchRender: function() {
            if (!(--this.batchRenderDepth)) {
                this.renderQueue.resume();
            }
        },


        // A good place for subclasses to initialize member variables
        initialize: function() {
            // subclasses can implement
        },


        // Retrieves an option with the given name
        opt: function(name) {
            return this.options[name];
        },


        // Triggers handlers that are view-related. Modifies args before passing to calendar.
        publiclyTrigger: function(name, thisObj) { // arguments beyond thisObj are passed along
            var calendar = this.calendar;

            return calendar.publiclyTrigger.apply(
                calendar,
                [name, thisObj || this].concat(
                    Array.prototype.slice.call(arguments, 2), // arguments beyond thisObj
                    [ this ] // always make the last argument a reference to the view. TODO: deprecate
                )
            );
        },


        /* Title and Date Formatting
         ------------------------------------------------------------------------------------------------------------------*/


        // Sets the view's title property to the most updated computed value
        updateTitle: function() {
            this.title = this.computeTitle();
            this.calendar.setToolbarsTitle(this.title);
        },


        // Computes what the title at the top of the calendar should be for this view
        computeTitle: function() {
            var range;

            // for views that span a large unit of time, show the proper interval, ignoring stray days before and after
            if (/^(year|month)$/.test(this.currentRangeUnit)) {
                range = this.currentRange;
            }
            else { // for day units or smaller, use the actual day range
                range = this.activeRange;
            }

            return this.formatRange(
                {
                    // in case currentRange has a time, make sure timezone is correct
                    start: this.calendar.applyTimezone(range.start),
                    end: this.calendar.applyTimezone(range.end)
                },
                this.opt('titleFormat') || this.computeTitleFormat(),
                this.opt('titleRangeSeparator')
            );
        },


        // Generates the format string that should be used to generate the title for the current date range.
        // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
        computeTitleFormat: function() {
            if (this.currentRangeUnit == 'year') {
                return 'YYYY';
            }
            else if (this.currentRangeUnit == 'month') {
                return this.opt('monthYearFormat'); // like "September 2014"
            }
            else if (this.currentRangeAs('days') > 1) {
                return 'll'; // multi-day range. shorter, like "Sep 9 - 10 2014"
            }
            else {
                return 'LL'; // one day. longer, like "September 9 2014"
            }
        },


        // Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
        // Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
        // The timezones of the dates within `range` will be respected.
        formatRange: function(range, formatStr, separator) {
            var end = range.end;

            if (!end.hasTime()) { // all-day?
                end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
            }

            return formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));
        },


        getAllDayHtml: function() {
            return this.opt('allDayHtml') || htmlEscape(this.opt('allDayText'));
        },


        /* Navigation
         ------------------------------------------------------------------------------------------------------------------*/


        // Generates HTML for an anchor to another view into the calendar.
        // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
        // `gotoOptions` can either be a moment input, or an object with the form:
        // { date, type, forceOff }
        // `type` is a view-type like "day" or "week". default value is "day".
        // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.
        buildGotoAnchorHtml: function(gotoOptions, attrs, innerHtml) {
            var date, type, forceOff;
            var finalOptions;

            if ($.isPlainObject(gotoOptions)) {
                date = gotoOptions.date;
                type = gotoOptions.type;
                forceOff = gotoOptions.forceOff;
            }
            else {
                date = gotoOptions; // a single moment input
            }
            date = FC.moment(date); // if a string, parse it

            finalOptions = { // for serialization into the link
                date: date.format('YYYY-MM-DD'),
                type: type || 'day'
            };

            if (typeof attrs === 'string') {
                innerHtml = attrs;
                attrs = null;
            }

            attrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space
            innerHtml = innerHtml || '';

            if (!forceOff && this.opt('navLinks')) {
                return '<a' + attrs +
                    ' data-goto="' + htmlEscape(JSON.stringify(finalOptions)) + '">' +
                    innerHtml +
                    '</a>';
            }
            else {
                return '<span' + attrs + '>' +
                    innerHtml +
                    '</span>';
            }
        },


        // Rendering Non-date-related Content
        // -----------------------------------------------------------------------------------------------------------------


        // Sets the container element that the view should render inside of, does global DOM-related initializations,
        // and renders all the non-date-related content inside.
        setElement: function(el) {
            this.el = el;
            this.bindGlobalHandlers();
            this.bindBaseRenderHandlers();
            this.renderSkeleton();
        },


        // Removes the view's container element from the DOM, clearing any content beforehand.
        // Undoes any other DOM-related attachments.
        removeElement: function() {
            this.unsetDate();
            this.unrenderSkeleton();

            this.unbindGlobalHandlers();
            this.unbindBaseRenderHandlers();

            this.el.remove();
            // NOTE: don't null-out this.el in case the View was destroyed within an API callback.
            // We don't null-out the View's other jQuery element references upon destroy,
            //  so we shouldn't kill this.el either.
        },


        // Renders the basic structure of the view before any content is rendered
        renderSkeleton: function() {
            // subclasses should implement
        },


        // Unrenders the basic structure of the view
        unrenderSkeleton: function() {
            // subclasses should implement
        },


        // Date Setting/Unsetting
        // -----------------------------------------------------------------------------------------------------------------


        setDate: function(date) {
            var currentDateProfile = this.get('dateProfile');
            var newDateProfile = this.buildDateProfile(date, null, true); // forceToValid=true

            if (
                !currentDateProfile ||
                !isRangesEqual(currentDateProfile.activeRange, newDateProfile.activeRange)
            ) {
                this.set('dateProfile', newDateProfile);
            }

            return newDateProfile.date;
        },


        unsetDate: function() {
            this.unset('dateProfile');
        },


        // Date Rendering
        // -----------------------------------------------------------------------------------------------------------------


        requestDateRender: function(dateProfile) {
            var _this = this;

            this.renderQueue.queue(function() {
                _this.executeDateRender(dateProfile);
            }, 'date', 'init');
        },


        requestDateUnrender: function() {
            var _this = this;

            this.renderQueue.queue(function() {
                _this.executeDateUnrender();
            }, 'date', 'destroy');
        },


        // Event Data
        // -----------------------------------------------------------------------------------------------------------------


        fetchInitialEvents: function(dateProfile) {
            return this.calendar.requestEvents(
                dateProfile.activeRange.start,
                dateProfile.activeRange.end
            );
        },


        bindEventChanges: function() {
            this.listenTo(this.calendar, 'eventsReset', this.resetEvents);
        },


        unbindEventChanges: function() {
            this.stopListeningTo(this.calendar, 'eventsReset');
        },


        setEvents: function(events) {
            this.set('currentEvents', events);
            this.set('hasEvents', true);
        },


        unsetEvents: function() {
            this.unset('currentEvents');
            this.unset('hasEvents');
        },


        resetEvents: function(events) {
            this.startBatchRender();
            this.unsetEvents();
            this.setEvents(events);
            this.stopBatchRender();
        },


        // Event Rendering
        // -----------------------------------------------------------------------------------------------------------------


        requestEventsRender: function(events) {
            var _this = this;

            this.renderQueue.queue(function() {
                _this.executeEventsRender(events);
            }, 'event', 'init');
        },


        requestEventsUnrender: function() {
            var _this = this;

            this.renderQueue.queue(function() {
                _this.executeEventsUnrender();
            }, 'event', 'destroy');
        },


        // Date High-level Rendering
        // -----------------------------------------------------------------------------------------------------------------


        // if dateProfile not specified, uses current
        executeDateRender: function(dateProfile, skipScroll) {

            this.setDateProfileForRendering(dateProfile);
            this.updateTitle();
            this.calendar.updateToolbarButtons();

            if (this.render) {
                this.render(); // TODO: deprecate
            }

            this.renderDates();
            this.updateSize();
            this.renderBusinessHours(); // might need coordinates, so should go after updateSize()
            this.startNowIndicator();

            if (!skipScroll) {
                this.addScroll(this.computeInitialDateScroll());
            }

            this.isDatesRendered = true;
            this.trigger('datesRendered');
        },


        executeDateUnrender: function() {

            this.unselect();
            this.stopNowIndicator();

            this.trigger('before:datesUnrendered');

            this.unrenderBusinessHours();
            this.unrenderDates();

            if (this.destroy) {
                this.destroy(); // TODO: deprecate
            }

            this.isDatesRendered = false;
        },


        // Date Low-level Rendering
        // -----------------------------------------------------------------------------------------------------------------


        // date-cell content only
        renderDates: function() {
            // subclasses should implement
        },


        // date-cell content only
        unrenderDates: function() {
            // subclasses should override
        },


        // Determing when the "meat" of the view is rendered (aka the base)
        // -----------------------------------------------------------------------------------------------------------------


        bindBaseRenderHandlers: function() {
            var _this = this;

            this.on('datesRendered.baseHandler', function() {
                _this.onBaseRender();
            });

            this.on('before:datesUnrendered.baseHandler', function() {
                _this.onBeforeBaseUnrender();
            });
        },


        unbindBaseRenderHandlers: function() {
            this.off('.baseHandler');
        },


        onBaseRender: function() {
            this.applyScreenState();
            this.publiclyTrigger('viewRender', this, this, this.el);
        },


        onBeforeBaseUnrender: function() {
            this.applyScreenState();
            this.publiclyTrigger('viewDestroy', this, this, this.el);
        },


        // Misc view rendering utils
        // -----------------------------------------------------------------------------------------------------------------


        // Binds DOM handlers to elements that reside outside the view container, such as the document
        bindGlobalHandlers: function() {
            this.listenTo(GlobalEmitter.get(), {
                touchstart: this.processUnselect,
                mousedown: this.handleDocumentMousedown
            });
        },


        // Unbinds DOM handlers from elements that reside outside the view container
        unbindGlobalHandlers: function() {
            this.stopListeningTo(GlobalEmitter.get());
        },


        // Initializes internal variables related to theming
        initThemingProps: function() {
            var tm = this.opt('theme') ? 'ui' : 'fc';

            this.widgetHeaderClass = tm + '-widget-header';
            this.widgetContentClass = tm + '-widget-content';
            this.highlightStateClass = tm + '-state-highlight';
        },


        /* Business Hours
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders business-hours onto the view. Assumes updateSize has already been called.
        renderBusinessHours: function() {
            // subclasses should implement
        },


        // Unrenders previously-rendered business-hours
        unrenderBusinessHours: function() {
            // subclasses should implement
        },


        /* Now Indicator
         ------------------------------------------------------------------------------------------------------------------*/


        // Immediately render the current time indicator and begins re-rendering it at an interval,
        // which is defined by this.getNowIndicatorUnit().
        // TODO: somehow do this for the current whole day's background too
        startNowIndicator: function() {
            var _this = this;
            var unit;
            var update;
            var delay; // ms wait value

            if (this.opt('nowIndicator')) {
                unit = this.getNowIndicatorUnit();
                if (unit) {
                    update = proxy(this, 'updateNowIndicator'); // bind to `this`

                    this.initialNowDate = this.calendar.getNow();
                    this.initialNowQueriedMs = +new Date();
                    this.renderNowIndicator(this.initialNowDate);
                    this.isNowIndicatorRendered = true;

                    // wait until the beginning of the next interval
                    delay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;
                    this.nowIndicatorTimeoutID = setTimeout(function() {
                        _this.nowIndicatorTimeoutID = null;
                        update();
                        delay = +moment.duration(1, unit);
                        delay = Math.max(100, delay); // prevent too frequent
                        _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
                    }, delay);
                }
            }
        },


        // rerenders the now indicator, computing the new current time from the amount of time that has passed
        // since the initial getNow call.
        updateNowIndicator: function() {
            if (this.isNowIndicatorRendered) {
                this.unrenderNowIndicator();
                this.renderNowIndicator(
                    this.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs) // add ms
                );
            }
        },


        // Immediately unrenders the view's current time indicator and stops any re-rendering timers.
        // Won't cause side effects if indicator isn't rendered.
        stopNowIndicator: function() {
            if (this.isNowIndicatorRendered) {

                if (this.nowIndicatorTimeoutID) {
                    clearTimeout(this.nowIndicatorTimeoutID);
                    this.nowIndicatorTimeoutID = null;
                }
                if (this.nowIndicatorIntervalID) {
                    clearTimeout(this.nowIndicatorIntervalID);
                    this.nowIndicatorIntervalID = null;
                }

                this.unrenderNowIndicator();
                this.isNowIndicatorRendered = false;
            }
        },


        // Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator
        // should be refreshed. If something falsy is returned, no time indicator is rendered at all.
        getNowIndicatorUnit: function() {
            // subclasses should implement
        },


        // Renders a current time indicator at the given datetime
        renderNowIndicator: function(date) {
            // subclasses should implement
        },


        // Undoes the rendering actions from renderNowIndicator
        unrenderNowIndicator: function() {
            // subclasses should implement
        },


        /* Dimensions
         ------------------------------------------------------------------------------------------------------------------*/


        // Refreshes anything dependant upon sizing of the container element of the grid
        updateSize: function(isResize) {
            var scroll;

            if (isResize) {
                scroll = this.queryScroll();
            }

            this.updateHeight(isResize);
            this.updateWidth(isResize);
            this.updateNowIndicator();

            if (isResize) {
                this.applyScroll(scroll);
            }
        },


        // Refreshes the horizontal dimensions of the calendar
        updateWidth: function(isResize) {
            // subclasses should implement
        },


        // Refreshes the vertical dimensions of the calendar
        updateHeight: function(isResize) {
            var calendar = this.calendar; // we poll the calendar for height information

            this.setHeight(
                calendar.getSuggestedViewHeight(),
                calendar.isHeightAuto()
            );
        },


        // Updates the vertical dimensions of the calendar to the specified height.
        // if `isAuto` is set to true, height becomes merely a suggestion and the view should use its "natural" height.
        setHeight: function(height, isAuto) {
            // subclasses should implement
        },


        /* Scroller
         ------------------------------------------------------------------------------------------------------------------*/


        addForcedScroll: function(scroll) {
            this.addScroll(
                $.extend(scroll, { isForced: true })
            );
        },


        addScroll: function(scroll) {
            var queuedScroll = this.queuedScroll || (this.queuedScroll = {});

            if (!queuedScroll.isForced) {
                $.extend(queuedScroll, scroll);
            }
        },


        popScroll: function() {
            this.applyQueuedScroll();
            this.queuedScroll = null;
        },


        applyQueuedScroll: function() {
            if (this.queuedScroll) {
                this.applyScroll(this.queuedScroll);
            }
        },


        queryScroll: function() {
            var scroll = {};

            if (this.isDatesRendered) {
                $.extend(scroll, this.queryDateScroll());
            }

            return scroll;
        },


        applyScroll: function(scroll) {
            if (this.isDatesRendered) {
                this.applyDateScroll(scroll);
            }
        },


        computeInitialDateScroll: function() {
            return {}; // subclasses must implement
        },


        queryDateScroll: function() {
            return {}; // subclasses must implement
        },


        applyDateScroll: function(scroll) {
            ; // subclasses must implement
        },


        /* Height Freezing
         ------------------------------------------------------------------------------------------------------------------*/


        freezeHeight: function() {
            this.calendar.freezeContentHeight();
        },


        thawHeight: function() {
            this.calendar.thawContentHeight();
        },


        // Event High-level Rendering
        // -----------------------------------------------------------------------------------------------------------------


        executeEventsRender: function(events) {
            this.renderEvents(events);
            this.isEventsRendered = true;

            this.onEventsRender();
        },


        executeEventsUnrender: function() {
            this.onBeforeEventsUnrender();

            if (this.destroyEvents) {
                this.destroyEvents(); // TODO: deprecate
            }

            this.unrenderEvents();
            this.isEventsRendered = false;
        },


        // Event Rendering Triggers
        // -----------------------------------------------------------------------------------------------------------------


        // Signals that all events have been rendered
        onEventsRender: function() {
            this.applyScreenState();

            this.renderedEventSegEach(function(seg) {
                this.publiclyTrigger('eventAfterRender', seg.event, seg.event, seg.el);
            });
            this.publiclyTrigger('eventAfterAllRender');
        },


        // Signals that all event elements are about to be removed
        onBeforeEventsUnrender: function() {
            this.applyScreenState();

            this.renderedEventSegEach(function(seg) {
                this.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);
            });
        },


        applyScreenState: function() {
            this.thawHeight();
            this.freezeHeight();
            this.applyQueuedScroll();
        },


        // Event Low-level Rendering
        // -----------------------------------------------------------------------------------------------------------------


        // Renders the events onto the view.
        renderEvents: function(events) {
            // subclasses should implement
        },


        // Removes event elements from the view.
        unrenderEvents: function() {
            // subclasses should implement
        },


        // Event Rendering Utils
        // -----------------------------------------------------------------------------------------------------------------


        // Given an event and the default element used for rendering, returns the element that should actually be used.
        // Basically runs events and elements through the eventRender hook.
        resolveEventEl: function(event, el) {
            var custom = this.publiclyTrigger('eventRender', event, event, el);

            if (custom === false) { // means don't render at all
                el = null;
            }
            else if (custom && custom !== true) {
                el = $(custom);
            }

            return el;
        },


        // Hides all rendered event segments linked to the given event
        showEvent: function(event) {
            this.renderedEventSegEach(function(seg) {
                seg.el.css('visibility', '');
            }, event);
        },


        // Shows all rendered event segments linked to the given event
        hideEvent: function(event) {
            this.renderedEventSegEach(function(seg) {
                seg.el.css('visibility', 'hidden');
            }, event);
        },


        // Iterates through event segments that have been rendered (have an el). Goes through all by default.
        // If the optional `event` argument is specified, only iterates through segments linked to that event.
        // The `this` value of the callback function will be the view.
        renderedEventSegEach: function(func, event) {
            var segs = this.getEventSegs();
            var i;

            for (i = 0; i < segs.length; i++) {
                if (!event || segs[i].event._id === event._id) {
                    if (segs[i].el) {
                        func.call(this, segs[i]);
                    }
                }
            }
        },


        // Retrieves all the rendered segment objects for the view
        getEventSegs: function() {
            // subclasses must implement
            return [];
        },


        /* Event Drag-n-Drop
         ------------------------------------------------------------------------------------------------------------------*/


        // Computes if the given event is allowed to be dragged by the user
        isEventDraggable: function(event) {
            return this.isEventStartEditable(event);
        },


        isEventStartEditable: function(event) {
            return firstDefined(
                event.startEditable,
                (event.source || {}).startEditable,
                this.opt('eventStartEditable'),
                this.isEventGenerallyEditable(event)
            );
        },


        isEventGenerallyEditable: function(event) {
            return firstDefined(
                event.editable,
                (event.source || {}).editable,
                this.opt('editable')
            );
        },


        // Must be called when an event in the view is dropped onto new location.
        // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
        reportSegDrop: function(seg, dropLocation, largeUnit, el, ev) {
            var calendar = this.calendar;
            var mutateResult = calendar.mutateSeg(seg, dropLocation, largeUnit);
            var undoFunc = function() {
                mutateResult.undo();
                calendar.reportEventChange();
            };

            this.triggerEventDrop(seg.event, mutateResult.dateDelta, undoFunc, el, ev);
            calendar.reportEventChange(); // will rerender events
        },


        // Triggers event-drop handlers that have subscribed via the API
        triggerEventDrop: function(event, dateDelta, undoFunc, el, ev) {
            this.publiclyTrigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy
        },


        /* External Element Drag-n-Drop
         ------------------------------------------------------------------------------------------------------------------*/


        // Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
        // `meta` is the parsed data that has been embedded into the dragging event.
        // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
        reportExternalDrop: function(meta, dropLocation, el, ev, ui) {
            var eventProps = meta.eventProps;
            var eventInput;
            var event;

            // Try to build an event object and render it. TODO: decouple the two
            if (eventProps) {
                eventInput = $.extend({}, eventProps, dropLocation);
                event = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array
            }

            this.triggerExternalDrop(event, dropLocation, el, ev, ui);
        },


        // Triggers external-drop handlers that have subscribed via the API
        triggerExternalDrop: function(event, dropLocation, el, ev, ui) {

            // trigger 'drop' regardless of whether element represents an event
            this.publiclyTrigger('drop', el[0], dropLocation.start, ev, ui);

            if (event) {
                this.publiclyTrigger('eventReceive', null, event); // signal an external event landed
            }
        },


        /* Drag-n-Drop Rendering (for both events and external elements)
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of a event or external-element drag over the given drop zone.
        // If an external-element, seg will be `null`.
        // Must return elements used for any mock events.
        renderDrag: function(dropLocation, seg) {
            // subclasses must implement
        },


        // Unrenders a visual indication of an event or external-element being dragged.
        unrenderDrag: function() {
            // subclasses must implement
        },


        /* Event Resizing
         ------------------------------------------------------------------------------------------------------------------*/


        // Computes if the given event is allowed to be resized from its starting edge
        isEventResizableFromStart: function(event) {
            return this.opt('eventResizableFromStart') && this.isEventResizable(event);
        },


        // Computes if the given event is allowed to be resized from its ending edge
        isEventResizableFromEnd: function(event) {
            return this.isEventResizable(event);
        },


        // Computes if the given event is allowed to be resized by the user at all
        isEventResizable: function(event) {
            var source = event.source || {};

            return firstDefined(
                event.durationEditable,
                source.durationEditable,
                this.opt('eventDurationEditable'),
                event.editable,
                source.editable,
                this.opt('editable')
            );
        },


        // Must be called when an event in the view has been resized to a new length
        reportSegResize: function(seg, resizeLocation, largeUnit, el, ev) {
            var calendar = this.calendar;
            var mutateResult = calendar.mutateSeg(seg, resizeLocation, largeUnit);
            var undoFunc = function() {
                mutateResult.undo();
                calendar.reportEventChange();
            };

            this.triggerEventResize(seg.event, mutateResult.durationDelta, undoFunc, el, ev);
            calendar.reportEventChange(); // will rerender events
        },


        // Triggers event-resize handlers that have subscribed via the API
        triggerEventResize: function(event, durationDelta, undoFunc, el, ev) {
            this.publiclyTrigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy
        },


        /* Selection (time range)
         ------------------------------------------------------------------------------------------------------------------*/


        // Selects a date span on the view. `start` and `end` are both Moments.
        // `ev` is the native mouse event that begin the interaction.
        select: function(span, ev) {
            this.unselect(ev);
            this.renderSelection(span);
            this.reportSelection(span, ev);
        },


        // Renders a visual indication of the selection
        renderSelection: function(span) {
            // subclasses should implement
        },


        // Called when a new selection is made. Updates internal state and triggers handlers.
        reportSelection: function(span, ev) {
            this.isSelected = true;
            this.triggerSelect(span, ev);
        },


        // Triggers handlers to 'select'
        triggerSelect: function(span, ev) {
            this.publiclyTrigger(
                'select',
                null,
                this.calendar.applyTimezone(span.start), // convert to calendar's tz for external API
                this.calendar.applyTimezone(span.end), // "
                ev
            );
        },


        // Undoes a selection. updates in the internal state and triggers handlers.
        // `ev` is the native mouse event that began the interaction.
        unselect: function(ev) {
            if (this.isSelected) {
                this.isSelected = false;
                if (this.destroySelection) {
                    this.destroySelection(); // TODO: deprecate
                }
                this.unrenderSelection();
                this.publiclyTrigger('unselect', null, ev);
            }
        },


        // Unrenders a visual indication of selection
        unrenderSelection: function() {
            // subclasses should implement
        },


        /* Event Selection
         ------------------------------------------------------------------------------------------------------------------*/


        selectEvent: function(event) {
            if (!this.selectedEvent || this.selectedEvent !== event) {
                this.unselectEvent();
                this.renderedEventSegEach(function(seg) {
                    seg.el.addClass('fc-selected');
                }, event);
                this.selectedEvent = event;
            }
        },


        unselectEvent: function() {
            if (this.selectedEvent) {
                this.renderedEventSegEach(function(seg) {
                    seg.el.removeClass('fc-selected');
                }, this.selectedEvent);
                this.selectedEvent = null;
            }
        },


        isEventSelected: function(event) {
            // event references might change on refetchEvents(), while selectedEvent doesn't,
            // so compare IDs
            return this.selectedEvent && this.selectedEvent._id === event._id;
        },


        /* Mouse / Touch Unselecting (time range & event unselection)
         ------------------------------------------------------------------------------------------------------------------*/
        // TODO: move consistently to down/start or up/end?
        // TODO: don't kill previous selection if touch scrolling


        handleDocumentMousedown: function(ev) {
            if (isPrimaryMouseButton(ev)) {
                this.processUnselect(ev);
            }
        },


        processUnselect: function(ev) {
            this.processRangeUnselect(ev);
            this.processEventUnselect(ev);
        },


        processRangeUnselect: function(ev) {
            var ignore;

            // is there a time-range selection?
            if (this.isSelected && this.opt('unselectAuto')) {
                // only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
                ignore = this.opt('unselectCancel');
                if (!ignore || !$(ev.target).closest(ignore).length) {
                    this.unselect(ev);
                }
            }
        },


        processEventUnselect: function(ev) {
            if (this.selectedEvent) {
                if (!$(ev.target).closest('.fc-selected').length) {
                    this.unselectEvent();
                }
            }
        },


        /* Day Click
         ------------------------------------------------------------------------------------------------------------------*/


        // Triggers handlers to 'dayClick'
        // Span has start/end of the clicked area. Only the start is useful.
        triggerDayClick: function(span, dayEl, ev) {
            this.publiclyTrigger(
                'dayClick',
                dayEl,
                this.calendar.applyTimezone(span.start), // convert to calendar's timezone for external API
                ev
            );
        },


        /* Date Utils
         ------------------------------------------------------------------------------------------------------------------*/


        // Returns the date range of the full days the given range visually appears to occupy.
        // Returns a new range object.
        computeDayRange: function(range) {
            var startDay = range.start.clone().stripTime(); // the beginning of the day the range starts
            var end = range.end;
            var endDay = null;
            var endTimeMS;

            if (end) {
                endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
                endTimeMS = +end.time(); // # of milliseconds into `endDay`

                // If the end time is actually inclusively part of the next day and is equal to or
                // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
                // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
                if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
                    endDay.add(1, 'days');
                }
            }

            // If no end was specified, or if it is within `startDay` but not past nextDayThreshold,
            // assign the default duration of one day.
            if (!end || endDay <= startDay) {
                endDay = startDay.clone().add(1, 'days');
            }

            return { start: startDay, end: endDay };
        },


        // Does the given event visually appear to occupy more than one day?
        isMultiDayEvent: function(event) {
            var range = this.computeDayRange(event); // event is range-ish

            return range.end.diff(range.start, 'days') > 1;
        }

    });


    View.watch('displayingDates', [ 'dateProfile' ], function(deps) {
        this.requestDateRender(deps.dateProfile);
    }, function() {
        this.requestDateUnrender();
    });


    View.watch('initialEvents', [ 'dateProfile' ], function(deps) {
        return this.fetchInitialEvents(deps.dateProfile);
    });


    View.watch('bindingEvents', [ 'initialEvents' ], function(deps) {
        this.setEvents(deps.initialEvents);
        this.bindEventChanges();
    }, function() {
        this.unbindEventChanges();
        this.unsetEvents();
    });


    View.watch('displayingEvents', [ 'displayingDates', 'hasEvents' ], function() {
        this.requestEventsRender(this.get('currentEvents')); // if there were event mutations after initialEvents
    }, function() {
        this.requestEventsUnrender();
    });

    ;;

    View.mixin({

        // range the view is formally responsible for.
        // for example, a month view might have 1st-31st, excluding padded dates
        currentRange: null,
        currentRangeUnit: null, // name of largest unit being displayed, like "month" or "week"

        // date range with a rendered skeleton
        // includes not-active days that need some sort of DOM
        renderRange: null,

        // dates that display events and accept drag-n-drop
        activeRange: null,

        // constraint for where prev/next operations can go and where events can be dragged/resized to.
        // an object with optional start and end properties.
        validRange: null,

        // how far the current date will move for a prev/next operation
        dateIncrement: null,

        minTime: null, // Duration object that denotes the first visible time of any given day
        maxTime: null, // Duration object that denotes the exclusive visible end time of any given day
        usesMinMaxTime: false, // whether minTime/maxTime will affect the activeRange. Views must opt-in.

        // DEPRECATED
        start: null, // use activeRange.start
        end: null, // use activeRange.end
        intervalStart: null, // use currentRange.start
        intervalEnd: null, // use currentRange.end


        /* Date Range Computation
         ------------------------------------------------------------------------------------------------------------------*/


        setDateProfileForRendering: function(dateProfile) {
            this.currentRange = dateProfile.currentRange;
            this.currentRangeUnit = dateProfile.currentRangeUnit;
            this.renderRange = dateProfile.renderRange;
            this.activeRange = dateProfile.activeRange;
            this.validRange = dateProfile.validRange;
            this.dateIncrement = dateProfile.dateIncrement;
            this.minTime = dateProfile.minTime;
            this.maxTime = dateProfile.maxTime;

            // DEPRECATED, but we need to keep it updated
            this.start = dateProfile.activeRange.start;
            this.end = dateProfile.activeRange.end;
            this.intervalStart = dateProfile.currentRange.start;
            this.intervalEnd = dateProfile.currentRange.end;
        },


        // Builds a structure with info about what the dates/ranges will be for the "prev" view.
        buildPrevDateProfile: function(date) {
            var prevDate = date.clone().startOf(this.currentRangeUnit).subtract(this.dateIncrement);

            return this.buildDateProfile(prevDate, -1);
        },


        // Builds a structure with info about what the dates/ranges will be for the "next" view.
        buildNextDateProfile: function(date) {
            var nextDate = date.clone().startOf(this.currentRangeUnit).add(this.dateIncrement);

            return this.buildDateProfile(nextDate, 1);
        },


        // Builds a structure holding dates/ranges for rendering around the given date.
        // Optional direction param indicates whether the date is being incremented/decremented
        // from its previous value. decremented = -1, incremented = 1 (default).
        buildDateProfile: function(date, direction, forceToValid) {
            var validRange = this.buildValidRange();
            var minTime = null;
            var maxTime = null;
            var currentInfo;
            var renderRange;
            var activeRange;
            var isValid;

            if (forceToValid) {
                date = constrainDate(date, validRange);
            }

            currentInfo = this.buildCurrentRangeInfo(date, direction);
            renderRange = this.buildRenderRange(currentInfo.range, currentInfo.unit);
            activeRange = cloneRange(renderRange);

            if (!this.opt('showNonCurrentDates')) {
                activeRange = constrainRange(activeRange, currentInfo.range);
            }

            minTime = moment.duration(this.opt('minTime'));
            maxTime = moment.duration(this.opt('maxTime'));
            this.adjustActiveRange(activeRange, minTime, maxTime);

            activeRange = constrainRange(activeRange, validRange);
            date = constrainDate(date, activeRange);

            // it's invalid if the originally requested date is not contained,
            // or if the range is completely outside of the valid range.
            isValid = doRangesIntersect(currentInfo.range, validRange);

            return {
                validRange: validRange,
                currentRange: currentInfo.range,
                currentRangeUnit: currentInfo.unit,
                activeRange: activeRange,
                renderRange: renderRange,
                minTime: minTime,
                maxTime: maxTime,
                isValid: isValid,
                date: date,
                dateIncrement: this.buildDateIncrement(currentInfo.duration)
                // pass a fallback (might be null) ^
            };
        },


        // Builds an object with optional start/end properties.
        // Indicates the minimum/maximum dates to display.
        buildValidRange: function() {
            return this.getRangeOption('validRange', this.calendar.getNow()) || {};
        },


        // Builds a structure with info about the "current" range, the range that is
        // highlighted as being the current month for example.
        // See buildDateProfile for a description of `direction`.
        // Guaranteed to have `range` and `unit` properties. `duration` is optional.
        buildCurrentRangeInfo: function(date, direction) {
            var duration = null;
            var unit = null;
            var range = null;
            var dayCount;

            if (this.viewSpec.duration) {
                duration = this.viewSpec.duration;
                unit = this.viewSpec.durationUnit;
                range = this.buildRangeFromDuration(date, direction, duration, unit);
            }
            else if ((dayCount = this.opt('dayCount'))) {
                unit = 'day';
                range = this.buildRangeFromDayCount(date, direction, dayCount);
            }
            else if ((range = this.buildCustomVisibleRange(date))) {
                unit = computeGreatestUnit(range.start, range.end);
            }
            else {
                duration = this.getFallbackDuration();
                unit = computeGreatestUnit(duration);
                range = this.buildRangeFromDuration(date, direction, duration, unit);
            }

            this.normalizeCurrentRange(range, unit); // modifies in-place

            return { duration: duration, unit: unit, range: range };
        },


        getFallbackDuration: function() {
            return moment.duration({ days: 1 });
        },


        // If the range has day units or larger, remove times. Otherwise, ensure times.
        normalizeCurrentRange: function(range, unit) {

            if (/^(year|month|week|day)$/.test(unit)) { // whole-days?
                range.start.stripTime();
                range.end.stripTime();
            }
            else { // needs to have a time?
                if (!range.start.hasTime()) {
                    range.start.time(0); // give 00:00 time
                }
                if (!range.end.hasTime()) {
                    range.end.time(0); // give 00:00 time
                }
            }
        },


        // Mutates the given activeRange to have time values (un-ambiguate)
        // if the minTime or maxTime causes the range to expand.
        // TODO: eventually activeRange should *always* have times.
        adjustActiveRange: function(range, minTime, maxTime) {
            var hasSpecialTimes = false;

            if (this.usesMinMaxTime) {

                if (minTime < 0) {
                    range.start.time(0).add(minTime);
                    hasSpecialTimes = true;
                }

                if (maxTime > 24 * 60 * 60 * 1000) { // beyond 24 hours?
                    range.end.time(maxTime - (24 * 60 * 60 * 1000));
                    hasSpecialTimes = true;
                }

                if (hasSpecialTimes) {
                    if (!range.start.hasTime()) {
                        range.start.time(0);
                    }
                    if (!range.end.hasTime()) {
                        range.end.time(0);
                    }
                }
            }
        },


        // Builds the "current" range when it is specified as an explicit duration.
        // `unit` is the already-computed computeGreatestUnit value of duration.
        buildRangeFromDuration: function(date, direction, duration, unit) {
            var alignment = this.opt('dateAlignment');
            var start = date.clone();
            var end;
            var dateIncrementInput;
            var dateIncrementDuration;

            // if the view displays a single day or smaller
            if (duration.as('days') <= 1) {
                if (this.isHiddenDay(start)) {
                    start = this.skipHiddenDays(start, direction);
                    start.startOf('day');
                }
            }

            // compute what the alignment should be
            if (!alignment) {
                dateIncrementInput = this.opt('dateIncrement');

                if (dateIncrementInput) {
                    dateIncrementDuration = moment.duration(dateIncrementInput);

                    // use the smaller of the two units
                    if (dateIncrementDuration < duration) {
                        alignment = computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);
                    }
                    else {
                        alignment = unit;
                    }
                }
                else {
                    alignment = unit;
                }
            }

            start.startOf(alignment);
            end = start.clone().add(duration);

            return { start: start, end: end };
        },


        // Builds the "current" range when a dayCount is specified.
        buildRangeFromDayCount: function(date, direction, dayCount) {
            var customAlignment = this.opt('dateAlignment');
            var runningCount = 0;
            var start = date.clone();
            var end;

            if (customAlignment) {
                start.startOf(customAlignment);
            }

            start.startOf('day');
            start = this.skipHiddenDays(start, direction);

            end = start.clone();
            do {
                end.add(1, 'day');
                if (!this.isHiddenDay(end)) {
                    runningCount++;
                }
            } while (runningCount < dayCount);

            return { start: start, end: end };
        },


        // Builds a normalized range object for the "visible" range,
        // which is a way to define the currentRange and activeRange at the same time.
        buildCustomVisibleRange: function(date) {
            var visibleRange = this.getRangeOption(
                'visibleRange',
                this.calendar.moment(date) // correct zone. also generates new obj that avoids mutations
            );

            if (visibleRange && (!visibleRange.start || !visibleRange.end)) {
                return null;
            }

            return visibleRange;
        },


        // Computes the range that will represent the element/cells for *rendering*,
        // but which may have voided days/times.
        buildRenderRange: function(currentRange, currentRangeUnit) {
            // cut off days in the currentRange that are hidden
            return this.trimHiddenDays(currentRange);
        },


        // Compute the duration value that should be added/substracted to the current date
        // when a prev/next operation happens.
        buildDateIncrement: function(fallback) {
            var dateIncrementInput = this.opt('dateIncrement');
            var customAlignment;

            if (dateIncrementInput) {
                return moment.duration(dateIncrementInput);
            }
            else if ((customAlignment = this.opt('dateAlignment'))) {
                return moment.duration(1, customAlignment);
            }
            else if (fallback) {
                return fallback;
            }
            else {
                return moment.duration({ days: 1 });
            }
        },


        // Remove days from the beginning and end of the range that are computed as hidden.
        trimHiddenDays: function(inputRange) {
            return {
                start: this.skipHiddenDays(inputRange.start),
                end: this.skipHiddenDays(inputRange.end, -1, true) // exclusively move backwards
            };
        },


        // Compute the number of the give units in the "current" range.
        // Will return a floating-point number. Won't round.
        currentRangeAs: function(unit) {
            var currentRange = this.currentRange;
            return currentRange.end.diff(currentRange.start, unit, true);
        },


        // Arguments after name will be forwarded to a hypothetical function value
        // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
        // Always clone your objects if you fear mutation.
        getRangeOption: function(name) {
            var val = this.opt(name);

            if (typeof val === 'function') {
                val = val.apply(
                    null,
                    Array.prototype.slice.call(arguments, 1)
                );
            }

            if (val) {
                return this.calendar.parseRange(val);
            }
        },


        /* Hidden Days
         ------------------------------------------------------------------------------------------------------------------*/


        // Initializes internal variables related to calculating hidden days-of-week
        initHiddenDays: function() {
            var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
            var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
            var dayCnt = 0;
            var i;

            if (this.opt('weekends') === false) {
                hiddenDays.push(0, 6); // 0=sunday, 6=saturday
            }

            for (i = 0; i < 7; i++) {
                if (
                    !(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)
                ) {
                    dayCnt++;
                }
            }

            if (!dayCnt) {
                throw 'invalid hiddenDays'; // all days were hidden? bad.
            }

            this.isHiddenDayHash = isHiddenDayHash;
        },


        // Is the current day hidden?
        // `day` is a day-of-week index (0-6), or a Moment
        isHiddenDay: function(day) {
            if (moment.isMoment(day)) {
                day = day.day();
            }
            return this.isHiddenDayHash[day];
        },


        // Incrementing the current day until it is no longer a hidden day, returning a copy.
        // DOES NOT CONSIDER validRange!
        // If the initial value of `date` is not a hidden day, don't do anything.
        // Pass `isExclusive` as `true` if you are dealing with an end date.
        // `inc` defaults to `1` (increment one day forward each time)
        skipHiddenDays: function(date, inc, isExclusive) {
            var out = date.clone();
            inc = inc || 1;
            while (
                this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]
                ) {
                out.add(inc, 'days');
            }
            return out;
        }

    });

    ;;

    /*
     Embodies a div that has potential scrollbars
     */
    var Scroller = FC.Scroller = Class.extend({

        el: null, // the guaranteed outer element
        scrollEl: null, // the element with the scrollbars
        overflowX: null,
        overflowY: null,


        constructor: function(options) {
            options = options || {};
            this.overflowX = options.overflowX || options.overflow || 'auto';
            this.overflowY = options.overflowY || options.overflow || 'auto';
        },


        render: function() {
            this.el = this.renderEl();
            this.applyOverflow();
        },


        renderEl: function() {
            return (this.scrollEl = $('<div class="fc-scroller"></div>'));
        },


        // sets to natural height, unlocks overflow
        clear: function() {
            this.setHeight('auto');
            this.applyOverflow();
        },


        destroy: function() {
            this.el.remove();
        },


        // Overflow
        // -----------------------------------------------------------------------------------------------------------------


        applyOverflow: function() {
            this.scrollEl.css({
                'overflow-x': this.overflowX,
                'overflow-y': this.overflowY
            });
        },


        // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
        // Useful for preserving scrollbar widths regardless of future resizes.
        // Can pass in scrollbarWidths for optimization.
        lockOverflow: function(scrollbarWidths) {
            var overflowX = this.overflowX;
            var overflowY = this.overflowY;

            scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();

            if (overflowX === 'auto') {
                overflowX = (
                    scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?
                    // OR scrolling pane with massless scrollbars?
                    this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth
                    // subtract 1 because of IE off-by-one issue
                ) ? 'scroll' : 'hidden';
            }

            if (overflowY === 'auto') {
                overflowY = (
                    scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?
                    // OR scrolling pane with massless scrollbars?
                    this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight
                    // subtract 1 because of IE off-by-one issue
                ) ? 'scroll' : 'hidden';
            }

            this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });
        },


        // Getters / Setters
        // -----------------------------------------------------------------------------------------------------------------


        setHeight: function(height) {
            this.scrollEl.height(height);
        },


        getScrollTop: function() {
            return this.scrollEl.scrollTop();
        },


        setScrollTop: function(top) {
            this.scrollEl.scrollTop(top);
        },


        getClientWidth: function() {
            return this.scrollEl[0].clientWidth;
        },


        getClientHeight: function() {
            return this.scrollEl[0].clientHeight;
        },


        getScrollbarWidths: function() {
            return getScrollbarWidths(this.scrollEl);
        }

    });

    ;;
    function Iterator(items) {
        this.items = items || [];
    }


    /* Calls a method on every item passing the arguments through */
    Iterator.prototype.proxyCall = function(methodName) {
        var args = Array.prototype.slice.call(arguments, 1);
        var results = [];

        this.items.forEach(function(item) {
            results.push(item[methodName].apply(item, args));
        });

        return results;
    };

    ;;

    /* Toolbar with buttons and title
     ----------------------------------------------------------------------------------------------------------------------*/

    function Toolbar(calendar, toolbarOptions) {
        var t = this;

        // exports
        t.setToolbarOptions = setToolbarOptions;
        t.render = render;
        t.removeElement = removeElement;
        t.updateTitle = updateTitle;
        t.activateButton = activateButton;
        t.deactivateButton = deactivateButton;
        t.disableButton = disableButton;
        t.enableButton = enableButton;
        t.getViewsWithButtons = getViewsWithButtons;
        t.el = null; // mirrors local `el`

        // locals
        var el;
        var viewsWithButtons = [];
        var tm;

        // method to update toolbar-specific options, not calendar-wide options
        function setToolbarOptions(newToolbarOptions) {
            toolbarOptions = newToolbarOptions;
        }

        // can be called repeatedly and will rerender
        function render() {
            var sections = toolbarOptions.layout;

            tm = calendar.opt('theme') ? 'ui' : 'fc';

            if (sections) {
                if (!el) {
                    el = this.el = $("<div class='fc-toolbar "+ toolbarOptions.extraClasses + "'/>");
                }
                else {
                    el.empty();
                }
                el.append(renderSection('left'))
                    .append(renderSection('right'))
                    .append(renderSection('center'))
                    .append('<div class="fc-clear"/>');
            }
            else {
                removeElement();
            }
        }


        function removeElement() {
            if (el) {
                el.remove();
                el = t.el = null;
            }
        }


        function renderSection(position) {
            var sectionEl = $('<div class="fc-' + position + '"/>');
            var buttonStr = toolbarOptions.layout[position];
            var calendarCustomButtons = calendar.opt('customButtons') || {};
            var calendarButtonText = calendar.opt('buttonText') || {};

            if (buttonStr) {
                $.each(buttonStr.split(' '), function(i) {
                    var groupChildren = $();
                    var isOnlyButtons = true;
                    var groupEl;

                    $.each(this.split(','), function(j, buttonName) {
                        var customButtonProps;
                        var viewSpec;
                        var buttonClick;
                        var overrideText; // text explicitly set by calendar's constructor options. overcomes icons
                        var defaultText;
                        var themeIcon;
                        var normalIcon;
                        var innerHtml;
                        var classes;
                        var button; // the element

                        if (buttonName == 'title') {
                            groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height
                            isOnlyButtons = false;
                        }
                        else {
                            if ((customButtonProps = calendarCustomButtons[buttonName])) {
                                buttonClick = function(ev) {
                                    if (customButtonProps.click) {
                                        customButtonProps.click.call(button[0], ev);
                                    }
                                };
                                overrideText = ''; // icons will override text
                                defaultText = customButtonProps.text;
                            }
                            else if ((viewSpec = calendar.getViewSpec(buttonName))) {
                                buttonClick = function() {
                                    calendar.changeView(buttonName);
                                };
                                viewsWithButtons.push(buttonName);
                                overrideText = viewSpec.buttonTextOverride;
                                defaultText = viewSpec.buttonTextDefault;
                            }
                            else if (calendar[buttonName]) { // a calendar method
                                buttonClick = function() {
                                    calendar[buttonName]();
                                };
                                overrideText = (calendar.overrides.buttonText || {})[buttonName];
                                defaultText = calendarButtonText[buttonName]; // everything else is considered default
                            }

                            if (buttonClick) {

                                themeIcon =
                                    customButtonProps ?
                                        customButtonProps.themeIcon :
                                        calendar.opt('themeButtonIcons')[buttonName];

                                normalIcon =
                                    customButtonProps ?
                                        customButtonProps.icon :
                                        calendar.opt('buttonIcons')[buttonName];

                                if (overrideText) {
                                    innerHtml = htmlEscape(overrideText);
                                }
                                else if (themeIcon && calendar.opt('theme')) {
                                    innerHtml = "<span class='ui-icon ui-icon-" + themeIcon + "'></span>";
                                }
                                else if (normalIcon && !calendar.opt('theme')) {
                                    innerHtml = "<span class='fc-icon fc-icon-" + normalIcon + "'></span>";
                                }
                                else {
                                    innerHtml = htmlEscape(defaultText);
                                }

                                classes = [
                                    'fc-' + buttonName + '-button',
                                    tm + '-button',
                                    tm + '-state-default'
                                ];

                                button = $( // type="button" so that it doesn't submit a form
                                    '<button type="button" class="' + classes.join(' ') + '">' +
                                    innerHtml +
                                    '</button>'
                                )
                                    .click(function(ev) {
                                        // don't process clicks for disabled buttons
                                        if (!button.hasClass(tm + '-state-disabled')) {

                                            buttonClick(ev);

                                            // after the click action, if the button becomes the "active" tab, or disabled,
                                            // it should never have a hover class, so remove it now.
                                            if (
                                                button.hasClass(tm + '-state-active') ||
                                                button.hasClass(tm + '-state-disabled')
                                            ) {
                                                button.removeClass(tm + '-state-hover');
                                            }
                                        }
                                    })
                                    .mousedown(function() {
                                        // the *down* effect (mouse pressed in).
                                        // only on buttons that are not the "active" tab, or disabled
                                        button
                                            .not('.' + tm + '-state-active')
                                            .not('.' + tm + '-state-disabled')
                                            .addClass(tm + '-state-down');
                                    })
                                    .mouseup(function() {
                                        // undo the *down* effect
                                        button.removeClass(tm + '-state-down');
                                    })
                                    .hover(
                                        function() {
                                            // the *hover* effect.
                                            // only on buttons that are not the "active" tab, or disabled
                                            button
                                                .not('.' + tm + '-state-active')
                                                .not('.' + tm + '-state-disabled')
                                                .addClass(tm + '-state-hover');
                                        },
                                        function() {
                                            // undo the *hover* effect
                                            button
                                                .removeClass(tm + '-state-hover')
                                                .removeClass(tm + '-state-down'); // if mouseleave happens before mouseup
                                        }
                                    );

                                groupChildren = groupChildren.add(button);
                            }
                        }
                    });

                    if (isOnlyButtons) {
                        groupChildren
                            .first().addClass(tm + '-corner-left').end()
                            .last().addClass(tm + '-corner-right').end();
                    }

                    if (groupChildren.length > 1) {
                        groupEl = $('<div/>');
                        if (isOnlyButtons) {
                            groupEl.addClass('fc-button-group');
                        }
                        groupEl.append(groupChildren);
                        sectionEl.append(groupEl);
                    }
                    else {
                        sectionEl.append(groupChildren); // 1 or 0 children
                    }
                });
            }

            return sectionEl;
        }


        function updateTitle(text) {
            if (el) {
                el.find('h2').text(text);
            }
        }


        function activateButton(buttonName) {
            if (el) {
                el.find('.fc-' + buttonName + '-button')
                    .addClass(tm + '-state-active');
            }
        }


        function deactivateButton(buttonName) {
            if (el) {
                el.find('.fc-' + buttonName + '-button')
                    .removeClass(tm + '-state-active');
            }
        }


        function disableButton(buttonName) {
            if (el) {
                el.find('.fc-' + buttonName + '-button')
                    .prop('disabled', true)
                    .addClass(tm + '-state-disabled');
            }
        }


        function enableButton(buttonName) {
            if (el) {
                el.find('.fc-' + buttonName + '-button')
                    .prop('disabled', false)
                    .removeClass(tm + '-state-disabled');
            }
        }


        function getViewsWithButtons() {
            return viewsWithButtons;
        }

    }

    ;;

    var Calendar = FC.Calendar = Class.extend(EmitterMixin, {

        view: null, // current View object
        viewsByType: null, // holds all instantiated view instances, current or not
        currentDate: null, // unzoned moment. private (public API should use getDate instead)
        loadingLevel: 0, // number of simultaneous loading tasks


        constructor: function(el, overrides) {

            // declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.
            // unneeded() is called in destroy.
            GlobalEmitter.needed();

            this.el = el;
            this.viewsByType = {};
            this.viewSpecCache = {};

            this.initOptionsInternals(overrides);
            this.initMomentInternals(); // needs to happen after options hash initialized
            this.initCurrentDate();

            EventManager.call(this); // needs options immediately
            this.initialize();
        },


        // Subclasses can override this for initialization logic after the constructor has been called
        initialize: function() {
        },


        // Public API
        // -----------------------------------------------------------------------------------------------------------------


        getCalendar: function() {
            return this;
        },


        getView: function() {
            return this.view;
        },


        publiclyTrigger: function(name, thisObj) {
            var args = Array.prototype.slice.call(arguments, 2);
            var optHandler = this.opt(name);

            thisObj = thisObj || this.el[0];
            this.triggerWith(name, thisObj, args); // Emitter's method

            if (optHandler) {
                return optHandler.apply(thisObj, args);
            }
        },


        // View
        // -----------------------------------------------------------------------------------------------------------------


        // Given a view name for a custom view or a standard view, creates a ready-to-go View object
        instantiateView: function(viewType) {
            var spec = this.getViewSpec(viewType);

            return new spec['class'](this, spec);
        },


        // Returns a boolean about whether the view is okay to instantiate at some point
        isValidViewType: function(viewType) {
            return Boolean(this.getViewSpec(viewType));
        },


        changeView: function(viewName, dateOrRange) {

            if (dateOrRange) {

                if (dateOrRange.start && dateOrRange.end) { // a range
                    this.recordOptionOverrides({ // will not rerender
                        visibleRange: dateOrRange
                    });
                }
                else { // a date
                    this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate
                }
            }

            this.renderView(viewName);
        },


        // Forces navigation to a view for the given date.
        // `viewType` can be a specific view name or a generic one like "week" or "day".
        zoomTo: function(newDate, viewType) {
            var spec;

            viewType = viewType || 'day'; // day is default zoom
            spec = this.getViewSpec(viewType) || this.getUnitViewSpec(viewType);

            this.currentDate = newDate.clone();
            this.renderView(spec ? spec.type : null);
        },


        // Current Date
        // -----------------------------------------------------------------------------------------------------------------


        initCurrentDate: function() {
            var defaultDateInput = this.opt('defaultDate');

            // compute the initial ambig-timezone date
            if (defaultDateInput != null) {
                this.currentDate = this.moment(defaultDateInput).stripZone();
            }
            else {
                this.currentDate = this.getNow(); // getNow already returns unzoned
            }
        },


        prev: function() {
            var prevInfo = this.view.buildPrevDateProfile(this.currentDate);

            if (prevInfo.isValid) {
                this.currentDate = prevInfo.date;
                this.renderView();
            }
        },


        next: function() {
            var nextInfo = this.view.buildNextDateProfile(this.currentDate);

            if (nextInfo.isValid) {
                this.currentDate = nextInfo.date;
                this.renderView();
            }
        },


        prevYear: function() {
            this.currentDate.add(-1, 'years');
            this.renderView();
        },


        nextYear: function() {
            this.currentDate.add(1, 'years');
            this.renderView();
        },


        today: function() {
            this.currentDate = this.getNow(); // should deny like prev/next?
            this.renderView();
        },


        gotoDate: function(zonedDateInput) {
            this.currentDate = this.moment(zonedDateInput).stripZone();
            this.renderView();
        },


        incrementDate: function(delta) {
            this.currentDate.add(moment.duration(delta));
            this.renderView();
        },


        // for external API
        getDate: function() {
            return this.applyTimezone(this.currentDate); // infuse the calendar's timezone
        },


        // Loading Triggering
        // -----------------------------------------------------------------------------------------------------------------


        // Should be called when any type of async data fetching begins
        pushLoading: function() {
            if (!(this.loadingLevel++)) {
                this.publiclyTrigger('loading', null, true, this.view);
            }
        },


        // Should be called when any type of async data fetching completes
        popLoading: function() {
            if (!(--this.loadingLevel)) {
                this.publiclyTrigger('loading', null, false, this.view);
            }
        },


        // Selection
        // -----------------------------------------------------------------------------------------------------------------


        // this public method receives start/end dates in any format, with any timezone
        select: function(zonedStartInput, zonedEndInput) {
            this.view.select(
                this.buildSelectSpan.apply(this, arguments)
            );
        },


        unselect: function() { // safe to be called before renderView
            if (this.view) {
                this.view.unselect();
            }
        },


        // Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
        buildSelectSpan: function(zonedStartInput, zonedEndInput) {
            var start = this.moment(zonedStartInput).stripZone();
            var end;

            if (zonedEndInput) {
                end = this.moment(zonedEndInput).stripZone();
            }
            else if (start.hasTime()) {
                end = start.clone().add(this.defaultTimedEventDuration);
            }
            else {
                end = start.clone().add(this.defaultAllDayEventDuration);
            }

            return { start: start, end: end };
        },


        // Misc
        // -----------------------------------------------------------------------------------------------------------------


        // will return `null` if invalid range
        parseRange: function(rangeInput) {
            var start = null;
            var end = null;

            if (rangeInput.start) {
                start = this.moment(rangeInput.start).stripZone();
            }

            if (rangeInput.end) {
                end = this.moment(rangeInput.end).stripZone();
            }

            if (!start && !end) {
                return null;
            }

            if (start && end && end.isBefore(start)) {
                return null;
            }

            return { start: start, end: end };
        },


        rerenderEvents: function() { // API method. destroys old events if previously rendered.
            if (this.elementVisible()) {
                this.reportEventChange(); // will re-trasmit events to the view, causing a rerender
            }
        }

    });

    ;;
    /*
     Options binding/triggering system.
     */
    Calendar.mixin({

        dirDefaults: null, // option defaults related to LTR or RTL
        localeDefaults: null, // option defaults related to current locale
        overrides: null, // option overrides given to the fullCalendar constructor
        dynamicOverrides: null, // options set with dynamic setter method. higher precedence than view overrides.
        optionsModel: null, // all defaults combined with overrides


        initOptionsInternals: function(overrides) {
            this.overrides = $.extend({}, overrides); // make a copy
            this.dynamicOverrides = {};
            this.optionsModel = new Model();

            this.populateOptionsHash();
        },


        // public getter/setter
        option: function(name, value) {
            var newOptionHash;

            if (typeof name === 'string') {
                if (value === undefined) { // getter
                    return this.optionsModel.get(name);
                }
                else { // setter for individual option
                    newOptionHash = {};
                    newOptionHash[name] = value;
                    this.setOptions(newOptionHash);
                }
            }
            else if (typeof name === 'object') { // compound setter with object input
                this.setOptions(name);
            }
        },


        // private getter
        opt: function(name) {
            return this.optionsModel.get(name);
        },


        setOptions: function(newOptionHash) {
            var optionCnt = 0;
            var optionName;

            this.recordOptionOverrides(newOptionHash);

            for (optionName in newOptionHash) {
                optionCnt++;
            }

            // special-case handling of single option change.
            // if only one option change, `optionName` will be its name.
            if (optionCnt === 1) {
                if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {
                    this.updateSize(true); // true = allow recalculation of height
                    return;
                }
                else if (optionName === 'defaultDate') {
                    return; // can't change date this way. use gotoDate instead
                }
                else if (optionName === 'businessHours') {
                    if (this.view) {
                        this.view.unrenderBusinessHours();
                        this.view.renderBusinessHours();
                    }
                    return;
                }
                else if (optionName === 'timezone') {
                    this.rezoneArrayEventSources();
                    this.refetchEvents();
                    return;
                }
            }

            // catch-all. rerender the header and footer and rebuild/rerender the current view
            this.renderHeader();
            this.renderFooter();

            // even non-current views will be affected by this option change. do before rerender
            // TODO: detangle
            this.viewsByType = {};

            this.reinitView();
        },


        // Computes the flattened options hash for the calendar and assigns to `this.options`.
        // Assumes this.overrides and this.dynamicOverrides have already been initialized.
        populateOptionsHash: function() {
            var locale, localeDefaults;
            var isRTL, dirDefaults;
            var rawOptions;

            locale = firstDefined( // explicit locale option given?
                this.dynamicOverrides.locale,
                this.overrides.locale
            );
            localeDefaults = localeOptionHash[locale];
            if (!localeDefaults) { // explicit locale option not given or invalid?
                locale = Calendar.defaults.locale;
                localeDefaults = localeOptionHash[locale] || {};
            }

            isRTL = firstDefined( // based on options computed so far, is direction RTL?
                this.dynamicOverrides.isRTL,
                this.overrides.isRTL,
                localeDefaults.isRTL,
                Calendar.defaults.isRTL
            );
            dirDefaults = isRTL ? Calendar.rtlDefaults : {};

            this.dirDefaults = dirDefaults;
            this.localeDefaults = localeDefaults;

            rawOptions = mergeOptions([ // merge defaults and overrides. lowest to highest precedence
                Calendar.defaults, // global defaults
                dirDefaults,
                localeDefaults,
                this.overrides,
                this.dynamicOverrides
            ]);
            populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options

            this.optionsModel.reset(rawOptions);
        },


        // stores the new options internally, but does not rerender anything.
        recordOptionOverrides: function(newOptionHash) {
            var optionName;

            for (optionName in newOptionHash) {
                this.dynamicOverrides[optionName] = newOptionHash[optionName];
            }

            this.viewSpecCache = {}; // the dynamic override invalidates the options in this cache, so just clear it
            this.populateOptionsHash(); // this.options needs to be recomputed after the dynamic override
        }

    });

    ;;

    Calendar.mixin({

        defaultAllDayEventDuration: null,
        defaultTimedEventDuration: null,
        localeData: null,


        initMomentInternals: function() {
            var _this = this;

            this.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));
            this.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));

            // Called immediately, and when any of the options change.
            // Happens before any internal objects rebuild or rerender, because this is very core.
            this.optionsModel.watch('buildingMomentLocale', [
                '?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',
                '?firstDay', '?weekNumberCalculation'
            ], function(opts) {
                var weekNumberCalculation = opts.weekNumberCalculation;
                var firstDay = opts.firstDay;
                var _week;

                // normalize
                if (weekNumberCalculation === 'iso') {
                    weekNumberCalculation = 'ISO'; // normalize
                }

                var localeData = createObject( // make a cheap copy
                    getMomentLocaleData(opts.locale) // will fall back to en
                );

                if (opts.monthNames) {
                    localeData._months = opts.monthNames;
                }
                if (opts.monthNamesShort) {
                    localeData._monthsShort = opts.monthNamesShort;
                }
                if (opts.dayNames) {
                    localeData._weekdays = opts.dayNames;
                }
                if (opts.dayNamesShort) {
                    localeData._weekdaysShort = opts.dayNamesShort;
                }

                if (firstDay == null && weekNumberCalculation === 'ISO') {
                    firstDay = 1;
                }
                if (firstDay != null) {
                    _week = createObject(localeData._week); // _week: { dow: # }
                    _week.dow = firstDay;
                    localeData._week = _week;
                }

                if ( // whitelist certain kinds of input
                weekNumberCalculation === 'ISO' ||
                weekNumberCalculation === 'local' ||
                typeof weekNumberCalculation === 'function'
                ) {
                    localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it
                }

                _this.localeData = localeData;

                // If the internal current date object already exists, move to new locale.
                // We do NOT need to do this technique for event dates, because this happens when converting to "segments".
                if (_this.currentDate) {
                    _this.localizeMoment(_this.currentDate); // sets to localeData
                }
            });
        },


        // Builds a moment using the settings of the current calendar: timezone and locale.
        // Accepts anything the vanilla moment() constructor accepts.
        moment: function() {
            var mom;

            if (this.opt('timezone') === 'local') {
                mom = FC.moment.apply(null, arguments);

                // Force the moment to be local, because FC.moment doesn't guarantee it.
                if (mom.hasTime()) { // don't give ambiguously-timed moments a local zone
                    mom.local();
                }
            }
            else if (this.opt('timezone') === 'UTC') {
                mom = FC.moment.utc.apply(null, arguments); // process as UTC
            }
            else {
                mom = FC.moment.parseZone.apply(null, arguments); // let the input decide the zone
            }

            this.localizeMoment(mom); // TODO

            return mom;
        },


        // Updates the given moment's locale settings to the current calendar locale settings.
        localizeMoment: function(mom) {
            mom._locale = this.localeData;
        },


        // Returns a boolean about whether or not the calendar knows how to calculate
        // the timezone offset of arbitrary dates in the current timezone.
        getIsAmbigTimezone: function() {
            return this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';
        },


        // Returns a copy of the given date in the current timezone. Has no effect on dates without times.
        applyTimezone: function(date) {
            if (!date.hasTime()) {
                return date.clone();
            }

            var zonedDate = this.moment(date.toArray());
            var timeAdjust = date.time() - zonedDate.time();
            var adjustedZonedDate;

            // Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
            if (timeAdjust) { // is the time result different than expected?
                adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds
                if (date.time() - adjustedZonedDate.time() === 0) { // does it match perfectly now?
                    zonedDate = adjustedZonedDate;
                }
            }

            return zonedDate;
        },


        // Returns a moment for the current date, as defined by the client's computer or from the `now` option.
        // Will return an moment with an ambiguous timezone.
        getNow: function() {
            var now = this.opt('now');
            if (typeof now === 'function') {
                now = now();
            }
            return this.moment(now).stripZone();
        },


        // Produces a human-readable string for the given duration.
        // Side-effect: changes the locale of the given duration.
        humanizeDuration: function(duration) {
            return duration.locale(this.opt('locale')).humanize();
        },



        // Event-Specific Date Utilities. TODO: move
        // -----------------------------------------------------------------------------------------------------------------


        // Get an event's normalized end date. If not present, calculate it from the defaults.
        getEventEnd: function(event) {
            if (event.end) {
                return event.end.clone();
            }
            else {
                return this.getDefaultEventEnd(event.allDay, event.start);
            }
        },


        // Given an event's allDay status and start date, return what its fallback end date should be.
        // TODO: rename to computeDefaultEventEnd
        getDefaultEventEnd: function(allDay, zonedStart) {
            var end = zonedStart.clone();

            if (allDay) {
                end.stripTime().add(this.defaultAllDayEventDuration);
            }
            else {
                end.add(this.defaultTimedEventDuration);
            }

            if (this.getIsAmbigTimezone()) {
                end.stripZone(); // we don't know what the tzo should be
            }

            return end;
        }

    });

    ;;

    Calendar.mixin({

        viewSpecCache: null, // cache of view definitions (initialized in Calendar.js)


        // Gets information about how to create a view. Will use a cache.
        getViewSpec: function(viewType) {
            var cache = this.viewSpecCache;

            return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
        },


        // Given a duration singular unit, like "week" or "day", finds a matching view spec.
        // Preference is given to views that have corresponding buttons.
        getUnitViewSpec: function(unit) {
            var viewTypes;
            var i;
            var spec;

            if ($.inArray(unit, unitsDesc) != -1) {

                // put views that have buttons first. there will be duplicates, but oh well
                viewTypes = this.header.getViewsWithButtons(); // TODO: include footer as well?
                $.each(FC.views, function(viewType) { // all views
                    viewTypes.push(viewType);
                });

                for (i = 0; i < viewTypes.length; i++) {
                    spec = this.getViewSpec(viewTypes[i]);
                    if (spec) {
                        if (spec.singleUnit == unit) {
                            return spec;
                        }
                    }
                }
            }
        },


        // Builds an object with information on how to create a given view
        buildViewSpec: function(requestedViewType) {
            var viewOverrides = this.overrides.views || {};
            var specChain = []; // for the view. lowest to highest priority
            var defaultsChain = []; // for the view. lowest to highest priority
            var overridesChain = []; // for the view. lowest to highest priority
            var viewType = requestedViewType;
            var spec; // for the view
            var overrides; // for the view
            var durationInput;
            var duration;
            var unit;

            // iterate from the specific view definition to a more general one until we hit an actual View class
            while (viewType) {
                spec = fcViews[viewType];
                overrides = viewOverrides[viewType];
                viewType = null; // clear. might repopulate for another iteration

                if (typeof spec === 'function') { // TODO: deprecate
                    spec = { 'class': spec };
                }

                if (spec) {
                    specChain.unshift(spec);
                    defaultsChain.unshift(spec.defaults || {});
                    durationInput = durationInput || spec.duration;
                    viewType = viewType || spec.type;
                }

                if (overrides) {
                    overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
                    durationInput = durationInput || overrides.duration;
                    viewType = viewType || overrides.type;
                }
            }

            spec = mergeProps(specChain);
            spec.type = requestedViewType;
            if (!spec['class']) {
                return false;
            }

            // fall back to top-level `duration` option
            durationInput = durationInput ||
                this.dynamicOverrides.duration ||
                this.overrides.duration;

            if (durationInput) {
                duration = moment.duration(durationInput);

                if (duration.valueOf()) { // valid?

                    unit = computeDurationGreatestUnit(duration, durationInput);

                    spec.duration = duration;
                    spec.durationUnit = unit;

                    // view is a single-unit duration, like "week" or "day"
                    // incorporate options for this. lowest priority
                    if (duration.as(unit) === 1) {
                        spec.singleUnit = unit;
                        overridesChain.unshift(viewOverrides[unit] || {});
                    }
                }
            }

            spec.defaults = mergeOptions(defaultsChain);
            spec.overrides = mergeOptions(overridesChain);

            this.buildViewSpecOptions(spec);
            this.buildViewSpecButtonText(spec, requestedViewType);

            return spec;
        },


        // Builds and assigns a view spec's options object from its already-assigned defaults and overrides
        buildViewSpecOptions: function(spec) {
            spec.options = mergeOptions([ // lowest to highest priority
                Calendar.defaults, // global defaults
                spec.defaults, // view's defaults (from ViewSubclass.defaults)
                this.dirDefaults,
                this.localeDefaults, // locale and dir take precedence over view's defaults!
                this.overrides, // calendar's overrides (options given to constructor)
                spec.overrides, // view's overrides (view-specific options)
                this.dynamicOverrides // dynamically set via setter. highest precedence
            ]);
            populateInstanceComputableOptions(spec.options);
        },


        // Computes and assigns a view spec's buttonText-related options
        buildViewSpecButtonText: function(spec, requestedViewType) {

            // given an options object with a possible `buttonText` hash, lookup the buttonText for the
            // requested view, falling back to a generic unit entry like "week" or "day"
            function queryButtonText(options) {
                var buttonText = options.buttonText || {};
                return buttonText[requestedViewType] ||
                    // view can decide to look up a certain key
                    (spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||
                    // a key like "month"
                    (spec.singleUnit ? buttonText[spec.singleUnit] : null);
            }

            // highest to lowest priority
            spec.buttonTextOverride =
                queryButtonText(this.dynamicOverrides) ||
                queryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence
                spec.overrides.buttonText; // `buttonText` for view-specific options is a string

            // highest to lowest priority. mirrors buildViewSpecOptions
            spec.buttonTextDefault =
                queryButtonText(this.localeDefaults) ||
                queryButtonText(this.dirDefaults) ||
                spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
                queryButtonText(Calendar.defaults) ||
                (spec.duration ? this.humanizeDuration(spec.duration) : null) || // like "3 days"
                requestedViewType; // fall back to given view name
        }

    });

    ;;

    Calendar.mixin({

        el: null,
        contentEl: null,
        suggestedViewHeight: null,
        windowResizeProxy: null,
        ignoreWindowResize: 0,


        render: function() {
            if (!this.contentEl) {
                this.initialRender();
            }
            else if (this.elementVisible()) {
                // mainly for the public API
                this.calcSize();
                this.renderView();
            }
        },


        initialRender: function() {
            var _this = this;
            var el = this.el;

            el.addClass('fc');

            // event delegation for nav links
            el.on('click.fc', 'a[data-goto]', function(ev) {
                var anchorEl = $(this);
                var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON
                var date = _this.moment(gotoOptions.date);
                var viewType = gotoOptions.type;

                // property like "navLinkDayClick". might be a string or a function
                var customAction = _this.view.opt('navLink' + capitaliseFirstLetter(viewType) + 'Click');

                if (typeof customAction === 'function') {
                    customAction(date, ev);
                }
                else {
                    if (typeof customAction === 'string') {
                        viewType = customAction;
                    }
                    _this.zoomTo(date, viewType);
                }
            });

            // called immediately, and upon option change
            this.optionsModel.watch('applyingThemeClasses', [ '?theme' ], function(opts) {
                el.toggleClass('ui-widget', opts.theme);
                el.toggleClass('fc-unthemed', !opts.theme);
            });

            // called immediately, and upon option change.
            // HACK: locale often affects isRTL, so we explicitly listen to that too.
            this.optionsModel.watch('applyingDirClasses', [ '?isRTL', '?locale' ], function(opts) {
                el.toggleClass('fc-ltr', !opts.isRTL);
                el.toggleClass('fc-rtl', opts.isRTL);
            });

            this.contentEl = $("<div class='fc-view-container'/>").prependTo(el);

            this.initToolbars();
            this.renderHeader();
            this.renderFooter();
            this.renderView(this.opt('defaultView'));

            if (this.opt('handleWindowResize')) {
                $(window).resize(
                    this.windowResizeProxy = debounce( // prevents rapid calls
                        this.windowResize.bind(this),
                        this.opt('windowResizeDelay')
                    )
                );
            }
        },


        destroy: function() {

            if (this.view) {
                this.view.removeElement();

                // NOTE: don't null-out this.view in case API methods are called after destroy.
                // It is still the "current" view, just not rendered.
            }

            this.toolbarsManager.proxyCall('removeElement');
            this.contentEl.remove();
            this.el.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');

            this.el.off('.fc'); // unbind nav link handlers

            if (this.windowResizeProxy) {
                $(window).unbind('resize', this.windowResizeProxy);
                this.windowResizeProxy = null;
            }

            GlobalEmitter.unneeded();
        },


        elementVisible: function() {
            return this.el.is(':visible');
        },



        // View Rendering
        // -----------------------------------------------------------------------------------


        // Renders a view because of a date change, view-type change, or for the first time.
        // If not given a viewType, keep the current view but render different dates.
        // Accepts an optional scroll state to restore to.
        renderView: function(viewType, forcedScroll) {

            this.ignoreWindowResize++;

            var needsClearView = this.view && viewType && this.view.type !== viewType;

            // if viewType is changing, remove the old view's rendering
            if (needsClearView) {
                this.freezeContentHeight(); // prevent a scroll jump when view element is removed
                this.clearView();
            }

            // if viewType changed, or the view was never created, create a fresh view
            if (!this.view && viewType) {
                this.view =
                    this.viewsByType[viewType] ||
                    (this.viewsByType[viewType] = this.instantiateView(viewType));

                this.view.setElement(
                    $("<div class='fc-view fc-" + viewType + "-view' />").appendTo(this.contentEl)
                );
                this.toolbarsManager.proxyCall('activateButton', viewType);
            }

            if (this.view) {

                if (forcedScroll) {
                    this.view.addForcedScroll(forcedScroll);
                }

                if (this.elementVisible()) {
                    this.currentDate = this.view.setDate(this.currentDate);
                }
            }

            if (needsClearView) {
                this.thawContentHeight();
            }

            this.ignoreWindowResize--;
        },


        // Unrenders the current view and reflects this change in the Header.
        // Unregsiters the `view`, but does not remove from viewByType hash.
        clearView: function() {
            this.toolbarsManager.proxyCall('deactivateButton', this.view.type);
            this.view.removeElement();
            this.view = null;
        },


        // Destroys the view, including the view object. Then, re-instantiates it and renders it.
        // Maintains the same scroll state.
        // TODO: maintain any other user-manipulated state.
        reinitView: function() {
            this.ignoreWindowResize++;
            this.freezeContentHeight();

            var viewType = this.view.type;
            var scrollState = this.view.queryScroll();
            this.clearView();
            this.calcSize();
            this.renderView(viewType, scrollState);

            this.thawContentHeight();
            this.ignoreWindowResize--;
        },


        // Resizing
        // -----------------------------------------------------------------------------------


        getSuggestedViewHeight: function() {
            if (this.suggestedViewHeight === null) {
                this.calcSize();
            }
            return this.suggestedViewHeight;
        },


        isHeightAuto: function() {
            return this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';
        },


        updateSize: function(shouldRecalc) {
            if (this.elementVisible()) {

                if (shouldRecalc) {
                    this._calcSize();
                }

                this.ignoreWindowResize++;
                this.view.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()
                this.ignoreWindowResize--;

                return true; // signal success
            }
        },


        calcSize: function() {
            if (this.elementVisible()) {
                this._calcSize();
            }
        },


        _calcSize: function() { // assumes elementVisible
            var contentHeightInput = this.opt('contentHeight');
            var heightInput = this.opt('height');

            if (typeof contentHeightInput === 'number') { // exists and not 'auto'
                this.suggestedViewHeight = contentHeightInput;
            }
            else if (typeof contentHeightInput === 'function') { // exists and is a function
                this.suggestedViewHeight = contentHeightInput();
            }
            else if (typeof heightInput === 'number') { // exists and not 'auto'
                this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();
            }
            else if (typeof heightInput === 'function') { // exists and is a function
                this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();
            }
            else if (heightInput === 'parent') { // set to height of parent element
                this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();
            }
            else {
                this.suggestedViewHeight = Math.round(
                    this.contentEl.width() /
                    Math.max(this.opt('aspectRatio'), .5)
                );
            }
        },


        windowResize: function(ev) {
            if (
                !this.ignoreWindowResize &&
                ev.target === window && // so we don't process jqui "resize" events that have bubbled up
                this.view.renderRange // view has already been rendered
            ) {
                if (this.updateSize(true)) {
                    this.view.publiclyTrigger('windowResize', this.el[0]);
                }
            }
        },


        /* Height "Freezing"
         -----------------------------------------------------------------------------*/


        freezeContentHeight: function() {
            this.contentEl.css({
                width: '100%',
                height: this.contentEl.height(),
                overflow: 'hidden'
            });
        },


        thawContentHeight: function() {
            this.contentEl.css({
                width: '',
                height: '',
                overflow: ''
            });
        }

    });

    ;;

    Calendar.mixin({

        header: null,
        footer: null,
        toolbarsManager: null,


        initToolbars: function() {
            this.header = new Toolbar(this, this.computeHeaderOptions());
            this.footer = new Toolbar(this, this.computeFooterOptions());
            this.toolbarsManager = new Iterator([ this.header, this.footer ]);
        },


        computeHeaderOptions: function() {
            return {
                extraClasses: 'fc-header-toolbar',
                layout: this.opt('header')
            };
        },


        computeFooterOptions: function() {
            return {
                extraClasses: 'fc-footer-toolbar',
                layout: this.opt('footer')
            };
        },


        // can be called repeatedly and Header will rerender
        renderHeader: function() {
            var header = this.header;

            header.setToolbarOptions(this.computeHeaderOptions());
            header.render();

            if (header.el) {
                this.el.prepend(header.el);
            }
        },


        // can be called repeatedly and Footer will rerender
        renderFooter: function() {
            var footer = this.footer;

            footer.setToolbarOptions(this.computeFooterOptions());
            footer.render();

            if (footer.el) {
                this.el.append(footer.el);
            }
        },


        setToolbarsTitle: function(title) {
            this.toolbarsManager.proxyCall('updateTitle', title);
        },


        updateToolbarButtons: function() {
            var now = this.getNow();
            var view = this.view;
            var todayInfo = view.buildDateProfile(now);
            var prevInfo = view.buildPrevDateProfile(this.currentDate);
            var nextInfo = view.buildNextDateProfile(this.currentDate);

            this.toolbarsManager.proxyCall(
                (todayInfo.isValid && !isDateWithinRange(now, view.currentRange)) ?
                    'enableButton' :
                    'disableButton',
                'today'
            );

            this.toolbarsManager.proxyCall(
                prevInfo.isValid ?
                    'enableButton' :
                    'disableButton',
                'prev'
            );

            this.toolbarsManager.proxyCall(
                nextInfo.isValid ?
                    'enableButton' :
                    'disableButton',
                'next'
            );
        },


        queryToolbarsHeight: function() {
            return this.toolbarsManager.items.reduce(function(accumulator, toolbar) {
                var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin
                return accumulator + toolbarHeight;
            }, 0);
        }

    });

    ;;

    Calendar.defaults = {

        titleRangeSeparator: ' \u2013 ', // en dash
        monthYearFormat: 'MMMM YYYY', // required for en. other locales rely on datepicker computable option

        defaultTimedEventDuration: '02:00:00',
        defaultAllDayEventDuration: { days: 1 },
        forceEventDuration: false,
        nextDayThreshold: '09:00:00', // 9am

        // display
        defaultView: 'month',
        aspectRatio: 1.35,
        header: {
            left: 'title',
            center: '',
            right: 'today prev,next'
        },
        weekends: true,
        weekNumbers: false,

        weekNumberTitle: 'W',
        weekNumberCalculation: 'local',

        //editable: false,

        //nowIndicator: false,

        scrollTime: '06:00:00',
        minTime: '00:00:00',
        maxTime: '24:00:00',
        showNonCurrentDates: true,

        // event ajax
        lazyFetching: true,
        startParam: 'start',
        endParam: 'end',
        timezoneParam: 'timezone',

        timezone: false,

        //allDayDefault: undefined,

        // locale
        isRTL: false,
        buttonText: {
            prev: "prev",
            next: "next",
            prevYear: "prev year",
            nextYear: "next year",
            year: 'year', // TODO: locale files need to specify this
            today: 'today',
            month: 'month',
            week: 'week',
            day: 'day'
        },

        buttonIcons: {
            prev: 'left-single-arrow',
            next: 'right-single-arrow',
            prevYear: 'left-double-arrow',
            nextYear: 'right-double-arrow'
        },

        allDayText: 'all-day',

        // jquery-ui theming
        theme: false,
        themeButtonIcons: {
            prev: 'circle-triangle-w',
            next: 'circle-triangle-e',
            prevYear: 'seek-prev',
            nextYear: 'seek-next'
        },

        //eventResizableFromStart: false,
        dragOpacity: .75,
        dragRevertDuration: 500,
        dragScroll: true,

        //selectable: false,
        unselectAuto: true,
        //selectMinDistance: 0,

        dropAccept: '*',

        eventOrder: 'title',
        //eventRenderWait: null,

        eventLimit: false,
        eventLimitText: 'more',
        eventLimitClick: 'popover',
        dayPopoverFormat: 'LL',

        handleWindowResize: true,
        windowResizeDelay: 100, // milliseconds before an updateSize happens

        longPressDelay: 1000

    };


    Calendar.englishDefaults = { // used by locale.js
        dayPopoverFormat: 'dddd, MMMM D'
    };


    Calendar.rtlDefaults = { // right-to-left defaults
        header: { // TODO: smarter solution (first/center/last ?)
            left: 'next,prev today',
            center: '',
            right: 'title'
        },
        buttonIcons: {
            prev: 'right-single-arrow',
            next: 'left-single-arrow',
            prevYear: 'right-double-arrow',
            nextYear: 'left-double-arrow'
        },
        themeButtonIcons: {
            prev: 'circle-triangle-e',
            next: 'circle-triangle-w',
            nextYear: 'seek-prev',
            prevYear: 'seek-next'
        }
    };

    ;;

    var localeOptionHash = FC.locales = {}; // initialize and expose


// TODO: document the structure and ordering of a FullCalendar locale file


// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default locales for datepicker.
    FC.datepickerLocale = function(localeCode, dpLocaleCode, dpOptions) {

        // get the FullCalendar internal option hash for this locale. create if necessary
        var fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});

        // transfer some simple options from datepicker to fc
        fcOptions.isRTL = dpOptions.isRTL;
        fcOptions.weekNumberTitle = dpOptions.weekHeader;

        // compute some more complex options from datepicker
        $.each(dpComputableOptions, function(name, func) {
            fcOptions[name] = func(dpOptions);
        });

        // is jQuery UI Datepicker is on the page?
        if ($.datepicker) {

            // Register the locale data.
            // FullCalendar and MomentJS use locale codes like "pt-br" but Datepicker
            // does it like "pt-BR" or if it doesn't have the locale, maybe just "pt".
            // Make an alias so the locale can be referenced either way.
            $.datepicker.regional[dpLocaleCode] =
                $.datepicker.regional[localeCode] = // alias
                    dpOptions;

            // Alias 'en' to the default locale data. Do this every time.
            $.datepicker.regional.en = $.datepicker.regional[''];

            // Set as Datepicker's global defaults.
            $.datepicker.setDefaults(dpOptions);
        }
    };


// Sets FullCalendar-specific translations. Will set the locales as the global default.
    FC.locale = function(localeCode, newFcOptions) {
        var fcOptions;
        var momOptions;

        // get the FullCalendar internal option hash for this locale. create if necessary
        fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});

        // provided new options for this locales? merge them in
        if (newFcOptions) {
            fcOptions = localeOptionHash[localeCode] = mergeOptions([ fcOptions, newFcOptions ]);
        }

        // compute locale options that weren't defined.
        // always do this. newFcOptions can be undefined when initializing from i18n file,
        // so no way to tell if this is an initialization or a default-setting.
        momOptions = getMomentLocaleData(localeCode); // will fall back to en
        $.each(momComputableOptions, function(name, func) {
            if (fcOptions[name] == null) {
                fcOptions[name] = func(momOptions, fcOptions);
            }
        });

        // set it as the default locale for FullCalendar
        Calendar.defaults.locale = localeCode;
    };


// NOTE: can't guarantee any of these computations will run because not every locale has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
    var dpComputableOptions = {

        buttonText: function(dpOptions) {
            return {
                // the translations sometimes wrongly contain HTML entities
                prev: stripHtmlEntities(dpOptions.prevText),
                next: stripHtmlEntities(dpOptions.nextText),
                today: stripHtmlEntities(dpOptions.currentText)
            };
        },

        // Produces format strings like "MMMM YYYY" -> "September 2014"
        monthYearFormat: function(dpOptions) {
            return dpOptions.showMonthAfterYear ?
                'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
                'MMMM YYYY[' + dpOptions.yearSuffix + ']';
        }

    };

    var momComputableOptions = {

        // Produces format strings like "ddd M/D" -> "Fri 9/15"
        dayOfMonthFormat: function(momOptions, fcOptions) {
            var format = momOptions.longDateFormat('l'); // for the format like "M/D/YYYY"

            // strip the year off the edge, as well as other misc non-whitespace chars
            format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');

            if (fcOptions.isRTL) {
                format += ' ddd'; // for RTL, add day-of-week to end
            }
            else {
                format = 'ddd ' + format; // for LTR, add day-of-week to beginning
            }
            return format;
        },

        // Produces format strings like "h:mma" -> "6:00pm"
        mediumTimeFormat: function(momOptions) { // can't be called `timeFormat` because collides with option
            return momOptions.longDateFormat('LT')
                .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
        },

        // Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
        smallTimeFormat: function(momOptions) {
            return momOptions.longDateFormat('LT')
                .replace(':mm', '(:mm)')
                .replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
                .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
        },

        // Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
        extraSmallTimeFormat: function(momOptions) {
            return momOptions.longDateFormat('LT')
                .replace(':mm', '(:mm)')
                .replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
                .replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
        },

        // Produces format strings like "ha" / "H" -> "6pm" / "18"
        hourFormat: function(momOptions) {
            return momOptions.longDateFormat('LT')
                .replace(':mm', '')
                .replace(/(\Wmm)$/, '') // like above, but for foreign locales
                .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
        },

        // Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
        noMeridiemTimeFormat: function(momOptions) {
            return momOptions.longDateFormat('LT')
                .replace(/\s*a$/i, ''); // remove trailing AM/PM
        }

    };


// options that should be computed off live calendar options (considers override options)
// TODO: best place for this? related to locale?
// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it
    var instanceComputableOptions = {

        // Produces format strings for results like "Mo 16"
        smallDayDateFormat: function(options) {
            return options.isRTL ?
                'D dd' :
                'dd D';
        },

        // Produces format strings for results like "Wk 5"
        weekFormat: function(options) {
            return options.isRTL ?
                'w[ ' + options.weekNumberTitle + ']' :
                '[' + options.weekNumberTitle + ' ]w';
        },

        // Produces format strings for results like "Wk5"
        smallWeekFormat: function(options) {
            return options.isRTL ?
                'w[' + options.weekNumberTitle + ']' :
                '[' + options.weekNumberTitle + ']w';
        }

    };

// TODO: make these computable properties in optionsModel
    function populateInstanceComputableOptions(options) {
        $.each(instanceComputableOptions, function(name, func) {
            if (options[name] == null) {
                options[name] = func(options);
            }
        });
    }


// Returns moment's internal locale data. If doesn't exist, returns English.
    function getMomentLocaleData(localeCode) {
        return moment.localeData(localeCode) || moment.localeData('en');
    }


// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
    FC.locale('en', Calendar.englishDefaults);

    ;;

    FC.sourceNormalizers = [];
    FC.sourceFetchers = [];

    var ajaxDefaults = {
        dataType: 'json',
        cache: false
    };

    var eventGUID = 1;


    function EventManager() { // assumed to be a calendar
        var t = this;


        // exports
        t.requestEvents = requestEvents;
        t.reportEventChange = reportEventChange;
        t.isFetchNeeded = isFetchNeeded;
        t.fetchEvents = fetchEvents;
        t.fetchEventSources = fetchEventSources;
        t.refetchEvents = refetchEvents;
        t.refetchEventSources = refetchEventSources;
        t.getEventSources = getEventSources;
        t.getEventSourceById = getEventSourceById;
        t.addEventSource = addEventSource;
        t.removeEventSource = removeEventSource;
        t.removeEventSources = removeEventSources;
        t.updateEvent = updateEvent;
        t.updateEvents = updateEvents;
        t.renderEvent = renderEvent;
        t.renderEvents = renderEvents;
        t.removeEvents = removeEvents;
        t.clientEvents = clientEvents;
        t.mutateEvent = mutateEvent;
        t.normalizeEventDates = normalizeEventDates;
        t.normalizeEventTimes = normalizeEventTimes;


        // locals
        var stickySource = { events: [] };
        var sources = [ stickySource ];
        var rangeStart, rangeEnd;
        var pendingSourceCnt = 0; // outstanding fetch requests, max one per source
        var cache = []; // holds events that have already been expanded
        var prunedCache; // like cache, but only events that intersect with rangeStart/rangeEnd


        $.each(
            (t.opt('events') ? [ t.opt('events') ] : []).concat(t.opt('eventSources') || []),
            function(i, sourceInput) {
                var source = buildEventSource(sourceInput);
                if (source) {
                    sources.push(source);
                }
            }
        );



        function requestEvents(start, end) {
            if (!t.opt('lazyFetching') || isFetchNeeded(start, end)) {
                return fetchEvents(start, end);
            }
            else {
                return Promise.resolve(prunedCache);
            }
        }


        function reportEventChange() {
            prunedCache = filterEventsWithinRange(cache);
            t.trigger('eventsReset', prunedCache);
        }


        function filterEventsWithinRange(events) {
            var filteredEvents = [];
            var i, event;

            for (i = 0; i < events.length; i++) {
                event = events[i];

                if (
                    event.start.clone().stripZone() < rangeEnd &&
                    t.getEventEnd(event).stripZone() > rangeStart
                ) {
                    filteredEvents.push(event);
                }
            }

            return filteredEvents;
        }


        t.getEventCache = function() {
            return cache;
        };



        /* Fetching
         -----------------------------------------------------------------------------*/


        // start and end are assumed to be unzoned
        function isFetchNeeded(start, end) {
            return !rangeStart || // nothing has been fetched yet?
                start < rangeStart || end > rangeEnd; // is part of the new range outside of the old range?
        }


        function fetchEvents(start, end) {
            rangeStart = start;
            rangeEnd = end;
            return refetchEvents();
        }


        // poorly named. fetches all sources with current `rangeStart` and `rangeEnd`.
        function refetchEvents() {
            return fetchEventSources(sources, 'reset');
        }


        // poorly named. fetches a subset of event sources.
        function refetchEventSources(matchInputs) {
            return fetchEventSources(getEventSourcesByMatchArray(matchInputs));
        }


        // expects an array of event source objects (the originals, not copies)
        // `specialFetchType` is an optimization parameter that affects purging of the event cache.
        function fetchEventSources(specificSources, specialFetchType) {
            var i, source;

            if (specialFetchType === 'reset') {
                cache = [];
            }
            else if (specialFetchType !== 'add') {
                cache = excludeEventsBySources(cache, specificSources);
            }

            for (i = 0; i < specificSources.length; i++) {
                source = specificSources[i];

                // already-pending sources have already been accounted for in pendingSourceCnt
                if (source._status !== 'pending') {
                    pendingSourceCnt++;
                }

                source._fetchId = (source._fetchId || 0) + 1;
                source._status = 'pending';
            }

            for (i = 0; i < specificSources.length; i++) {
                source = specificSources[i];
                tryFetchEventSource(source, source._fetchId);
            }

            if (pendingSourceCnt) {
                return Promise.construct(function(resolve) {
                    t.one('eventsReceived', resolve); // will send prunedCache
                });
            }
            else { // executed all synchronously, or no sources at all
                return Promise.resolve(prunedCache);
            }
        }


        // fetches an event source and processes its result ONLY if it is still the current fetch.
        // caller is responsible for incrementing pendingSourceCnt first.
        function tryFetchEventSource(source, fetchId) {
            _fetchEventSource(source, function(eventInputs) {
                var isArraySource = $.isArray(source.events);
                var i, eventInput;
                var abstractEvent;

                if (
                    // is this the source's most recent fetch?
                // if not, rely on an upcoming fetch of this source to decrement pendingSourceCnt
                fetchId === source._fetchId &&
                // event source no longer valid?
                source._status !== 'rejected'
                ) {
                    source._status = 'resolved';

                    if (eventInputs) {
                        for (i = 0; i < eventInputs.length; i++) {
                            eventInput = eventInputs[i];

                            if (isArraySource) { // array sources have already been convert to Event Objects
                                abstractEvent = eventInput;
                            }
                            else {
                                abstractEvent = buildEventFromInput(eventInput, source);
                            }

                            if (abstractEvent) { // not false (an invalid event)
                                cache.push.apply( // append
                                    cache,
                                    expandEvent(abstractEvent) // add individual expanded events to the cache
                                );
                            }
                        }
                    }

                    decrementPendingSourceCnt();
                }
            });
        }


        function rejectEventSource(source) {
            var wasPending = source._status === 'pending';

            source._status = 'rejected';

            if (wasPending) {
                decrementPendingSourceCnt();
            }
        }


        function decrementPendingSourceCnt() {
            pendingSourceCnt--;
            if (!pendingSourceCnt) {
                reportEventChange(cache); // updates prunedCache
                t.trigger('eventsReceived', prunedCache);
            }
        }


        function _fetchEventSource(source, callback) {
            var i;
            var fetchers = FC.sourceFetchers;
            var res;

            for (i=0; i<fetchers.length; i++) {
                res = fetchers[i].call(
                    t, // this, the Calendar object
                    source,
                    rangeStart.clone(),
                    rangeEnd.clone(),
                    t.opt('timezone'),
                    callback
                );

                if (res === true) {
                    // the fetcher is in charge. made its own async request
                    return;
                }
                else if (typeof res == 'object') {
                    // the fetcher returned a new source. process it
                    _fetchEventSource(res, callback);
                    return;
                }
            }

            var events = source.events;
            if (events) {
                if ($.isFunction(events)) {
                    t.pushLoading();
                    events.call(
                        t, // this, the Calendar object
                        rangeStart.clone(),
                        rangeEnd.clone(),
                        t.opt('timezone'),
                        function(events) {
                            callback(events);
                            t.popLoading();
                        }
                    );
                }
                else if ($.isArray(events)) {
                    callback(events);
                }
                else {
                    callback();
                }
            }else{
                var url = source.url;
                if (url) {
                    var success = source.success;
                    var error = source.error;
                    var complete = source.complete;

                    // retrieve any outbound GET/POST $.ajax data from the options
                    var customData;
                    if ($.isFunction(source.data)) {
                        // supplied as a function that returns a key/value object
                        customData = source.data();
                    }
                    else {
                        // supplied as a straight key/value object
                        customData = source.data;
                    }

                    // use a copy of the custom data so we can modify the parameters
                    // and not affect the passed-in object.
                    var data = $.extend({}, customData || {});

                    var startParam = firstDefined(source.startParam, t.opt('startParam'));
                    var endParam = firstDefined(source.endParam, t.opt('endParam'));
                    var timezoneParam = firstDefined(source.timezoneParam, t.opt('timezoneParam'));

                    if (startParam) {
                        data[startParam] = rangeStart.format();
                    }
                    if (endParam) {
                        data[endParam] = rangeEnd.format();
                    }
                    if (t.opt('timezone') && t.opt('timezone') != 'local') {
                        data[timezoneParam] = t.opt('timezone');
                    }

                    t.pushLoading();
                    $.ajax($.extend({}, ajaxDefaults, source, {
                        data: data,
                        success: function(events) {
                            events = events || [];
                            var res = applyAll(success, this, arguments);
                            if ($.isArray(res)) {
                                events = res;
                            }
                            callback(events);
                        },
                        error: function() {
                            applyAll(error, this, arguments);
                            callback();
                        },
                        complete: function() {
                            applyAll(complete, this, arguments);
                            t.popLoading();
                        }
                    }));
                }else{
                    callback();
                }
            }
        }



        /* Sources
         -----------------------------------------------------------------------------*/


        function addEventSource(sourceInput) {
            var source = buildEventSource(sourceInput);
            if (source) {
                sources.push(source);
                fetchEventSources([ source ], 'add'); // will eventually call reportEventChange
            }
        }


        function buildEventSource(sourceInput) { // will return undefined if invalid source
            var normalizers = FC.sourceNormalizers;
            var source;
            var i;

            if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {
                source = { events: sourceInput };
            }
            else if (typeof sourceInput === 'string') {
                source = { url: sourceInput };
            }
            else if (typeof sourceInput === 'object') {
                source = $.extend({}, sourceInput); // shallow copy
            }

            if (source) {

                // TODO: repeat code, same code for event classNames
                if (source.className) {
                    if (typeof source.className === 'string') {
                        source.className = source.className.split(/\s+/);
                    }
                    // otherwise, assumed to be an array
                }
                else {
                    source.className = [];
                }

                // for array sources, we convert to standard Event Objects up front
                if ($.isArray(source.events)) {
                    source.origArray = source.events; // for removeEventSource
                    source.events = $.map(source.events, function(eventInput) {
                        return buildEventFromInput(eventInput, source);
                    });
                }

                for (i=0; i<normalizers.length; i++) {
                    normalizers[i].call(t, source);
                }

                return source;
            }
        }


        function removeEventSource(matchInput) {
            removeSpecificEventSources(
                getEventSourcesByMatch(matchInput)
            );
        }


        // if called with no arguments, removes all.
        function removeEventSources(matchInputs) {
            if (matchInputs == null) {
                removeSpecificEventSources(sources, true); // isAll=true
            }
            else {
                removeSpecificEventSources(
                    getEventSourcesByMatchArray(matchInputs)
                );
            }
        }


        function removeSpecificEventSources(targetSources, isAll) {
            var i;

            // cancel pending requests
            for (i = 0; i < targetSources.length; i++) {
                rejectEventSource(targetSources[i]);
            }

            if (isAll) { // an optimization
                sources = [];
                cache = [];
            }
            else {
                // remove from persisted source list
                sources = $.grep(sources, function(source) {
                    for (i = 0; i < targetSources.length; i++) {
                        if (source === targetSources[i]) {
                            return false; // exclude
                        }
                    }
                    return true; // include
                });

                cache = excludeEventsBySources(cache, targetSources);
            }

            reportEventChange();
        }


        function getEventSources() {
            return sources.slice(1); // returns a shallow copy of sources with stickySource removed
        }


        function getEventSourceById(id) {
            return $.grep(sources, function(source) {
                return source.id && source.id === id;
            })[0];
        }


        // like getEventSourcesByMatch, but accepts multple match criteria (like multiple IDs)
        function getEventSourcesByMatchArray(matchInputs) {

            // coerce into an array
            if (!matchInputs) {
                matchInputs = [];
            }
            else if (!$.isArray(matchInputs)) {
                matchInputs = [ matchInputs ];
            }

            var matchingSources = [];
            var i;

            // resolve raw inputs to real event source objects
            for (i = 0; i < matchInputs.length; i++) {
                matchingSources.push.apply( // append
                    matchingSources,
                    getEventSourcesByMatch(matchInputs[i])
                );
            }

            return matchingSources;
        }


        // matchInput can either by a real event source object, an ID, or the function/URL for the source.
        // returns an array of matching source objects.
        function getEventSourcesByMatch(matchInput) {
            var i, source;

            // given an proper event source object
            for (i = 0; i < sources.length; i++) {
                source = sources[i];
                if (source === matchInput) {
                    return [ source ];
                }
            }

            // an ID match
            source = getEventSourceById(matchInput);
            if (source) {
                return [ source ];
            }

            return $.grep(sources, function(source) {
                return isSourcesEquivalent(matchInput, source);
            });
        }


        function isSourcesEquivalent(source1, source2) {
            return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
        }


        function getSourcePrimitive(source) {
            return (
                    (typeof source === 'object') ? // a normalized event source?
                        (source.origArray || source.googleCalendarId || source.url || source.events) : // get the primitive
                        null
                ) ||
                source; // the given argument *is* the primitive
        }


        // util
        // returns a filtered array without events that are part of any of the given sources
        function excludeEventsBySources(specificEvents, specificSources) {
            return $.grep(specificEvents, function(event) {
                for (var i = 0; i < specificSources.length; i++) {
                    if (event.source === specificSources[i]) {
                        return false; // exclude
                    }
                }
                return true; // keep
            });
        }



        /* Manipulation
         -----------------------------------------------------------------------------*/


        // Only ever called from the externally-facing API
        function updateEvent(event) {
            updateEvents([ event ]);
        }


        // Only ever called from the externally-facing API
        function updateEvents(events) {
            var i, event;

            for (i = 0; i < events.length; i++) {
                event = events[i];

                // massage start/end values, even if date string values
                event.start = t.moment(event.start);
                if (event.end) {
                    event.end = t.moment(event.end);
                }
                else {
                    event.end = null;
                }

                mutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization
            }

            reportEventChange(); // reports event modifications (so we can redraw)
        }


        // Returns a hash of misc event properties that should be copied over to related events.
        function getMiscEventProps(event) {
            var props = {};

            $.each(event, function(name, val) {
                if (isMiscEventPropName(name)) {
                    if (val !== undefined && isAtomic(val)) { // a defined non-object
                        props[name] = val;
                    }
                }
            });

            return props;
        }

        // non-date-related, non-id-related, non-secret
        function isMiscEventPropName(name) {
            return !/^_|^(id|allDay|start|end)$/.test(name);
        }


        // returns the expanded events that were created
        function renderEvent(eventInput, stick) {
            return renderEvents([ eventInput ], stick);
        }


        // returns the expanded events that were created
        function renderEvents(eventInputs, stick) {
            var renderedEvents = [];
            var renderableEvents;
            var abstractEvent;
            var i, j, event;

            for (i = 0; i < eventInputs.length; i++) {
                abstractEvent = buildEventFromInput(eventInputs[i]);

                if (abstractEvent) { // not false (a valid input)
                    renderableEvents = expandEvent(abstractEvent);

                    for (j = 0; j < renderableEvents.length; j++) {
                        event = renderableEvents[j];

                        if (!event.source) {
                            if (stick) {
                                stickySource.events.push(event);
                                event.source = stickySource;
                            }
                            cache.push(event);
                        }
                    }

                    renderedEvents = renderedEvents.concat(renderableEvents);
                }
            }

            if (renderedEvents.length) { // any new events rendered?
                reportEventChange();
            }

            return renderedEvents;
        }


        function removeEvents(filter) {
            var eventID;
            var i;

            if (filter == null) { // null or undefined. remove all events
                filter = function() { return true; }; // will always match
            }
            else if (!$.isFunction(filter)) { // an event ID
                eventID = filter + '';
                filter = function(event) {
                    return event._id == eventID;
                };
            }

            // Purge event(s) from our local cache
            cache = $.grep(cache, filter, true); // inverse=true

            // Remove events from array sources.
            // This works because they have been converted to official Event Objects up front.
            // (and as a result, event._id has been calculated).
            for (i=0; i<sources.length; i++) {
                if ($.isArray(sources[i].events)) {
                    sources[i].events = $.grep(sources[i].events, filter, true);
                }
            }

            reportEventChange();
        }


        function clientEvents(filter) {
            if ($.isFunction(filter)) {
                return $.grep(cache, filter);
            }
            else if (filter != null) { // not null, not undefined. an event ID
                filter += '';
                return $.grep(cache, function(e) {
                    return e._id == filter;
                });
            }
            return cache; // else, return all
        }


        // Makes sure all array event sources have their internal event objects
        // converted over to the Calendar's current timezone.
        t.rezoneArrayEventSources = function() {
            var i;
            var events;
            var j;

            for (i = 0; i < sources.length; i++) {
                events = sources[i].events;
                if ($.isArray(events)) {

                    for (j = 0; j < events.length; j++) {
                        rezoneEventDates(events[j]);
                    }
                }
            }
        };

        function rezoneEventDates(event) {
            event.start = t.moment(event.start);
            if (event.end) {
                event.end = t.moment(event.end);
            }
            backupEventDates(event);
        }


        /* Event Normalization
         -----------------------------------------------------------------------------*/


        // Given a raw object with key/value properties, returns an "abstract" Event object.
        // An "abstract" event is an event that, if recurring, will not have been expanded yet.
        // Will return `false` when input is invalid.
        // `source` is optional
        function buildEventFromInput(input, source) {
            var calendarEventDataTransform = t.opt('eventDataTransform');
            var out = {};
            var start, end;
            var allDay;

            if (calendarEventDataTransform) {
                input = calendarEventDataTransform(input);
            }
            if (source && source.eventDataTransform) {
                input = source.eventDataTransform(input);
            }

            // Copy all properties over to the resulting object.
            // The special-case properties will be copied over afterwards.
            $.extend(out, input);

            if (source) {
                out.source = source;
            }

            out._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');

            if (input.className) {
                if (typeof input.className == 'string') {
                    out.className = input.className.split(/\s+/);
                }
                else { // assumed to be an array
                    out.className = input.className;
                }
            }
            else {
                out.className = [];
            }

            start = input.start || input.date; // "date" is an alias for "start"
            end = input.end;

            // parse as a time (Duration) if applicable
            if (isTimeString(start)) {
                start = moment.duration(start);
            }
            if (isTimeString(end)) {
                end = moment.duration(end);
            }

            if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {

                // the event is "abstract" (recurring) so don't calculate exact start/end dates just yet
                out.start = start ? moment.duration(start) : null; // will be a Duration or null
                out.end = end ? moment.duration(end) : null; // will be a Duration or null
                out._recurring = true; // our internal marker
            }
            else {

                if (start) {
                    start = t.moment(start);
                    if (!start.isValid()) {
                        return false;
                    }
                }

                if (end) {
                    end = t.moment(end);
                    if (!end.isValid()) {
                        end = null; // let defaults take over
                    }
                }

                allDay = input.allDay;
                if (allDay === undefined) { // still undefined? fallback to default
                    allDay = firstDefined(
                        source ? source.allDayDefault : undefined,
                        t.opt('allDayDefault')
                    );
                    // still undefined? normalizeEventDates will calculate it
                }

                assignDatesToEvent(start, end, allDay, out);
            }

            t.normalizeEvent(out); // hook for external use. a prototype method

            return out;
        }
        t.buildEventFromInput = buildEventFromInput;


        // Normalizes and assigns the given dates to the given partially-formed event object.
        // NOTE: mutates the given start/end moments. does not make a copy.
        function assignDatesToEvent(start, end, allDay, event) {
            event.start = start;
            event.end = end;
            event.allDay = allDay;
            normalizeEventDates(event);
            backupEventDates(event);
        }


        // Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.
        // NOTE: Will modify the given object.
        function normalizeEventDates(eventProps) {

            normalizeEventTimes(eventProps);

            if (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {
                eventProps.end = null;
            }

            if (!eventProps.end) {
                if (t.opt('forceEventDuration')) {
                    eventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);
                }
                else {
                    eventProps.end = null;
                }
            }
        }


        // Ensures the allDay property exists and the timeliness of the start/end dates are consistent
        function normalizeEventTimes(eventProps) {
            if (eventProps.allDay == null) {
                eventProps.allDay = !(eventProps.start.hasTime() || (eventProps.end && eventProps.end.hasTime()));
            }

            if (eventProps.allDay) {
                eventProps.start.stripTime();
                if (eventProps.end) {
                    // TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment
                    eventProps.end.stripTime();
                }
            }
            else {
                if (!eventProps.start.hasTime()) {
                    eventProps.start = t.applyTimezone(eventProps.start.time(0)); // will assign a 00:00 time
                }
                if (eventProps.end && !eventProps.end.hasTime()) {
                    eventProps.end = t.applyTimezone(eventProps.end.time(0)); // will assign a 00:00 time
                }
            }
        }


        // If the given event is a recurring event, break it down into an array of individual instances.
        // If not a recurring event, return an array with the single original event.
        // If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.
        // HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).
        function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {
            var events = [];
            var dowHash;
            var dow;
            var i;
            var date;
            var startTime, endTime;
            var start, end;
            var event;

            _rangeStart = _rangeStart || rangeStart;
            _rangeEnd = _rangeEnd || rangeEnd;

            if (abstractEvent) {
                if (abstractEvent._recurring) {

                    // make a boolean hash as to whether the event occurs on each day-of-week
                    if ((dow = abstractEvent.dow)) {
                        dowHash = {};
                        for (i = 0; i < dow.length; i++) {
                            dowHash[dow[i]] = true;
                        }
                    }

                    // iterate through every day in the current range
                    date = _rangeStart.clone().stripTime(); // holds the date of the current day
                    while (date.isBefore(_rangeEnd)) {

                        if (!dowHash || dowHash[date.day()]) { // if everyday, or this particular day-of-week

                            startTime = abstractEvent.start; // the stored start and end properties are times (Durations)
                            endTime = abstractEvent.end; // "
                            start = date.clone();
                            end = null;

                            if (startTime) {
                                start = start.time(startTime);
                            }
                            if (endTime) {
                                end = date.clone().time(endTime);
                            }

                            event = $.extend({}, abstractEvent); // make a copy of the original
                            assignDatesToEvent(
                                start, end,
                                !startTime && !endTime, // allDay?
                                event
                            );
                            events.push(event);
                        }

                        date.add(1, 'days');
                    }
                }
                else {
                    events.push(abstractEvent); // return the original event. will be a one-item array
                }
            }

            return events;
        }
        t.expandEvent = expandEvent;



        /* Event Modification Math
         -----------------------------------------------------------------------------------------*/


        // Modifies an event and all related events by applying the given properties.
        // Special date-diffing logic is used for manipulation of dates.
        // If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.
        // All date comparisons are done against the event's pristine _start and _end dates.
        // Returns an object with delta information and a function to undo all operations.
        // For making computations in a granularity greater than day/time, specify largeUnit.
        // NOTE: The given `newProps` might be mutated for normalization purposes.
        function mutateEvent(event, newProps, largeUnit) {
            var miscProps = {};
            var oldProps;
            var clearEnd;
            var startDelta;
            var endDelta;
            var durationDelta;
            var undoFunc;

            // diffs the dates in the appropriate way, returning a duration
            function diffDates(date1, date0) { // date1 - date0
                if (largeUnit) {
                    return diffByUnit(date1, date0, largeUnit);
                }
                else if (newProps.allDay) {
                    return diffDay(date1, date0);
                }
                else {
                    return diffDayTime(date1, date0);
                }
            }

            newProps = newProps || {};

            // normalize new date-related properties
            if (!newProps.start) {
                newProps.start = event.start.clone();
            }
            if (newProps.end === undefined) {
                newProps.end = event.end ? event.end.clone() : null;
            }
            if (newProps.allDay == null) { // is null or undefined?
                newProps.allDay = event.allDay;
            }
            normalizeEventDates(newProps);

            // create normalized versions of the original props to compare against
            // need a real end value, for diffing
            oldProps = {
                start: event._start.clone(),
                end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),
                allDay: newProps.allDay // normalize the dates in the same regard as the new properties
            };
            normalizeEventDates(oldProps);

            // need to clear the end date if explicitly changed to null
            clearEnd = event._end !== null && newProps.end === null;

            // compute the delta for moving the start date
            startDelta = diffDates(newProps.start, oldProps.start);

            // compute the delta for moving the end date
            if (newProps.end) {
                endDelta = diffDates(newProps.end, oldProps.end);
                durationDelta = endDelta.subtract(startDelta);
            }
            else {
                durationDelta = null;
            }

            // gather all non-date-related properties
            $.each(newProps, function(name, val) {
                if (isMiscEventPropName(name)) {
                    if (val !== undefined) {
                        miscProps[name] = val;
                    }
                }
            });

            // apply the operations to the event and all related events
            undoFunc = mutateEvents(
                clientEvents(event._id), // get events with this ID
                clearEnd,
                newProps.allDay,
                startDelta,
                durationDelta,
                miscProps
            );

            return {
                dateDelta: startDelta,
                durationDelta: durationDelta,
                undo: undoFunc
            };
        }


        // Modifies an array of events in the following ways (operations are in order):
        // - clear the event's `end`
        // - convert the event to allDay
        // - add `dateDelta` to the start and end
        // - add `durationDelta` to the event's duration
        // - assign `miscProps` to the event
        //
        // Returns a function that can be called to undo all the operations.
        //
        // TODO: don't use so many closures. possible memory issues when lots of events with same ID.
        //
        function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {
            var isAmbigTimezone = t.getIsAmbigTimezone();
            var undoFunctions = [];

            // normalize zero-length deltas to be null
            if (dateDelta && !dateDelta.valueOf()) { dateDelta = null; }
            if (durationDelta && !durationDelta.valueOf()) { durationDelta = null; }

            $.each(events, function(i, event) {
                var oldProps;
                var newProps;

                // build an object holding all the old values, both date-related and misc.
                // for the undo function.
                oldProps = {
                    start: event.start.clone(),
                    end: event.end ? event.end.clone() : null,
                    allDay: event.allDay
                };
                $.each(miscProps, function(name) {
                    oldProps[name] = event[name];
                });

                // new date-related properties. work off the original date snapshot.
                // ok to use references because they will be thrown away when backupEventDates is called.
                newProps = {
                    start: event._start,
                    end: event._end,
                    allDay: allDay // normalize the dates in the same regard as the new properties
                };
                normalizeEventDates(newProps); // massages start/end/allDay

                // strip or ensure the end date
                if (clearEnd) {
                    newProps.end = null;
                }
                else if (durationDelta && !newProps.end) { // the duration translation requires an end date
                    newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);
                }

                if (dateDelta) {
                    newProps.start.add(dateDelta);
                    if (newProps.end) {
                        newProps.end.add(dateDelta);
                    }
                }

                if (durationDelta) {
                    newProps.end.add(durationDelta); // end already ensured above
                }

                // if the dates have changed, and we know it is impossible to recompute the
                // timezone offsets, strip the zone.
                if (
                    isAmbigTimezone &&
                    !newProps.allDay &&
                    (dateDelta || durationDelta)
                ) {
                    newProps.start.stripZone();
                    if (newProps.end) {
                        newProps.end.stripZone();
                    }
                }

                $.extend(event, miscProps, newProps); // copy over misc props, then date-related props
                backupEventDates(event); // regenerate internal _start/_end/_allDay

                undoFunctions.push(function() {
                    $.extend(event, oldProps);
                    backupEventDates(event); // regenerate internal _start/_end/_allDay
                });
            });

            return function() {
                for (var i = 0; i < undoFunctions.length; i++) {
                    undoFunctions[i]();
                }
            };
        }

    }


// returns an undo function
    Calendar.prototype.mutateSeg = function(seg, newProps) {
        return this.mutateEvent(seg.event, newProps);
    };


// hook for external libs to manipulate event properties upon creation.
// should manipulate the event in-place.
    Calendar.prototype.normalizeEvent = function(event) {
    };


// Does the given span (start, end, and other location information)
// fully contain the other?
    Calendar.prototype.spanContainsSpan = function(outerSpan, innerSpan) {
        var eventStart = outerSpan.start.clone().stripZone();
        var eventEnd = this.getEventEnd(outerSpan).stripZone();

        return innerSpan.start >= eventStart && innerSpan.end <= eventEnd;
    };


// Returns a list of events that the given event should be compared against when being considered for a move to
// the specified span. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.
    Calendar.prototype.getPeerEvents = function(span, event) {
        var cache = this.getEventCache();
        var peerEvents = [];
        var i, otherEvent;

        for (i = 0; i < cache.length; i++) {
            otherEvent = cache[i];
            if (
                !event ||
                event._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events
            ) {
                peerEvents.push(otherEvent);
            }
        }

        return peerEvents;
    };


// updates the "backup" properties, which are preserved in order to compute diffs later on.
    function backupEventDates(event) {
        event._allDay = event.allDay;
        event._start = event.start.clone();
        event._end = event.end ? event.end.clone() : null;
    }


    /* Overlapping / Constraining
     -----------------------------------------------------------------------------------------*/


// Determines if the given event can be relocated to the given span (unzoned start/end with other misc data)
    Calendar.prototype.isEventSpanAllowed = function(span, event) {
        var source = event.source || {};
        var eventAllowFunc = this.opt('eventAllow');

        var constraint = firstDefined(
            event.constraint,
            source.constraint,
            this.opt('eventConstraint')
        );

        var overlap = firstDefined(
            event.overlap,
            source.overlap,
            this.opt('eventOverlap')
        );

        return this.isSpanAllowed(span, constraint, overlap, event) &&
            (!eventAllowFunc || eventAllowFunc(span, event) !== false);
    };


// Determines if an external event can be relocated to the given span (unzoned start/end with other misc data)
    Calendar.prototype.isExternalSpanAllowed = function(eventSpan, eventLocation, eventProps) {
        var eventInput;
        var event;

        // note: very similar logic is in View's reportExternalDrop
        if (eventProps) {
            eventInput = $.extend({}, eventProps, eventLocation);
            event = this.expandEvent(
                this.buildEventFromInput(eventInput)
            )[0];
        }

        if (event) {
            return this.isEventSpanAllowed(eventSpan, event);
        }
        else { // treat it as a selection

            return this.isSelectionSpanAllowed(eventSpan);
        }
    };


// Determines the given span (unzoned start/end with other misc data) can be selected.
    Calendar.prototype.isSelectionSpanAllowed = function(span) {
        var selectAllowFunc = this.opt('selectAllow');

        return this.isSpanAllowed(span, this.opt('selectConstraint'), this.opt('selectOverlap')) &&
            (!selectAllowFunc || selectAllowFunc(span) !== false);
    };


// Returns true if the given span (caused by an event drop/resize or a selection) is allowed to exist
// according to the constraint/overlap settings.
// `event` is not required if checking a selection.
    Calendar.prototype.isSpanAllowed = function(span, constraint, overlap, event) {
        var constraintEvents;
        var anyContainment;
        var peerEvents;
        var i, peerEvent;
        var peerOverlap;

        // the range must be fully contained by at least one of produced constraint events
        if (constraint != null) {

            // not treated as an event! intermediate data structure
            // TODO: use ranges in the future
            constraintEvents = this.constraintToEvents(constraint);
            if (constraintEvents) { // not invalid

                anyContainment = false;
                for (i = 0; i < constraintEvents.length; i++) {
                    if (this.spanContainsSpan(constraintEvents[i], span)) {
                        anyContainment = true;
                        break;
                    }
                }

                if (!anyContainment) {
                    return false;
                }
            }
        }

        peerEvents = this.getPeerEvents(span, event);

        for (i = 0; i < peerEvents.length; i++)  {
            peerEvent = peerEvents[i];

            // there needs to be an actual intersection before disallowing anything
            if (this.eventIntersectsRange(peerEvent, span)) {

                // evaluate overlap for the given range and short-circuit if necessary
                if (overlap === false) {
                    return false;
                }
                // if the event's overlap is a test function, pass the peer event in question as the first param
                else if (typeof overlap === 'function' && !overlap(peerEvent, event)) {
                    return false;
                }

                // if we are computing if the given range is allowable for an event, consider the other event's
                // EventObject-specific or Source-specific `overlap` property
                if (event) {
                    peerOverlap = firstDefined(
                        peerEvent.overlap,
                        (peerEvent.source || {}).overlap
                        // we already considered the global `eventOverlap`
                    );
                    if (peerOverlap === false) {
                        return false;
                    }
                    // if the peer event's overlap is a test function, pass the subject event as the first param
                    if (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {
                        return false;
                    }
                }
            }
        }

        return true;
    };


// Given an event input from the API, produces an array of event objects. Possible event inputs:
// 'businessHours'
// An event ID (number or string)
// An object with specific start/end dates or a recurring event (like what businessHours accepts)
    Calendar.prototype.constraintToEvents = function(constraintInput) {

        if (constraintInput === 'businessHours') {
            return this.getCurrentBusinessHourEvents();
        }

        if (typeof constraintInput === 'object') {
            if (constraintInput.start != null) { // needs to be event-like input
                return this.expandEvent(this.buildEventFromInput(constraintInput));
            }
            else {
                return null; // invalid
            }
        }

        return this.clientEvents(constraintInput); // probably an ID
    };


// Does the event's date range intersect with the given range?
// start/end already assumed to have stripped zones :(
    Calendar.prototype.eventIntersectsRange = function(event, range) {
        var eventStart = event.start.clone().stripZone();
        var eventEnd = this.getEventEnd(event).stripZone();

        return range.start < eventEnd && range.end > eventStart;
    };


    /* Business Hours
     -----------------------------------------------------------------------------------------*/

    var BUSINESS_HOUR_EVENT_DEFAULTS = {
        id: '_fcBusinessHours', // will relate events from different calls to expandEvent
        start: '09:00',
        end: '17:00',
        dow: [ 1, 2, 3, 4, 5 ], // monday - friday
        rendering: 'inverse-background'
        // classNames are defined in businessHoursSegClasses
    };

// Return events objects for business hours within the current view.
// Abuse of our event system :(
    Calendar.prototype.getCurrentBusinessHourEvents = function(wholeDay) {
        return this.computeBusinessHourEvents(wholeDay, this.opt('businessHours'));
    };

// Given a raw input value from options, return events objects for business hours within the current view.
    Calendar.prototype.computeBusinessHourEvents = function(wholeDay, input) {
        if (input === true) {
            return this.expandBusinessHourEvents(wholeDay, [ {} ]);
        }
        else if ($.isPlainObject(input)) {
            return this.expandBusinessHourEvents(wholeDay, [ input ]);
        }
        else if ($.isArray(input)) {
            return this.expandBusinessHourEvents(wholeDay, input, true);
        }
        else {
            return [];
        }
    };

// inputs expected to be an array of objects.
// if ignoreNoDow is true, will ignore entries that don't specify a day-of-week (dow) key.
    Calendar.prototype.expandBusinessHourEvents = function(wholeDay, inputs, ignoreNoDow) {
        var view = this.getView();
        var events = [];
        var i, input;

        for (i = 0; i < inputs.length; i++) {
            input = inputs[i];

            if (ignoreNoDow && !input.dow) {
                continue;
            }

            // give defaults. will make a copy
            input = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, input);

            // if a whole-day series is requested, clear the start/end times
            if (wholeDay) {
                input.start = null;
                input.end = null;
            }

            events.push.apply(events, // append
                this.expandEvent(
                    this.buildEventFromInput(input),
                    view.activeRange.start,
                    view.activeRange.end
                )
            );
        }

        return events;
    };

    ;;

    /* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
     ----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.

    var BasicView = FC.BasicView = View.extend({

        scroller: null,

        dayGridClass: DayGrid, // class the dayGrid will be instantiated from (overridable by subclasses)
        dayGrid: null, // the main subcomponent that does most of the heavy lifting

        dayNumbersVisible: false, // display day numbers on each day cell?
        colWeekNumbersVisible: false, // display week numbers along the side?
        cellWeekNumbersVisible: false, // display week numbers in day cell?

        weekNumberWidth: null, // width of all the week-number cells running down the side

        headContainerEl: null, // div that hold's the dayGrid's rendered date header
        headRowEl: null, // the fake row element of the day-of-week header


        initialize: function() {
            this.dayGrid = this.instantiateDayGrid();

            this.scroller = new Scroller({
                overflowX: 'hidden',
                overflowY: 'auto'
            });
        },


        // Generates the DayGrid object this view needs. Draws from this.dayGridClass
        instantiateDayGrid: function() {
            // generate a subclass on the fly with BasicView-specific behavior
            // TODO: cache this subclass
            var subclass = this.dayGridClass.extend(basicDayGridMethods);

            return new subclass(this);
        },


        // Computes the date range that will be rendered.
        buildRenderRange: function(currentRange, currentRangeUnit) {
            var renderRange = View.prototype.buildRenderRange.apply(this, arguments);

            // year and month views should be aligned with weeks. this is already done for week
            if (/^(year|month)$/.test(currentRangeUnit)) {
                renderRange.start.startOf('week');

                // make end-of-week if not already
                if (renderRange.end.weekday()) {
                    renderRange.end.add(1, 'week').startOf('week'); // exclusively move backwards
                }
            }

            return this.trimHiddenDays(renderRange);
        },


        // Renders the view into `this.el`, which should already be assigned
        renderDates: function() {

            this.dayGrid.breakOnWeeks = /year|month|week/.test(this.currentRangeUnit); // do before Grid::setRange
            this.dayGrid.setRange(this.renderRange);

            this.dayNumbersVisible = this.dayGrid.rowCnt > 1; // TODO: make grid responsible
            if (this.opt('weekNumbers')) {
                if (this.opt('weekNumbersWithinDays')) {
                    this.cellWeekNumbersVisible = true;
                    this.colWeekNumbersVisible = false;
                }
                else {
                    this.cellWeekNumbersVisible = false;
                    this.colWeekNumbersVisible = true;
                };
            }
            this.dayGrid.numbersVisible = this.dayNumbersVisible ||
                this.cellWeekNumbersVisible || this.colWeekNumbersVisible;

            this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());
            this.renderHead();

            this.scroller.render();
            var dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');
            var dayGridEl = $('<div class="fc-day-grid" />').appendTo(dayGridContainerEl);
            this.el.find('.fc-body > tr > td').append(dayGridContainerEl);

            this.dayGrid.setElement(dayGridEl);
            this.dayGrid.renderDates(this.hasRigidRows());
        },


        // render the day-of-week headers
        renderHead: function() {
            this.headContainerEl =
                this.el.find('.fc-head-container')
                    .html(this.dayGrid.renderHeadHtml());
            this.headRowEl = this.headContainerEl.find('.fc-row');
        },


        // Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
        // always completely kill the dayGrid's rendering.
        unrenderDates: function() {
            this.dayGrid.unrenderDates();
            this.dayGrid.removeElement();
            this.scroller.destroy();
        },


        renderBusinessHours: function() {
            this.dayGrid.renderBusinessHours();
        },


        unrenderBusinessHours: function() {
            this.dayGrid.unrenderBusinessHours();
        },


        // Builds the HTML skeleton for the view.
        // The day-grid component will render inside of a container defined by this HTML.
        renderSkeletonHtml: function() {
            return '' +
                '<table>' +
                '<thead class="fc-head">' +
                '<tr>' +
                '<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
                '</tr>' +
                '</thead>' +
                '<tbody class="fc-body">' +
                '<tr>' +
                '<td class="' + this.widgetContentClass + '"></td>' +
                '</tr>' +
                '</tbody>' +
                '</table>';
        },


        // Generates an HTML attribute string for setting the width of the week number column, if it is known
        weekNumberStyleAttr: function() {
            if (this.weekNumberWidth !== null) {
                return 'style="width:' + this.weekNumberWidth + 'px"';
            }
            return '';
        },


        // Determines whether each row should have a constant height
        hasRigidRows: function() {
            var eventLimit = this.opt('eventLimit');
            return eventLimit && typeof eventLimit !== 'number';
        },


        /* Dimensions
         ------------------------------------------------------------------------------------------------------------------*/


        // Refreshes the horizontal dimensions of the view
        updateWidth: function() {
            if (this.colWeekNumbersVisible) {
                // Make sure all week number cells running down the side have the same width.
                // Record the width for cells created later.
                this.weekNumberWidth = matchCellWidths(
                    this.el.find('.fc-week-number')
                );
            }
        },


        // Adjusts the vertical dimensions of the view to the specified values
        setHeight: function(totalHeight, isAuto) {
            var eventLimit = this.opt('eventLimit');
            var scrollerHeight;
            var scrollbarWidths;

            // reset all heights to be natural
            this.scroller.clear();
            uncompensateScroll(this.headRowEl);

            this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

            // is the event limit a constant level number?
            if (eventLimit && typeof eventLimit === 'number') {
                this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
            }

            // distribute the height to the rows
            // (totalHeight is a "recommended" value if isAuto)
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.setGridHeight(scrollerHeight, isAuto);

            // is the event limit dynamically calculated?
            if (eventLimit && typeof eventLimit !== 'number') {
                this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
            }

            if (!isAuto) { // should we force dimensions of the scroll container?

                this.scroller.setHeight(scrollerHeight);
                scrollbarWidths = this.scroller.getScrollbarWidths();

                if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?

                    compensateScroll(this.headRowEl, scrollbarWidths);

                    // doing the scrollbar compensation might have created text overflow which created more height. redo
                    scrollerHeight = this.computeScrollerHeight(totalHeight);
                    this.scroller.setHeight(scrollerHeight);
                }

                // guarantees the same scrollbar widths
                this.scroller.lockOverflow(scrollbarWidths);
            }
        },


        // given a desired total height of the view, returns what the height of the scroller should be
        computeScrollerHeight: function(totalHeight) {
            return totalHeight -
                subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
        },


        // Sets the height of just the DayGrid component in this view
        setGridHeight: function(height, isAuto) {
            if (isAuto) {
                undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
            }
            else {
                distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
            }
        },


        /* Scroll
         ------------------------------------------------------------------------------------------------------------------*/


        computeInitialDateScroll: function() {
            return { top: 0 };
        },


        queryDateScroll: function() {
            return { top: this.scroller.getScrollTop() };
        },


        applyDateScroll: function(scroll) {
            if (scroll.top !== undefined) {
                this.scroller.setScrollTop(scroll.top);
            }
        },


        /* Hit Areas
         ------------------------------------------------------------------------------------------------------------------*/
        // forward all hit-related method calls to dayGrid


        hitsNeeded: function() {
            this.dayGrid.hitsNeeded();
        },


        hitsNotNeeded: function() {
            this.dayGrid.hitsNotNeeded();
        },


        prepareHits: function() {
            this.dayGrid.prepareHits();
        },


        releaseHits: function() {
            this.dayGrid.releaseHits();
        },


        queryHit: function(left, top) {
            return this.dayGrid.queryHit(left, top);
        },


        getHitSpan: function(hit) {
            return this.dayGrid.getHitSpan(hit);
        },


        getHitEl: function(hit) {
            return this.dayGrid.getHitEl(hit);
        },


        /* Events
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders the given events onto the view and populates the segments array
        renderEvents: function(events) {
            this.dayGrid.renderEvents(events);

            this.updateHeight(); // must compensate for events that overflow the row
        },


        // Retrieves all segment objects that are rendered in the view
        getEventSegs: function() {
            return this.dayGrid.getEventSegs();
        },


        // Unrenders all event elements and clears internal segment data
        unrenderEvents: function() {
            this.dayGrid.unrenderEvents();

            // we DON'T need to call updateHeight() because
            // a renderEvents() call always happens after this, which will eventually call updateHeight()
        },


        /* Dragging (for both events and external elements)
         ------------------------------------------------------------------------------------------------------------------*/


        // A returned value of `true` signals that a mock "helper" event has been rendered.
        renderDrag: function(dropLocation, seg) {
            return this.dayGrid.renderDrag(dropLocation, seg);
        },


        unrenderDrag: function() {
            this.dayGrid.unrenderDrag();
        },


        /* Selection
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of a selection
        renderSelection: function(span) {
            this.dayGrid.renderSelection(span);
        },


        // Unrenders a visual indications of a selection
        unrenderSelection: function() {
            this.dayGrid.unrenderSelection();
        }

    });


// Methods that will customize the rendering behavior of the BasicView's dayGrid
    var basicDayGridMethods = {


        // Generates the HTML that will go before the day-of week header cells
        renderHeadIntroHtml: function() {
            var view = this.view;

            if (view.colWeekNumbersVisible) {
                return '' +
                    '<th class="fc-week-number ' + view.widgetHeaderClass + '" ' + view.weekNumberStyleAttr() + '>' +
                    '<span>' + // needed for matchCellWidths
                    htmlEscape(view.opt('weekNumberTitle')) +
                    '</span>' +
                    '</th>';
            }

            return '';
        },


        // Generates the HTML that will go before content-skeleton cells that display the day/week numbers
        renderNumberIntroHtml: function(row) {
            var view = this.view;
            var weekStart = this.getCellDate(row, 0);

            if (view.colWeekNumbersVisible) {
                return '' +
                    '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '>' +
                    view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
                        { date: weekStart, type: 'week', forceOff: this.colCnt === 1 },
                        weekStart.format('w') // inner HTML
                    ) +
                    '</td>';
            }

            return '';
        },


        // Generates the HTML that goes before the day bg cells for each day-row
        renderBgIntroHtml: function() {
            var view = this.view;

            if (view.colWeekNumbersVisible) {
                return '<td class="fc-week-number ' + view.widgetContentClass + '" ' +
                    view.weekNumberStyleAttr() + '></td>';
            }

            return '';
        },


        // Generates the HTML that goes before every other type of row generated by DayGrid.
        // Affects helper-skeleton and highlight-skeleton rows.
        renderIntroHtml: function() {
            var view = this.view;

            if (view.colWeekNumbersVisible) {
                return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '></td>';
            }

            return '';
        }

    };

    ;;

    /* A month view with day cells running in rows (one-per-week) and columns
     ----------------------------------------------------------------------------------------------------------------------*/

    var MonthView = FC.MonthView = BasicView.extend({


        // Computes the date range that will be rendered.
        buildRenderRange: function() {
            var renderRange = BasicView.prototype.buildRenderRange.apply(this, arguments);
            var rowCnt;

            // ensure 6 weeks
            if (this.isFixedWeeks()) {
                rowCnt = Math.ceil( // could be partial weeks due to hiddenDays
                    renderRange.end.diff(renderRange.start, 'weeks', true) // dontRound=true
                );
                renderRange.end.add(6 - rowCnt, 'weeks');
            }

            return renderRange;
        },


        // Overrides the default BasicView behavior to have special multi-week auto-height logic
        setGridHeight: function(height, isAuto) {

            // if auto, make the height of each row the height that it would be if there were 6 weeks
            if (isAuto) {
                height *= this.rowCnt / 6;
            }

            distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
        },


        isFixedWeeks: function() {
            return this.opt('fixedWeekCount');
        }

    });

    ;;

    fcViews.basic = {
        'class': BasicView
    };

    fcViews.basicDay = {
        type: 'basic',
        duration: { days: 1 }
    };

    fcViews.basicWeek = {
        type: 'basic',
        duration: { weeks: 1 }
    };

    fcViews.month = {
        'class': MonthView,
        duration: { months: 1 }, // important for prev/next
        defaults: {
            fixedWeekCount: true
        }
    };
    ;;

    /* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
     ----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.

    var AgendaView = FC.AgendaView = View.extend({

        scroller: null,

        timeGridClass: TimeGrid, // class used to instantiate the timeGrid. subclasses can override
        timeGrid: null, // the main time-grid subcomponent of this view

        dayGridClass: DayGrid, // class used to instantiate the dayGrid. subclasses can override
        dayGrid: null, // the "all-day" subcomponent. if all-day is turned off, this will be null

        axisWidth: null, // the width of the time axis running down the side

        headContainerEl: null, // div that hold's the timeGrid's rendered date header
        noScrollRowEls: null, // set of fake row elements that must compensate when scroller has scrollbars

        // when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath
        bottomRuleEl: null,

        // indicates that minTime/maxTime affects rendering
        usesMinMaxTime: true,


        initialize: function() {
            this.timeGrid = this.instantiateTimeGrid();

            if (this.opt('allDaySlot')) { // should we display the "all-day" area?
                this.dayGrid = this.instantiateDayGrid(); // the all-day subcomponent of this view
            }

            this.scroller = new Scroller({
                overflowX: 'hidden',
                overflowY: 'auto'
            });
        },


        // Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
        instantiateTimeGrid: function() {
            var subclass = this.timeGridClass.extend(agendaTimeGridMethods);

            return new subclass(this);
        },


        // Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
        instantiateDayGrid: function() {
            var subclass = this.dayGridClass.extend(agendaDayGridMethods);

            return new subclass(this);
        },


        /* Rendering
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders the view into `this.el`, which has already been assigned
        renderDates: function() {

            this.timeGrid.setRange(this.renderRange);

            if (this.dayGrid) {
                this.dayGrid.setRange(this.renderRange);
            }

            this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());
            this.renderHead();

            this.scroller.render();
            var timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');
            var timeGridEl = $('<div class="fc-time-grid" />').appendTo(timeGridWrapEl);
            this.el.find('.fc-body > tr > td').append(timeGridWrapEl);

            this.timeGrid.setElement(timeGridEl);
            this.timeGrid.renderDates();

            // the <hr> that sometimes displays under the time-grid
            this.bottomRuleEl = $('<hr class="fc-divider ' + this.widgetHeaderClass + '"/>')
                .appendTo(this.timeGrid.el); // inject it into the time-grid

            if (this.dayGrid) {
                this.dayGrid.setElement(this.el.find('.fc-day-grid'));
                this.dayGrid.renderDates();

                // have the day-grid extend it's coordinate area over the <hr> dividing the two grids
                this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
            }

            this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller
        },


        // render the day-of-week headers
        renderHead: function() {
            this.headContainerEl =
                this.el.find('.fc-head-container')
                    .html(this.timeGrid.renderHeadHtml());
        },


        // Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
        // always completely kill each grid's rendering.
        unrenderDates: function() {
            this.timeGrid.unrenderDates();
            this.timeGrid.removeElement();

            if (this.dayGrid) {
                this.dayGrid.unrenderDates();
                this.dayGrid.removeElement();
            }

            this.scroller.destroy();
        },


        // Builds the HTML skeleton for the view.
        // The day-grid and time-grid components will render inside containers defined by this HTML.
        renderSkeletonHtml: function() {
            return '' +
                '<table>' +
                '<thead class="fc-head">' +
                '<tr>' +
                '<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
                '</tr>' +
                '</thead>' +
                '<tbody class="fc-body">' +
                '<tr>' +
                '<td class="' + this.widgetContentClass + '">' +
                (this.dayGrid ?
                        '<div class="fc-day-grid"/>' +
                        '<hr class="fc-divider ' + this.widgetHeaderClass + '"/>' :
                        ''
                ) +
                '</td>' +
                '</tr>' +
                '</tbody>' +
                '</table>';
        },


        // Generates an HTML attribute string for setting the width of the axis, if it is known
        axisStyleAttr: function() {
            if (this.axisWidth !== null) {
                return 'style="width:' + this.axisWidth + 'px"';
            }
            return '';
        },


        /* Business Hours
         ------------------------------------------------------------------------------------------------------------------*/


        renderBusinessHours: function() {
            this.timeGrid.renderBusinessHours();

            if (this.dayGrid) {
                this.dayGrid.renderBusinessHours();
            }
        },


        unrenderBusinessHours: function() {
            this.timeGrid.unrenderBusinessHours();

            if (this.dayGrid) {
                this.dayGrid.unrenderBusinessHours();
            }
        },


        /* Now Indicator
         ------------------------------------------------------------------------------------------------------------------*/


        getNowIndicatorUnit: function() {
            return this.timeGrid.getNowIndicatorUnit();
        },


        renderNowIndicator: function(date) {
            this.timeGrid.renderNowIndicator(date);
        },


        unrenderNowIndicator: function() {
            this.timeGrid.unrenderNowIndicator();
        },


        /* Dimensions
         ------------------------------------------------------------------------------------------------------------------*/


        updateSize: function(isResize) {
            this.timeGrid.updateSize(isResize);

            View.prototype.updateSize.call(this, isResize); // call the super-method
        },


        // Refreshes the horizontal dimensions of the view
        updateWidth: function() {
            // make all axis cells line up, and record the width so newly created axis cells will have it
            this.axisWidth = matchCellWidths(this.el.find('.fc-axis'));
        },


        // Adjusts the vertical dimensions of the view to the specified values
        setHeight: function(totalHeight, isAuto) {
            var eventLimit;
            var scrollerHeight;
            var scrollbarWidths;

            // reset all dimensions back to the original state
            this.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary
            this.scroller.clear(); // sets height to 'auto' and clears overflow
            uncompensateScroll(this.noScrollRowEls);

            // limit number of events in the all-day area
            if (this.dayGrid) {
                this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

                eventLimit = this.opt('eventLimit');
                if (eventLimit && typeof eventLimit !== 'number') {
                    eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
                }
                if (eventLimit) {
                    this.dayGrid.limitRows(eventLimit);
                }
            }

            if (!isAuto) { // should we force dimensions of the scroll container?

                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
                scrollbarWidths = this.scroller.getScrollbarWidths();

                if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?

                    // make the all-day and header rows lines up
                    compensateScroll(this.noScrollRowEls, scrollbarWidths);

                    // the scrollbar compensation might have changed text flow, which might affect height, so recalculate
                    // and reapply the desired height to the scroller.
                    scrollerHeight = this.computeScrollerHeight(totalHeight);
                    this.scroller.setHeight(scrollerHeight);
                }

                // guarantees the same scrollbar widths
                this.scroller.lockOverflow(scrollbarWidths);

                // if there's any space below the slats, show the horizontal rule.
                // this won't cause any new overflow, because lockOverflow already called.
                if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
                    this.bottomRuleEl.show();
                }
            }
        },


        // given a desired total height of the view, returns what the height of the scroller should be
        computeScrollerHeight: function(totalHeight) {
            return totalHeight -
                subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
        },


        /* Scroll
         ------------------------------------------------------------------------------------------------------------------*/


        // Computes the initial pre-configured scroll state prior to allowing the user to change it
        computeInitialDateScroll: function() {
            var scrollTime = moment.duration(this.opt('scrollTime'));
            var top = this.timeGrid.computeTimeTop(scrollTime);

            // zoom can give weird floating-point values. rather scroll a little bit further
            top = Math.ceil(top);

            if (top) {
                top++; // to overcome top border that slots beyond the first have. looks better
            }

            return { top: top };
        },


        queryDateScroll: function() {
            return { top: this.scroller.getScrollTop() };
        },


        applyDateScroll: function(scroll) {
            if (scroll.top !== undefined) {
                this.scroller.setScrollTop(scroll.top);
            }
        },


        /* Hit Areas
         ------------------------------------------------------------------------------------------------------------------*/
        // forward all hit-related method calls to the grids (dayGrid might not be defined)


        hitsNeeded: function() {
            this.timeGrid.hitsNeeded();
            if (this.dayGrid) {
                this.dayGrid.hitsNeeded();
            }
        },


        hitsNotNeeded: function() {
            this.timeGrid.hitsNotNeeded();
            if (this.dayGrid) {
                this.dayGrid.hitsNotNeeded();
            }
        },


        prepareHits: function() {
            this.timeGrid.prepareHits();
            if (this.dayGrid) {
                this.dayGrid.prepareHits();
            }
        },


        releaseHits: function() {
            this.timeGrid.releaseHits();
            if (this.dayGrid) {
                this.dayGrid.releaseHits();
            }
        },


        queryHit: function(left, top) {
            var hit = this.timeGrid.queryHit(left, top);

            if (!hit && this.dayGrid) {
                hit = this.dayGrid.queryHit(left, top);
            }

            return hit;
        },


        getHitSpan: function(hit) {
            // TODO: hit.component is set as a hack to identify where the hit came from
            return hit.component.getHitSpan(hit);
        },


        getHitEl: function(hit) {
            // TODO: hit.component is set as a hack to identify where the hit came from
            return hit.component.getHitEl(hit);
        },


        /* Events
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders events onto the view and populates the View's segment array
        renderEvents: function(events) {
            var dayEvents = [];
            var timedEvents = [];
            var daySegs = [];
            var timedSegs;
            var i;

            // separate the events into all-day and timed
            for (i = 0; i < events.length; i++) {
                if (events[i].allDay) {
                    dayEvents.push(events[i]);
                }
                else {
                    timedEvents.push(events[i]);
                }
            }

            // render the events in the subcomponents
            timedSegs = this.timeGrid.renderEvents(timedEvents);
            if (this.dayGrid) {
                daySegs = this.dayGrid.renderEvents(dayEvents);
            }

            // the all-day area is flexible and might have a lot of events, so shift the height
            this.updateHeight();
        },


        // Retrieves all segment objects that are rendered in the view
        getEventSegs: function() {
            return this.timeGrid.getEventSegs().concat(
                this.dayGrid ? this.dayGrid.getEventSegs() : []
            );
        },


        // Unrenders all event elements and clears internal segment data
        unrenderEvents: function() {

            // unrender the events in the subcomponents
            this.timeGrid.unrenderEvents();
            if (this.dayGrid) {
                this.dayGrid.unrenderEvents();
            }

            // we DON'T need to call updateHeight() because
            // a renderEvents() call always happens after this, which will eventually call updateHeight()
        },


        /* Dragging (for events and external elements)
         ------------------------------------------------------------------------------------------------------------------*/


        // A returned value of `true` signals that a mock "helper" event has been rendered.
        renderDrag: function(dropLocation, seg) {
            if (dropLocation.start.hasTime()) {
                return this.timeGrid.renderDrag(dropLocation, seg);
            }
            else if (this.dayGrid) {
                return this.dayGrid.renderDrag(dropLocation, seg);
            }
        },


        unrenderDrag: function() {
            this.timeGrid.unrenderDrag();
            if (this.dayGrid) {
                this.dayGrid.unrenderDrag();
            }
        },


        /* Selection
         ------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of a selection
        renderSelection: function(span) {
            if (span.start.hasTime() || span.end.hasTime()) {
                this.timeGrid.renderSelection(span);
            }
            else if (this.dayGrid) {
                this.dayGrid.renderSelection(span);
            }
        },


        // Unrenders a visual indications of a selection
        unrenderSelection: function() {
            this.timeGrid.unrenderSelection();
            if (this.dayGrid) {
                this.dayGrid.unrenderSelection();
            }
        }

    });


// Methods that will customize the rendering behavior of the AgendaView's timeGrid
// TODO: move into TimeGrid
    var agendaTimeGridMethods = {


        // Generates the HTML that will go before the day-of week header cells
        renderHeadIntroHtml: function() {
            var view = this.view;
            var weekText;

            if (view.opt('weekNumbers')) {
                weekText = this.start.format(view.opt('smallWeekFormat'));

                return '' +
                    '<th class="fc-axis fc-week-number ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '>' +
                    view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
                        { date: this.start, type: 'week', forceOff: this.colCnt > 1 },
                        htmlEscape(weekText) // inner HTML
                    ) +
                    '</th>';
            }
            else {
                return '<th class="fc-axis ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '></th>';
            }
        },


        // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
        renderBgIntroHtml: function() {
            var view = this.view;

            return '<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '></td>';
        },


        // Generates the HTML that goes before all other types of cells.
        // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
        renderIntroHtml: function() {
            var view = this.view;

            return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
        }

    };


// Methods that will customize the rendering behavior of the AgendaView's dayGrid
    var agendaDayGridMethods = {


        // Generates the HTML that goes before the all-day cells
        renderBgIntroHtml: function() {
            var view = this.view;

            return '' +
                '<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
                '<span>' + // needed for matchCellWidths
                view.getAllDayHtml() +
                '</span>' +
                '</td>';
        },


        // Generates the HTML that goes before all other types of cells.
        // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
        renderIntroHtml: function() {
            var view = this.view;

            return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
        }

    };

    ;;

    var AGENDA_ALL_DAY_EVENT_LIMIT = 5;

// potential nice values for the slot-duration and interval-duration
// from largest to smallest
    var AGENDA_STOCK_SUB_DURATIONS = [
        { hours: 1 },
        { minutes: 30 },
        { minutes: 15 },
        { seconds: 30 },
        { seconds: 15 }
    ];

    fcViews.agenda = {
        'class': AgendaView,
        defaults: {
            allDaySlot: true,
            slotDuration: '00:30:00',
            slotEventOverlap: true // a bad name. confused with overlap/constraint system
        }
    };

    fcViews.agendaDay = {
        type: 'agenda',
        duration: { days: 1 }
    };

    fcViews.agendaWeek = {
        type: 'agenda',
        duration: { weeks: 1 }
    };
    ;;

    /*
     Responsible for the scroller, and forwarding event-related actions into the "grid"
     */
    var ListView = View.extend({

        grid: null,
        scroller: null,

        initialize: function() {
            this.grid = new ListViewGrid(this);
            this.scroller = new Scroller({
                overflowX: 'hidden',
                overflowY: 'auto'
            });
        },

        renderSkeleton: function() {
            this.el.addClass(
                'fc-list-view ' +
                this.widgetContentClass
            );

            this.scroller.render();
            this.scroller.el.appendTo(this.el);

            this.grid.setElement(this.scroller.scrollEl);
        },

        unrenderSkeleton: function() {
            this.scroller.destroy(); // will remove the Grid too
        },

        setHeight: function(totalHeight, isAuto) {
            this.scroller.setHeight(this.computeScrollerHeight(totalHeight));
        },

        computeScrollerHeight: function(totalHeight) {
            return totalHeight -
                subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
        },

        renderDates: function() {
            this.grid.setRange(this.renderRange); // needs to process range-related options
        },

        renderEvents: function(events) {
            this.grid.renderEvents(events);
        },

        unrenderEvents: function() {
            this.grid.unrenderEvents();
        },

        isEventResizable: function(event) {
            return false;
        },

        isEventDraggable: function(event) {
            return false;
        }

    });

    /*
     Responsible for event rendering and user-interaction.
     Its "el" is the inner-content of the above view's scroller.
     */
    var ListViewGrid = Grid.extend({

        segSelector: '.fc-list-item', // which elements accept event actions
        hasDayInteractions: false, // no day selection or day clicking

        // slices by day
        spanToSegs: function(span) {
            var view = this.view;
            var dayStart = view.renderRange.start.clone().time(0); // timed, so segs get times!
            var dayIndex = 0;
            var seg;
            var segs = [];

            while (dayStart < view.renderRange.end) {

                seg = intersectRanges(span, {
                    start: dayStart,
                    end: dayStart.clone().add(1, 'day')
                });

                if (seg) {
                    seg.dayIndex = dayIndex;
                    segs.push(seg);
                }

                dayStart.add(1, 'day');
                dayIndex++;

                // detect when span won't go fully into the next day,
                // and mutate the latest seg to the be the end.
                if (
                    seg && !seg.isEnd && span.end.hasTime() &&
                    span.end < dayStart.clone().add(this.view.nextDayThreshold)
                ) {
                    seg.end = span.end.clone();
                    seg.isEnd = true;
                    break;
                }
            }

            return segs;
        },

        // like "4:00am"
        computeEventTimeFormat: function() {
            return this.view.opt('mediumTimeFormat');
        },

        // for events with a url, the whole <tr> should be clickable,
        // but it's impossible to wrap with an <a> tag. simulate this.
        handleSegClick: function(seg, ev) {
            var url;

            Grid.prototype.handleSegClick.apply(this, arguments); // super. might prevent the default action

            // not clicking on or within an <a> with an href
            if (!$(ev.target).closest('a[href]').length) {
                url = seg.event.url;
                if (url && !ev.isDefaultPrevented()) { // jsEvent not cancelled in handler
                    window.location.href = url; // simulate link click
                }
            }
        },

        // returns list of foreground segs that were actually rendered
        renderFgSegs: function(segs) {
            segs = this.renderFgSegEls(segs); // might filter away hidden events

            if (!segs.length) {
                this.renderEmptyMessage();
            }
            else {
                this.renderSegList(segs);
            }

            return segs;
        },

        renderEmptyMessage: function() {
            this.el.html(
                '<div class="fc-list-empty-wrap2">' + // TODO: try less wraps
                '<div class="fc-list-empty-wrap1">' +
                '<div class="fc-list-empty">' +
                htmlEscape(this.view.opt('noEventsMessage')) +
                '</div>' +
                '</div>' +
                '</div>'
            );
        },

        // render the event segments in the view
        renderSegList: function(allSegs) {
            var segsByDay = this.groupSegsByDay(allSegs); // sparse array
            var dayIndex;
            var daySegs;
            var i;
            var tableEl = $('<table class="fc-list-table"><tbody/></table>');
            var tbodyEl = tableEl.find('tbody');

            for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
                daySegs = segsByDay[dayIndex];
                if (daySegs) { // sparse array, so might be undefined

                    // append a day header
                    tbodyEl.append(this.dayHeaderHtml(
                        this.view.renderRange.start.clone().add(dayIndex, 'days')
                    ));

                    this.sortEventSegs(daySegs);

                    for (i = 0; i < daySegs.length; i++) {
                        tbodyEl.append(daySegs[i].el); // append event row
                    }
                }
            }

            this.el.empty().append(tableEl);
        },

        // Returns a sparse array of arrays, segs grouped by their dayIndex
        groupSegsByDay: function(segs) {
            var segsByDay = []; // sparse array
            var i, seg;

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
                    .push(seg);
            }

            return segsByDay;
        },

        // generates the HTML for the day headers that live amongst the event rows
        dayHeaderHtml: function(dayDate) {
            var view = this.view;
            var mainFormat = view.opt('listDayFormat');
            var altFormat = view.opt('listDayAltFormat');

            return '<tr class="fc-list-heading" data-date="' + dayDate.format('YYYY-MM-DD') + '">' +
                '<td class="' + view.widgetHeaderClass + '" colspan="3">' +
                (mainFormat ?
                    view.buildGotoAnchorHtml(
                        dayDate,
                        { 'class': 'fc-list-heading-main' },
                        htmlEscape(dayDate.format(mainFormat)) // inner HTML
                    ) :
                    '') +
                (altFormat ?
                    view.buildGotoAnchorHtml(
                        dayDate,
                        { 'class': 'fc-list-heading-alt' },
                        htmlEscape(dayDate.format(altFormat)) // inner HTML
                    ) :
                    '') +
                '</td>' +
                '</tr>';
        },

        // generates the HTML for a single event row
        fgSegHtml: function(seg) {
            var view = this.view;
            var classes = [ 'fc-list-item' ].concat(this.getSegCustomClasses(seg));
            var bgColor = this.getSegBackgroundColor(seg);
            var event = seg.event;
            var url = event.url;
            var timeHtml;

            if (event.allDay) {
                timeHtml = view.getAllDayHtml();
            }
            else if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day
                if (seg.isStart || seg.isEnd) { // outer segment that probably lasts part of the day
                    timeHtml = htmlEscape(this.getEventTimeText(seg));
                }
                else { // inner segment that lasts the whole day
                    timeHtml = view.getAllDayHtml();
                }
            }
            else {
                // Display the normal time text for the *event's* times
                timeHtml = htmlEscape(this.getEventTimeText(event));
            }

            if (url) {
                classes.push('fc-has-url');
            }

            return '<tr class="' + classes.join(' ') + '">' +
                (this.displayEventTime ?
                    '<td class="fc-list-item-time ' + view.widgetContentClass + '">' +
                    (timeHtml || '') +
                    '</td>' :
                    '') +
                '<td class="fc-list-item-marker ' + view.widgetContentClass + '">' +
                '<span class="fc-event-dot"' +
                (bgColor ?
                    ' style="background-color:' + bgColor + '"' :
                    '') +
                '></span>' +
                '</td>' +
                '<td class="fc-list-item-title ' + view.widgetContentClass + '">' +
                '<a' + (url ? ' href="' + htmlEscape(url) + '"' : '') + '>' +
                htmlEscape(seg.event.title || '') +
                '</a>' +
                '</td>' +
                '</tr>';
        }

    });

    ;;

    fcViews.list = {
        'class': ListView,
        buttonTextKey: 'list', // what to lookup in locale files
        defaults: {
            buttonText: 'list', // text to display for English
            listDayFormat: 'LL', // like "January 1, 2016"
            noEventsMessage: 'No events to display'
        }
    };

    fcViews.listDay = {
        type: 'list',
        duration: { days: 1 },
        defaults: {
            listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header
        }
    };

    fcViews.listWeek = {
        type: 'list',
        duration: { weeks: 1 },
        defaults: {
            listDayFormat: 'dddd', // day-of-week is more important
            listDayAltFormat: 'LL'
        }
    };

    fcViews.listMonth = {
        type: 'list',
        duration: { month: 1 },
        defaults: {
            listDayAltFormat: 'dddd' // day-of-week is nice-to-have
        }
    };

    fcViews.listYear = {
        type: 'list',
        duration: { year: 1 },
        defaults: {
            listDayAltFormat: 'dddd' // day-of-week is nice-to-have
        }
    };

    ;;

    return FC; // export for Node/CommonJS
});
!function(e){"function"==typeof define&&define.amd?define(["jquery","moment"],e):"object"==typeof exports?module.exports=e(require("jquery"),require("moment")):e(jQuery,moment)}(function(e,t){!function(){t.defineLocale("ja",{months:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),monthsShort:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),weekdays:"日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日".split("_"),weekdaysShort:"日_月_火_水_木_金_土".split("_"),weekdaysMin:"日_月_火_水_木_金_土".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY年M月D日",LLL:"YYYY年M月D日 HH:mm",LLLL:"YYYY年M月D日 HH:mm dddd",l:"YYYY/MM/DD",ll:"YYYY年M月D日",lll:"YYYY年M月D日 HH:mm",llll:"YYYY年M月D日 HH:mm dddd"},meridiemParse:/午前|午後/i,isPM:function(e){return"午後"===e},meridiem:function(e,t,a){return e<12?"午前":"午後"},calendar:{sameDay:"[今日] LT",nextDay:"[明日] LT",nextWeek:"[来週]dddd LT",lastDay:"[昨日] LT",lastWeek:"[前週]dddd LT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}日/,ordinal:function(e,t){switch(t){case"d":case"D":case"DDD":return e+"日";default:return e}},relativeTime:{future:"%s後",past:"%s前",s:"数秒",m:"1分",mm:"%d分",h:"1時間",hh:"%d時間",d:"1日",dd:"%d日",M:"1ヶ月",MM:"%dヶ月",y:"1年",yy:"%d年"}})}(),e.fullCalendar.datepickerLocale("ja","ja",{closeText:"閉じる",prevText:"&#x3C;前",nextText:"次&#x3E;",currentText:"今日",monthNames:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],monthNamesShort:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],dayNames:["日曜日","月曜日","火曜日","水曜日","木曜日","金曜日","土曜日"],dayNamesShort:["日","月","火","水","木","金","土"],dayNamesMin:["日","月","火","水","木","金","土"],weekHeader:"週",dateFormat:"yy/mm/dd",firstDay:0,isRTL:!1,showMonthAfterYear:!0,yearSuffix:"年"}),e.fullCalendar.locale("ja",{buttonText:{month:"月",week:"週",day:"日",list:"予定リスト"},allDayText:"終日",eventLimitText:function(e){return"他 "+e+" 件"},noEventsMessage:"イベントが表示されないように"})});